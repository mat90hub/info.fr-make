@c -*- coding: utf-8-unix; mode: texinfo; mode: auto-fill; ispell-local-dictionary: "francais" -*-
\input texinfo                @c -*- Texinfo -*-
@c ===========================================================================
@c
@c Version Française
@c
@c ===========================================================================
@c typographie française :    «   » …

@c %**start of header
@setfilename make.fr.info


@afourpaper
@documentencoding UTF-8
@documentlanguage fr_FR

@validatemenus off

@include version.fr.texi

@set EDITION 0.75

@settitle GNU @code{make}
@setchapternewpage odd
@c Combine the variable and function indices:
@syncodeindex vr fn
@c Combine the program and concept indices:
@syncodeindex pg cp
@c FSF publishers: format makebook.texi instead of using this file directly.
@c ISBN confirmed by Jasimin Huang <jasimin@fsf.org> on 25 Mar 2009
@set ISBN 1-882114-83-3
@c %**end of header

@copying
Ce fichier documente l'utilitaire GNU @code{make}, qui détermine
automatiquement sur un gros programme, quelles sont les parties qui
doivent être recompilées et qui exécute les commandes correspondantes.


This is Edition @value{EDITION}, last updated @value{UPDATED},
of @cite{The GNU Make Manual}, for GNU @code{make} version @value{VERSION}.

Copyright @copyright{} 2022 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover Texts being ``A GNU Manual,'' and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom.''
@end quotation
@end copying

@c finalout

@c ISPELL CHECK: done, 10 June 1993 --roland
@c ISPELL CHECK: done, 2000-06-25 --Martin Buchholz


@dircategory Développement logiciel
@direntry
* Make.fr: (make.fr).           Recompile des fichiers automatiquement.
@end direntry

@iftex
@shorttitlepage GNU Make
@end iftex
@titlepage
@title GNU Make
@subtitle Un programme pour orienter les recompilations
@subtitle GNU @code{make} Version @value{VERSION}
@subtitle @value{UPDATED-MONTH}
@author Richard M. Stallman, Roland McGrath, Paul D. Smith
@page
@vskip 0pt plus 1filll
@insertcopying
@sp 2
Published by the Free Software Foundation @* 51 Franklin St. -- Fifth Floor
@* Boston, MA 02110-1301 USA @* ISBN @value{ISBN} @*
@sp 2
Cover art by Etienne Suvasa.
@end titlepage

@summarycontents
@contents

@ifnottex
@node Top, Vue générale, (dir), (dir)
@top GNU @code{make}

@insertcopying
@end ifnottex


@include ndt.fr.texi


@node Vue générale, Introduction, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Vue générale de make

L'outil @code{make} détermine automatiquement pour un gros programme,
quelles parties nécessitent une recompilation et lance les commandes pour
le faire.  Ce manuel décrit GNU @code{make}, qui a été implémenté par
Richard Stallman et Roland McGrath. Depuis la version 3.76 le
développement est géré par Paul D. Smith.

GNU @code{make} est en conformité avec la section 6.2 de
@cite{IEEE Standard 1003.2-1992} (POSIX.2).
@cindex POSIX
@cindex IEEE Standard 1003.2
@cindex conformité aux standards

Notre exemple montre des programmes C, parce qu'ils sont les plus
communs, mais vous pouvez utiliser @code{make} avec n'importe quel
langage de programmation, qui a un compilateur pouvant être exécuté avec
une commande du shell.  En fait, @code{make} n'est pas limité aux
programmes.  Vous pouvez l'utiliser dès qu'il faut mettre des fichiers à
jour automatiquement dès que l'un des fichiers source qui ont servi à
les générer change.


@node Préparation, Comment lire ce manuel, Vue générale, Vue générale
@ifnottex
@heading Préparer et exécuter Make
@end ifnottex

Pour préparer l'utilisation de @code{make}, vous devez écrire un fichier
appelé @dfn{makefile}, qui décrit les relations entre les fichiers de
votre programme et donne les commandes à exécuter pour pour mettre à
chaque fichier. Le programme exécutable est typiquement mis à jour à partir
des fichiers objet, qui sont à leur tour mis à jour à partir des
fichiers source.@refill

Quand un fichier makefile convenable existe, chaque fois que vous
changez les fichiers source, le lancement de la simple commande shell@tie{}:

@example
make
@end example

@noindent
suffit à exécuter toute les recompilations nécessaires. Le programme
@code{make} utilise la base de données du @file{makefile} et les temps
des dernières modifications des fichiers pour décider lesquels de ces
fichiers devra être mis à jour.

Vous pouvez entre des arguments en ligne de commande pour indiquer à
@code{make} quel fichiers doivent être compilés ou non et comment.
@xref{Exécuter make,,Comment exécuter @code{make}}.

@node Comment lire ce manuel, Problèmes et erreurs, Préparation, Vue générale
@section Comment lire ce manuel

Si vous découvrez @code{make} pour la première fois ou que vous
cherchiez une introduction, lisez les premières sections de chaque
chapitre en laissant de côté les sections suivantes. Dans chaque
chapitre, les premières sections contiennent l'introduction générale,
puis viennet les informations plus spécifiques ou plus techniques.

L'exception est le second chapitre, @ref{Introduction, ,Une introduction
aux Makefiles} qui est une introduction dans son entier.

Si vous êtes familier avec d'autres programmes @code{make} voyez
@ref{Fonctionalités,,Fonctionnalités de GNU make}, qui liste les
améliorations qu'apporte GNU @code{make} et @ref{Manquants,
,Incompatibilités et fonctionnalités manquantes} qui explique les
quelques points qui manquent à GNU @code{make} comparé aux autres.

Pour un Résumé rapide, voir @ref{Résumé des options}, @ref{Référence
rapide}, et @ref{Les cibles spéciales}.

@node Problèmes et erreurs, , Comment lire ce manuel, Vue générale
@section Problèmes et erreurs
@cindex Signaler les erreurs
@cindex erreurs, signalement
@cindex problème et erreurs, signalement

Si vous rencontrez des problèmes avec @code{make} ou que vous pensez
avoir détecté une erreur (ndt. aussi appelée ``bug'', parfois aussi
traduit par bogue), merci de le signaler aux développeurs (ndt: en
Anglais)@tie{}; nous ne pouvons pas promettre de faire quelque chose, mais
nous pourrions bien vouloir le corriger.

Avant de reporter une erreur, vérifiez bien qu'il s'agit effectivement
d'une erreur. Relisez attentivement la documentation et voyez s'il est
vraiment dit que vous pouvez faire ce que vous essayez. S'il n'est pas
clair, que vous devriez pouvoir faire quelque chose ou non, signalez le
aussi@tie{}; il s'agit d'un manque dans la documentation !

Avant de signaler une erreur ou de chercher à la corriger par vous-même,
essayez de l'isoler dans le plus petit @file{makefile} qui reproduise le
problème. Ensuite, envoyez-nous ce fichier @file{makefile} et les
resultats précis que @code{make} vous a donné, en incluant les messages
d'avertissements ou d'erreur eventuels. S'il vous plaît, ne paraphrasez
pas ces messages. Le mieux est est de les couper et les coller dans
votre rapport. Quand vous générer ce petit @file{makefile}, soyez sûr de
ne pas utiliser des utilitaires non-libres de droits ou inusuels dans
vos instructions@tie{}: vous pouvez presque toujours les émuler avec des
commandes Shell simples. Finalement, assurez-vous d'expliquer ce que
vous vous attendiez à obtenir@tie{}; cela nous aidera pour décider si le
problème était vraiment dans la documentation.

Quand vous avez précisé le problème, vous pouvez le signaler de deux
façons. Soit par courrier electronique en l'envoyant à@tie{}:

@example
    bug-make@@gnu.org
@end example

@noindent
soit en utilisant notre outils réseau de management de projet à l'adresse@tie{}:

@example
    http://savannah.gnu.org/projects/make/
@end example

@noindent
En supplément aux information ci-dessus, merci d'inclure le numéro de
version du programme @code{make} que vous utilisez. Vous pouvez obtenir
cette information avec la commande @samp{make --version}. Assurez-vous
aussi d'inclure le type de machine et de système d'exploitation que vous
utilisez. Ceci peut s'obtenir en regardant les dernières lignes de la
sortie de la commande @samp{make --help}.

@node Introduction, Les Makefiles, Vue générale, Top
@comment  node-name,  next,  previous,  up
@chapter Une introduction aux Makefiles

Pour dire au programme @code{make} ce qu'il faut faire, vous avez besoin
d'un fichier appelé @dfn{makefile}. La plupart du temps, ce fichier
@file{makefile} dit comment compiler et lier un programme.
@cindex makefile

Dans ce chapitre, nous présentons un fichier @file{makefile} élémentaire
qui décrit comment compiler et lier un programme éditeur de texte
(appelé @code{edit}) qui consiste en huit fichiers sources en @code{C} et
trois fichiers d'en-têtes. Un fichier @file{makefile} peut aussi dire
au programme @code{make} d'exécuter d'autres commandes diverses,
quand on le lui demande explicitement (par exemple pour effacer certains
fichiers dans une opération de nettoyage). Pour voir des exemples plus
complexes de fichier @file{makefile}, voir @ref{Makefile complexe}.

Quand @code{make} recompile le programme @code{edit}, chacun des
fichiers sources @code{C} doit être recompilé. Si un fichier d'en-tête a
changé, chacun des fichiers source @code{C} qui contient un appel à ce
fichier d'en-tête doit être recompilé par sécurité. Et finalement, si
un fichier source a été recompilé, tous les fichiers objet, qu'ils
soient nouvellement crées ou déjà sauvegardés par une compilation
précédente, doivent être liés ensemble pour produire le nouvel
exécutable de ce programme @code{edit}.
@cindex recompilation
@cindex edit

@node Introduction aux règles, Un makefile simple, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section À quoi ressemble une règle
@cindex règles, introduction
@cindex La partie contenant les règles d'un makefile
@cindex parties contenant les règles d'un makefile

Un fichier @file{makefile} élémentaire consiste en ``règles'' qui
ressemblent à ceci@tie{}:

@cindex cibles, introduction
@cindex pré-requis, introduction
@cindex instructions, introduction
@example
@group
@var{cible} @dots{}@tie{}: @var{pré-requis} @dots{}
        @var{instruction}
        @dots{}
        @dots{}
@end group
@end example

Une @dfn{cible} (ndt. @dfn{target}) est typiquement le nom d'un fichier
généré par un programme@tie{}; les exemples de cibles sont les exécutables
ou bien les fichiers objet. Mais une cible peut être aussi le nom d'une action à
accomplir, comme pour @samp{clean} (@pxref{Les cibles fictives}).

Un @dfn{pré-requis} (ndt. @dfn{prerequisite}) est un fichier qui est utilisé
comme une donnée d'entrée pour créer une cible. Une cible dépend souvent de
plusieurs fichiers. 

@cindex tabulations dans les règles
Une @dfn{instruction} et une action que @code{make} va exécuter. Une instruction
peut être composée de plusieurs commandes, soit toutes sur la même ligne,
soit chacune sur sa propre ligne.

@strong{À noter:} vous avez besoin de mettre un caractère de tabulation
au début de chaque ligne d'instruction@tie{}! C'est une obscurité qui peut faire
achopper les débutants. Si vous préférez préfixer votre instruction avec un
autre caractère que la tabulation, vous pouvez régler la variable
@code{.RECIPEPREFIX} sur un autre caractère (@pxref{Variables
spéciales}).

Normalement une instruction se trouve dans une règle avec des pré-requis
et elle sert à créer un fichier cible si l'un des pré-requis
change. Cependant, la règle qui utilise une instruction pour obtenir une
cible n'a pas besoin de pré-requis. Par exemple, la règle contenant la
commande d'effacement associée à la cible @samp{clean} n'en n'a pas.

Une @dfn{règle} explique donc comment et quand il faut recompiler
certains fichiers, qui sont les cibles d'une règle particulière. Le
programme @code{make} exécute des instructions sur des pré-requis pour créer
ou mettre des cibles à jour. Une règle peut aussi expliquer comment et
quand lancer une action.  @xref{Les règles,,Écrire les règles}.

Un makefile peut contenir autre chose à côté des règles, mais un makefile
simple n'a besoin de contenir que des règles. Les règles peuvent être un peu
plus compliquées que ce modèle, mais elles s'y ramènent d'une façon ou
d'une autre.

@node Un makefile simple, Comment fonctionne Make, Introduction aux règles, Introduction
@section Un Makefile simple
@cindex Un Makefile simple
@cindex simple, Makefile

Voici un makefile qui décrit directemment la façon dont un fichier
exécutable appelé @code{edit} dépend de huit fichiers objet, qui à leur
tour, dépendent de huit fichiers source C et de trois fichiers
d'en-têtes.

Dans cet exemple, tous les fichiers C incluent @file{defs.h}, mais
seulement ceux qui définissent des commandes d'édition incluent
@file{command.h} et seulement les fichiers de bas niveau qui modifient
le tampon de l'éditeur incluent le fichier @file{buffer.h}.

@example
@group
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
@end group
@end example

@noindent
Les lignes qui trop longues sont coupées en deux en utilisant la barre
oblique inversée suivie du caractère de nouvelle ligne@tie{}; c'est
fonctionnellement la même chose qu'une longue ligne, mais c'est plus
simple à lire.  @xref{Couper les lignes,,Couper les lignes trop
longues}.
@cindex Les lignes de continuation
@cindex @code{\} (barre oblique inversée), continuation de lignes
@cindex barre oblique inversée (@code{\}), pour les continuations de lignes
@cindex échapper les nouvelles lignes, dans un makefile
@cindex newline, quoting, in makefile
@cindex nouvelle ligne, échapper, dans un makefile

Pour créer le fichier exécutable appelé @file{edit} avec ce makefile
entrez simplement@tie{}:

@example
make
@end example

Pour effacer le fichier exécutable et tous les fichiers objet du
répertoire avec ce makefile entrez@tie{}:

@example
make clean
@end example

Dans l'exemple de ce makefile, les cibles incluent le fichier exécutable
@samp{edit} ainsi que les fichiers objet @samp{main.o} et @samp{kbd.o}.
Les pré-requis sont les fichiers comme @samp{main.c} et @samp{defs.h}.
En fait, chaque fichier @samp{.o} est à la fois une cible et un
pré-requis. Les instructions incluent @w{@samp{cc -c main.c}} et @w{@samp{cc
-c kbd.c}}.

Quand une cible est un fichier, elle a besoin d'être recompilée et liée
si l'un des pré-requis change. En plus, chaque pré-requis qui est
lui-même généré doit être mis à jour avant. Dans cet exemple,
@file{edit} dépend de chacun des huit fichiers objets@tie{}; le fichier objet
@file{main.o} dépend du fichier source @file{main.c} et de l'en-tête
file @file{defs.h}.

Une instruction peut suivre chaque ligne qui contient une cible et un
pré-requis. Ces instructions disent comment mettre un fichier cible à
jour.  Un caractère de tabulation (ou tout caractère spécifié par la
variable @code{.RECIPEPREFIX}@tie{}; @pxref{Variables spéciales}) doit
venir au début de chaque ligne d'instruction pour les distinguer des
autres lignes du makefile.  (Gardez en mémoire que @code{make} ne sait
rien du fonctionnement d'une instruction. C'est à vous de définir des
instructions qui mettront la cible à jour correctement.  Tout ce que
fait @code{make} n'est que d'exécuter les instructions que vous avez
spécifiées quand le fichier cible doit être mis à jour.)@refill
@cindex instruction

La cible @samp{clean} n'est pas un fichier, mais plutôt le nom d'une
action.  Comme vous ne voulez normalement pas exécuter les actions de
cette règle, @samp{clean} n'est le pré-requis d'aucune des autres
règles.  En conséquence @code{make} ne fait jamais rien avec, sauf si
vous le lui dites spécifiquement. Notez que cette règle, non seulement
n'est pas un pré-requis, mais qu'elle n'a pas non plus de pré-requis,
donc le seul objectif de cette règle est d'exécuter l'instruction
spécifiée. Les cibles qui ne font pas référence à des fichiers et qui ne
sont que des actions sont appelées des @dfn{Les cibles fictives}
(ndt. ``phony targets'').  @xref{Les cibles fictives}, pour plus
d'information sur ce genre de cibles.  @xref{Erreurs dans les
instructions, , Erreurs dans les instructions}, pour voir comment
demander à @code{make} d'ignorer les erreurs renvoyées par des commandes
comme @code{rm} ou d'autres du même type.
@cindex @code{clean} cible
@cindex @code{rm} (shell command)

@node Comment fonctionne Make, Les variables simplifient, Un makefile simple, Introduction
@comment  node-name,  next,  previous,  up
@section Comment make traite un Makefile
@cindex traiter un makefile
@cindex makefile, comment make traite

Par défaut @code{make} débute avec la première cible (en excluant les
cibles commençant par @samp{.}).  Cet objectif est appelé
@dfn{l'objectif par défaut}.  (Les @dfn{objectifs} sont les cibles que
@code{make} cherche à mettre finalement à jour. Vous pouvez modifier ce
comportement en utilisant la ligne de commande (@pxref{Objectifs,
,Arguments pour spécifier les objectifs}) ou avec la variable spéciale
@code{.DEFAULT_GOAL} (@pxref{Variables spéciales, , autres variables
spéciales}).
@cindex objectif par défaut
@cindex objectif, par défault
@cindex objectif

Dans l'exemple simple de la section précédente, l'objectif par défaut
est de mettre le programme @file{edit} à jour@tie{}; c'est pourquoi nous
mettons cette règle en premier.

Ainsi quand vous entrez la commande@tie{}:

@example
make
@end example

@noindent
Le programme @code{make} lit le @file{Makefile} du répertoire courant et
commence par exécuter la première règle. Dans cet exemple, cette règle
relance l'éditeur de liens pour le programme @file{edit}@tie{}; mais
avant que @code{make} ne puisse exécuter cette règle, il doit exécuter
les règles pour les fichiers dont @file{edit} dépend et qui sont ici les
fichiers objet. Chacun de ces fichiers est traité selon sa propre
règle. Ces règles disent de mettre chaque fichier @samp{.o} à jour en
compilant son fichier source. La recompilation doit être faite si les
fichiers source ou l'un des fichiers d'en-tête nommés en pré-requis est
plus récent que le fichier objet actuel ou si le fichier objet n'existe
pas.

Ces autres règles sont donc exécutées car leurs cibles apparaissent
comme pré-requis de l'objectif. Si elles n'étaient pas des conditions
pour cet objectif (ou parmi ses dépendances), ces règles ne seraient pas
exécutées, sauf si vous demandiez à @code{make} explicitement (comme
pour la commande @w{@code{make clean}}).

Avant de recompiler un fichier objet, @code{make} analyse les mises à
jour demandées par les pré-requis, les fichiers source et les fichiers
d'en-têtes. Ce @file{Makefile} ne spécifie pas autre chose pour eux
---@tie{}les fichiers @samp{.c} et @samp{.h} ne sont les cibles
d'aucune règle@tie{}--- donc @code{make} ne fait rien pour ces
fichiers. Mais @code{make} mettrait automatiquement à jour des
programmes C qui aurait pu être générés, comme ceux qu'aurait pu générer
@code{Bison} ou @code{Yacc} avec leur propres règles du moment.

Après avoir recompilé les fichiers objet nécessaires, @code{make}
décide de refaire ou non l'édition de liens pour @file{edit}. Ceci doit
être fait si le fichier @file{edit} n'existe pas ou si l'un des
fichiers objet est plus récent que lui. Si un fichier objet vient juste
d'être recompilé, il est maintenant plus récent que @file{edit}, donc
l'édition de liens est relancée.
@cindex Refaire l'édition de liens

Donc, si nous changeons le fichier @file{inser.c} et que nous exécutons
@code{make}, @code{make} compilera ce fichier pour mettre à jour 
@file{insert.o} et refera son lien avec @file{edit}. Si nous
changeons le fichier @file{command.h} et que nous exécutons @code{make},
@code{make} recompilera alors le fichier objet @file{kbd.o},
@file{command.o} et @file{files.o} et fera ensuite l'édition de liens du
programme @file{edit}.


@node Les variables simplifient, Laisser make déduire, Comment fonctionne Make, Introduction
@section Les variables rendent les Makefiles plus simples
@cindex variables
@cindex simplifier avec des variables

Dans notre exemple, nous devions lister les fichiers objet par deux
fois dans les règles compilant @file{edit} (voici cette règle répétée ici)@tie{}:

@example
@group
edit : main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
@end group
@end example

@cindex @code{objets}
Ce type de duplications est source d'erreur@tie{}; si un nouveau fichier
objet est ajouté au système, nous pourrions l'ajouter à l'une des listes
et l'oublier dans l'autre. Nous pouvons éliminer ce risque et
simplifier le fichier @file{Makefile} en utilisant une variable. Les
@dfn{variables} permettent de définir une chaîne de texte une fois pour
toute, pour ensuite la substituer en plusieurs endroits (@pxref{Utiliser
les variables, ,Comment utiliser les variables}).

@cindex @code{OBJETS}
@cindex @code{objs}
@cindex @code{OBJS}
@cindex @code{obj}
@cindex @code{OBJ}
C'est une pratique standard pour tous les @file{Makefile} d'avoir une
variable nommée @code{objects}, @code{OBJECTS}, @code{objs},
@code{OBJS}, @code{obj} ou encore @code{OBJ} qui est la liste de tous
les fichiers objet. Nous définissons la variable @code{object}
avec une ligne similaire à celle-ci dans le @file{Makefile}:@refill

@example
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
@end group
@end example

@noindent
Ainsi à chaque fois que nous voulons mettre la liste des fichiers
objets, nous pouvons lui substituer la valeur de cette variable en écrivant
@samp{$(objects)} (@pxref{Utiliser les variables, ,How to Use
Variables}).

Voici à quoi ressemblerait le fichier de @file{Makefile} que nous avons
vu, si nous utilisions une variable pour la liste des fichiers
objets@tie{}:

@example
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)\n"
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
@end group
@end example

@node Laisser make déduire, Combiner les pré-requis., Les variables simplifient, Introduction
@section Laisser @code{make} déduire les instructions
@cindex déduire les instructions (règles implicites)
@cindex règles implicites, introduction
@cindex règles, implicites, introduction

Il n'est pas nécessaire d'épeler les instructions pour compiler des
fichiers individuels de source C, car @code{make} peut les retrouver par
lui-même@tie{}: c'est une @dfn{règle implicite} de mettre un fichier
@samp{.o} à jour en utilisant la commande @samp{cc -c} sur le fichier
@samp{.c} correspondant. Par exemple, elle utiliserait l'instruction
@samp{cc -c main.c -o main.o} pour compiler @file{main.c} en
@file{main.o}. Nous pouvons donc omettre ces instructions dans les
règles, qui veulent obtenir ces fichiers objets.  @xref{Les règles
implicites, ,Utiliser les règles implicites}.@refill

Quand un fichier @samp{.c} est utilisé de cette façon en automatique, il
est aussi automatiquement ajouté à la liste des pré-requis. On peut donc
aussi omettre les fichiers @samp{.c} des pré-requis, si l'instruction a
été ainsi omise.

Voici l'exemple entier, avec ces deux changements apportés en même temps et une
variable @code{objects} comme suggérée avant@tie{}:

@example
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
@end group
@end example

@noindent
Ceci est donc la façon pratique dont on écrirait réellement le fichier
@file{Makefile}. (Les complications associées à @samp{clean} sont
décrites plus loin. Voir @ref{Les cibles fictives}, et @ref{Erreurs dans
les instructions, ,Erreurs dans les instructions}.)

Parce que les règles implicites sont si commodes, elles sont
importantes. Vous verrez que vous les utiliserez fréquemment.@refill

@node Combiner les pré-requis., Nettoyage, Laisser make déduire, Introduction
@section Un autre style de Makefile
@cindex Combiner les règles dans les pré-requis

Quand les objets d'un @file{Makefile} ne sont créés que par des règles
implicites, un style alternatif de @file{Makefile} est possible. Dans ce
style de @file{Makefile}, vous groupez les entrées par leur pré-requis
au lieu de les grouper par leur cibles. Voici à quoi cela ressemble@tie{}:

@example
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit@tie{}: $(objects)
        cc -o edit $(objects)
$(objects)@tie{}: defs.h
kbd.o command.o files.o@tie{}: command.h
display.o insert.o search.o files.o@tie{}: buffer.h
@end group
@end example

@noindent
Ici le fichier @file{defs.h} est donné comme un pré-requis à tous les
fichiers objets@tie{}; @file{command.h} et @file{buffer.h} sont des
pré-requis de certains fichiers objets listés pour eux.

Savoir si c'est mieux ainsi est affaire de goût@tie{}: l'écriture est plus
compacte, mais certaines personnes ne l'aiment pas car elles trouvent
qu'il est plus clair de mettre toutes les informations pour chaque cible
à un seul endroit.

@node Nettoyage, , Combiner les pré-requis., Introduction
@section Règles pour nettoyer le répertoire
@cindex nettoyage
@cindex enlever, nettoyer

Compiler un programme n'est peut être pas la seule chose pour laquelle
vous voudrez écrire une règle. Les @file{Makefile} font communément
d'autres choses à côté de la compilation@tie{}: par exemple, effacer tous
les fichiers objets et les exécutables pour que le répertoire reste
@samp{propre} (ndt. @samp{clean}).

@cindex @code{clean} target
Voici comment écrire une règle @code{make} pour nettoyer notre exemple
d'éditeur@tie{}:

@example
@group
clean:
        rm edit $(objects)
@end group
@end example

En pratique, on peut vouloir écrire une règle de manière un peu plus
compliquée pour traiter des situations non anticipées. Nous ferions
alors ceci@tie{}:

@example
@group
.PHONY : clean
clean :
        -rm edit $(objects)
@end group
@end example

@noindent
Ceci empêche @code{make} d'être mis en défaut à cause d'un fichier, qui
aurait été appelé @file{clean}, et aussi de continuer malgré les erreurs
possibles de @code{rm}. (Voir @ref{Les cibles fictives}, and
@ref{Erreurs dans les instructions, ,Erreurs dans les instructions}.)

@noindent
Une règle comme celle ci ne devrait jamais être placée au début d'un
@file{Makefile}, car nous ne voulons pas qu'elle s'exécute par
défaut@tie{}!  Dans notre exemple de @file{Makefile}, nous voulons que
la règle @code{edit} par défaut reste celle qui recompile l'éditeur.

Comme @code{clean} n'est pas un pré-requis de @code{edit}, cette règle
ne sera pas exécutée si nous lançons la commande @samp{make} sans
argument. Pour lancer cette règle, il faudra explicitement écrire
@samp{make clean}. @xref{Exécuter make, ,Comme exécuter @code{make}}.

@node Les Makefiles, Les règles, Introduction, Top
@chapter Écrire les Makefiles

@cindex makefile, comment écrire
Les informations qui disent à @code{make} comment recompiler un système
viennent de la lecture d'une base de données appelée @dfn{Makefile}.

@node Le contenu d'un makefile, Les noms des makefiles, Les Makefiles, Les Makefiles
@section Que contient un makefile

Un @file{Makefile} a cinq types de contenus@tie{}: @dfn{les règles explicites},
@dfn{les règles implicites}, @dfn{les définitions de variables}, @dfn{les
directives} et @dfn{les commentaires}. Les règles, les variables et les
directives sont décrites en détail dans les chapitres qui suivent.@refill

@itemize @bullet
@cindex règle, explicite, définition
@cindex règle explicite, définition
@item
Une @dfn{règle explicite} dit quand et comment refaire un ou plusieurs
fichiers, appelés les @dfn{cibles} pour cette règle. Elle liste les autres
fichiers, dont la cible dépend et qui sont appelés les @dfn{pré-requis}
de la cible. Elle peut aussi donner une instruction à utiliser pour créer
ou mettre à jour les cibles. @xref{Les règles, ,Écrire des règles}.

@cindex règle, implicite, définition
@cindex règle implicite, définition
@item
Une @dfn{règle implicite} dit quand et comment refaire une classe de
fichiers en se basant sur leur noms. Elle décrit comment la cible peut
dépendre d'un fichier dont le nom est similaire à la cible et donne la
instruction pour créer et mettre à jour une telle cible. @xref{Les règles
implicites, ,Utiliser des règles implicites}.

@cindex définition de variable
@item
Une @dfn{définition de variable} est une ligne qui spécifie une chaîne
de texte à donner à une variable et qui pourra lui être substituée plus
tard dans le texte. L'exemple de @file{Makefile} simple montre la
définition d'une variable @code{objects} qui est la liste de tous les
fichiers objets.  (@pxref{Les variables simplifient, , les variables
rendent les Makefiles plus simples}).

@cindex directive
@item
Une @dfn{directive} est une instruction pour @code{make} pour qu'il réalise
quelque chose de spécial en lisant le @file{Makefile}. Ceci inclut@tie{}:

@itemize @bullet
@item
Lire un autre fichier @file{Makefile} (@pxref{Inclure d'autres
makefiles, ,Inclure d'autres Makefiles}).

@item
Décider (sur la base de la valeur de variables) si on utilise ou on
ignore certaines parties du @file{Makefile} (@pxref{Les parties
conditionnelles, ,Les parties conditionnelles des Makefiles}).

@item
Définir une variable à partir d'une chaîne verbatim contenant plusieurs
lignes
(@pxref{Variables sur plusieurs lignes, ,Définir ds variable sur plusieurs lignes}).
@end itemize

@cindex commentaires, dans un Makefile
@cindex @code{#} (commentaires), dans un Makefile
@item
@samp{#} sur une ligne d'un @file{Makefile} débute un
@dfn{commentaire}. Tout le reste de la ligne, signe @samp{#} compris,
sera ignoré, sauf si une barre oblique inversée non échappée par une
autre barre oblique inversée se trouve en fin de ligne, auquel cas, le
commentaire continue sur la ligne suivante. Une ligne ne contenant qu'un
commentaire (avec peut être des espaces devant) est effectivement
blanche et ignorée. Si vous voulez utiliser le caractère littéral
@code{#}, échappez le avec une barre oblique inversée
(i.e. @code{\#}). Les commentaires peuvent apparaître sur n'importe
quelle ligne dans le @file{Makefile}, bien qu'ils puissent être traités
de manière spéciale dans certaines situations.

Vous ne pouvez pas utiliser de commentaire dans une références de
variable ou dans un appel de fonction@tie{}: à l'intérieur d'une
référence de variable et d'un appel de fonction, chaque instance de
@code{#} sera traitée littéralement (au lieu d'être le début d'un
commentaire)

À l'intérieur des instructions, les commentaires sont simplement passés au
shell comme tout autre partie du texte de cette instruction. C'est donc le
shell qui décidera finalement s'il le traite comme un commentaire ou
non.

À l'intérieur d'une directive @code{define}, les commentaires sont
ignorés durant la définition de la variable, mais conservés intact dans
la valeur de la variable. Quand la variable est développée, ils seront
traités soit comme des commentaires de @code{make} soit comme le texte
d'une instruction, tout dépendant du contexte dans le lequel cette variable
est évaluée.
@end itemize

@node Couper les lignes, ,Le contenu d'un makefile, Le contenu d'un makefile
@subsection Couper les lignes longues
@cindex couper les lignes longues
@cindex lignes longues, couper
@cindex bar oblique inversée (@code{\\}), pour échapper les sauts de lignes

Les @file{Makefiles} utilisent une syntaxe, qui repose sur les lignes et
pour laquelle le caractère de nouvelle ligne est une marque spéciale
marquant la fin d'une instruction. GNU @code{make} n'a pas de limite
pour le longueur d'une ligne d'instruction, jusqu'à la limite de mémoire
de l'ordinateur.

Cependant, il est difficile de lire les lignes qui sont trop longues
pour être affichées sans avoir à faire de défilement horizontal de
l'écran ou faire des retours automatiques de ligne. Pour une meilleure
lisibilité de vos @file{Makefiles}, vous pouvez les reformater en
ajoutant un saut de ligne au milieu d'une instruction. Vous le faites en
échappant le caractère de nouvelle ligne avec une barre oblique
inversée (@code{\}). Quand nous avons besoin de faire la distinction
nous référerons aux ``lignes physiques'' comme des lignes uniques
terminant par un caractère de nouvelle ligne (sans tenir compte si ce
caractère de nouvelle ligne est échappé ou non) et aux ``lignes
logiques'' étant une instruction complète, incluant toutes les lignes
échappées jusqu'à la première fin de ligne non échappée.

La façon dont la combinaison des barres obliques inversées et les
caractères de nouvelles lignes sont traités, dépend de savoir si
l'instruction est une ligne d'instruction ou non. Le traitement des barres
obliques inversées et des caractères de nouvelle ligne dans une
instruction d'instruction est discuté plus tard
(@pxref{Couper les lignes d'instructions}).

En dehors des instructions, une barre oblique inversée combinée avec le
caractère de nouvelle ligne est converti en un seul caractère
espace. Quand la substitution est faite, tous les espaces blancs autour
des barres obliques inversées combinées à des nouvelles lignes sont
condensés en un seul caractère d'espace@tie{}: ceci inclut tous les
espaces blancs qui précèdent les barres obliques inversées au début de
chaque ligne après la combinaison d'une barre oblique inversée avec une
nouvelle ligne et toutes les autres combinaisons suivantes.

Si la cible spéciale @code{.POSIX} est définie, alors les barres
obliques inversées suivies d'une nouvelle ligne sont traitées un peu
différemment pour se conformer au standard POSIX.2@tie{}: d'abord, les espaces
blancs précédant une barre oblique inversée ne sont pas enlevés et
ensuite, les suites de combinaisons de barres obliques inversées avec
une nouvelle ligne ne sont pas condensées.

@subsubheading Couper sans ajouter d'espace blanc
@cindex espace blanc, éviter sur les lignes coupées
@cindex enlever les espaces blancs des lignes coupées

Si vous avez besoin de couper une ligne, mais que vous ne voulez
@emph{pas} ajouter d'espaces blancs, vous pouvez utiliser une astuce
subtile@tie{}: remplacer vos paires de barres obliques inversées et de
nouvelle ligne avec les trois caractères signe dollar, barre oblique
inversée et caractère de nouvelle ligne@tie{}:

@example
var := one$\
       word
@end example

Après que @code{make} ait enlevé les caractères de barre oblique
inversée et de nouvelle ligne et ait condensé la ligne suivante en un seul
espace, ceci est équivalent à@tie{}:

@example
var := one$ word
@end example

Ensuite @code{make} va exécuter un développement de variable.  La
référence de variable @samp{$} se réfère à une variable avec le seul
caractère `` '' (l'espace) qui n'existe pas et donc se développe en une
chaîne vide en donnant une instruction d'assignement qui revient finalement
à@tie{}:

@example
var := oneword
@end example


@node Les noms des makefiles, Inclure d'autres makefiles, Le contenu d'un makefile, Les Makefiles
@section Quel nom donner à votre Makefile
@cindex nom de makefile
@cindex name of makefile
@cindex nom par défaut d'un Makefile
@cindex nom de fichier d'un makefile

Par défaut, quand @code{make} cherche un @file{Makefile}, il essaie dans
cet ordre les noms suivants@tie{}: @file{GNUmakefile}, @file{makefile} et
@file{Makefile}.@refill
@findex Makefile
@findex GNUmakefile
@findex makefile

@cindex @code{README}
Normalement, vous devriez appeler votre @file{makefile} @file{makefile}
ou @file{Makefile}. (Nous recommandons @file{Makefile} car il apparait
ainsi de manière plus saillante en début de liste de fichier d'un
répertoire, proche d'autres fichiers importants comme le fichier
@file{README}.) Le premier nom de la liste standard des noms vérifiés,
@file{GNUmakefile}, n'est la plupart du temps pas recommandé. Vous ne
devriez utiliser ce nom que si vous avez un fichier makefile spécifique
à GNU @code{make} et qui ne serait pas compris par d'autres versions
de @code{make}. Les autres programmes @code{make} recherchent
@file{makefile} et @file{Makefile}, mais pas @file{GNUmakefile}.

Si @code{make} ne trouve aucun de ces noms standards, il n'utilise alors
aucun makefile. Vous devrez alors spécifier un objectif par un argument
de commande et @code{make} essayera de se figurer comme le recompiler en
utilisant seulement ses règles implicites prédéfinies. @xref{Les
règles implicites, ,Utiliser les règles implicites}.

@cindex @code{-f}
@cindex @code{--file}
@cindex @code{--makefile}
Si vous voulez utiliser un nom non-standard pour vos makefiles, vous
pouvez spécifier le nom du makefile avec l'otpion @samp{-f} ou
@samp{--file}.  Les arguments @w{@samp{-f @var{name}}} ou
@w{@samp{--file=@var{name}}} disent à @code{make} de lire le fichier
@var{name} comme makefile.  Si vous utilisez plus d'une option @samp{-f}
ou @samp{--file}, vous pouvez spécifier plusieurs makefiles.  Tous les
makefiles seront effectivement concaténés dans l'ordre spécifié.  Les noms
de makefile par défaut @file{GNUmakefile}, @file{makefile} et
@file{Makefile} ne sont pas vérifiés automatiquement si vous spécifiez
@samp{-f} ou @samp{--file}.@refill
@cindex spécifier un nom de makefile
@cindex nom de makefile, comment spécifier
@cindex nom de makefile, comment spécifier
@cindex nom de fichier d'un makefile, comment spécifier

@node Inclure d'autres makefiles, La Variable MAKEFILES, Les noms des makefiles, Les Makefiles
@section Inclure d'autres Makefiles
@cindex inclure d'autres makefiles
@cindex makefile, inclure

@findex inclure
La directive @code{include} dit à @code{make} de suspendre la lecture du
fichier makefile courant pour en lire un autre, ou plusieurs autres,
avant de continuer. Cette directive est une ligne du makefile qui
ressemble à ceci@tie{}:

@example
include @var{filenames}@dots{}
@end example

@noindent
La variable @var{filenames} peut contenir un motif shell de nom de
fichier.  Si la variable @var{filenames} est vide, rien n'est inclu et
aucune erreur n'est reportée.

@cindex motif de nom de fichier (dans @code{include})
@cindex les caractères spéciaux des shell (dans @code{include})
@cindex caractères spéciaux, dans @code{include}

Les espaces supplémentaires ne sont pas permis et sont ignorés en début
de ligne, mais le premier caractère ne doit pas être une tabulation (ou
ne pas être la valeur définie par @code{.RECIPEPREFIX}) ---@tie{}si la
ligne commence par une tabulation, elle serait considérée comme une
ligne définissant une instruction.  Les espaces blancs sont requis entre
le mot clé @code{include} et les noms de fichiers qui suivent et entre
les noms de fichiers eux-mêmes@tie{}; les espaces blancs supplémentaires
sont ignorés à cette endroit et à la fin de la ligne de directive.  Un
commentaire commençant par @samp{#} est permis en fin de ligne.  Si le
nom de fichier contient une variable ou une référence de fonctions,
elles sont développées.  @xref{Utiliser les variables, ,Comment utiliser
les variables}.

Par exemple, si vous avez trois fichier @file{.mk}, @file{a.mk}, @file{b.mk},
et @file{c.mk}, et que @code{$(bar)} se développe en @code{bish bash},
alors l'expresssion suivante

@example
include foo *.mk $(bar)
@end example

est équivalente à

@example
include foo a.mk b.mk c.mk bish bash
@end example

Quand @code{make} exécute une directive @code{include}, il suspend la
lecture du contenu du makefile en cours pour lire celui de chaque fichier
listé, l'un après l'autre.  Quand ceci est fini, @code{make} revient à
la lecture du makefile dans laquelle la directive est apparue.

Une occasion typique pour utiliser les directives @code{include} est
quand plusieurs programmes sont gérés par des makefiles individuels
situés chacun dans un répertoire différent et qu'ils ont besoin d'un
ensemble commun de définition de variables (@pxref{Définir une variable, ,Définir des
variables}) ou de modèles de règles (@pxref{Modèle de règles, ,Définir
et re-définir des modèles de règles}).

Une autre occasion est quand vous générez des pré-requis automatiquement
depuis les fichiers source@tie{}; ces pré-requis peuvent être mis dans
un fichier qui est ensuite inclus par le makefile.  C'est une manière de
faire qui est généralement plus claire que celle d'ajouter les
pré-requis d'une manière ou d'une autre à la fin du makefile comme cela
était traditionnellement fait dans les anciennes versions de
@code{make}.  @xref{Pré-requis automatiques}.
@cindex pré-requis, génération automatique
@cindex génération automatique des pré-requis
@cindex générer les pré-requis automatiquement

@cindex @code{-I}
@cindex @code{--include-dir}
@cindex makefiles inclus, répétoire par défaut
@cindex répertoire par défaut des makefiles inclus
@findex /usr/gnu/include
@findex /usr/local/include
@findex /usr/include
Si le nom spécifié ne commence pas par une barre oblique et que le
fichier n'est pas trouvé dans le répertoire courant, la recherche est
étendue à plusieurs autres répertoires. D'abord la recherche s'étend à
tous les répertoires que vous avez spécifiés par l'option @samp{-I} ou
@samp{--include-dir} (@pxref{Résumé des options,,Résumé des options}).
Ensuites les répertoires suivants sont examinés (s'ils existent) dans
cet ordre@tie{}: @file{@var{prefix}/include} (normalement
@file{/usr/local/include} @footnote{quand GNU Make est compilé pour
MS-DOS et MS-Windows il se comporte comme si @var{prefix} avait été
défini comme étant la racine de l'arbre hiérarchique de DJGPP.})
@file{/usr/gnu/include}, @file{/usr/local/include}, @file{/usr/include}.

Si aucun fichier makefile inclus ne peut être trouvé dans aucuns de ces
répertoires, un message d'avertissement est généré, mais ceci ne conduit
pas immédiatement à une erreur fatale@tie{}; l'exécution du makefile
contenant la directive @code{include} continue.  Une fois que la lecture
des makefiles est terminée, @code{make} essayera de re-compiler chaque
fichier périmé et ceux qui n'existent pas encore.  @xref{Reconstruire les
Makefiles, ,Comment les Makefiles sont refaits}.  C'est seulement après
avoir essayé de trouver un moyen de refaire un makefile qui a échoué, que
@code{make} diagnostiquera le makefile manquant comme une erreur fatale.

Si vous voulez que @code{make} ignore simplement un makefile qui
n'existe pas ou qui ne peut pas être reconstruit, sans avoir de message
d'erreur, utilisez la directive @w{@code{-include}} à la place de
@code{include} comme ceci@tie{}:

@example
-include @var{filenames}@dots{}
@end example

Ceci se comporte comme @code{include} sur tous ses aspects, excepté
qu'il n'y a pas d'erreur (et même pas d'avertissement) si aucun des
fichiers @var{filenames} (ou aucun de leur pré-requis) n'existe et
qu'ils ne peuvent pas être reconstruits.

Pour des raisons de compatibilités avec d'autres implémentations de
@code{make}, @code{sinclude} est un autre nom pour cette directive
@w{@code{-include}}.

@node La Variable MAKEFILES, Reconstruire les Makefiles, Inclure d'autres makefiles, Les Makefiles
@section La Variable @code{MAKEFILES}
@cindex makefile, et la variable @code{MAKEFILES}
@cindex inclure (variable @code{MAKEFILES})

@vindex MAKEFILES
Si la variable d'environnement @code{MAKEFILES} est définie, @code{make}
considère sa valeur comme étant une liste de noms (séparés par des
espaces) de fichiers makefiles additionnels à lire avant les autres.
Ceci fonctionne en gros comme la directive @code{include}@tie{}: ces
fichiers sont recherchés dans les différents répertoires
(@pxref{Inclure d'autres makefiles, ,Include d'autres Makefiles}).  En plus, l'objectif par
défaut n'est jamais pris dans l'un de ces makefiles (et aucun des
makefiles qui pourrait y être inclus) et c'est une erreur si les
fichiers listés dans @code{MAKEFILES} ne sont pas trouvés.@refill

@cindex récursion, et la variable @code{MAKEFILES}
L'utilisation principale de @code{MAKEFILES} est la communication entre
des appels récursifs de @code{make} (@pxref{Récursion, ,Utilisation
récursive de make}). Normalement, il n'est pas souhaitable de définir
une variable d'environnement avant un appel de haut niveau de
@code{make}, car d'habitude il vaut mieux ne pas introduire du désordre
avec un makefile depuis l'extérieur.  Cependant, si vous lancez
@code{make} sans spécifier de makefile, un makefile dans
@code{MAKEFILES} pour faire des choses utiles pour aider les règles
implicites incluses à mieux fonctionner, comme de définir les chemins de
recherche de fichiers (@pxref{Rechercher dans les répertoires}).

Certains utilisateurs sont tentés de définir @code{MAKEFILES} dans
l'environnement automatiquement au moment de la connexion et faire que
le programme makefiles en tienne compte. C'est une très mauvaise idée,
car de tels makefiles ne vont pas fonctionner s'ils sont lancés par
quelqu'un d'autre. Il est bien mieux d'écrire les directives
@code{include} explicitement dans le makefiles.  @xref{Inclure d'autres makefiles, ,Inclure
d'autres Makefiles}.

@node Reconstruire les Makefiles, Forcer les makefiles, La Variable MAKEFILES, Les Makefiles
@section Comment les Makefiles sont refabriqués
@cindex mettre à jour les makefiles
@cindex reconstuire une makefiles
@cindex makefile, reconstruire
De temps en temps les makefiles peuvent être reconstruits par d'autres
fichiers, comme les fichiers RCS ou SCCS.  Si un makefile peut être
reconstruit par un autre fichier, vous voudrez probablement que
@code{make} obtienne une version mise à jour du makefile dans lequel il
faudra lire.

À cet effet, après avoir lu tous les makefiles, @code{make} les
considèrera chacun comme un objectif de cible et cherchera à les mettre
à jour. Si un makefile a une règle qui dit comment le mettre à jour
(trouvée juste dans ce makefile particulier ou dans un autre) ou si des
règles implicites s'y appliquent (@pxref{Les règles implicites,
,Utiliser des règles implicites}), il sera mis à jour si
nécessaire. Quand tous les makefiles auront été vérifiés, si l'un
d'entre eux a été changé, @code{make} commencera avec une feuille
blanche et relira de nouveau tous les makefiles.  (Il va aussi essayer
de mettre à jour chacun d'entre eux à nouveau, mais normalement cela ne
devrait pas les changer, car ils devraient être déjà à jour). Chaque
redémarrage mettra à jour la variable spéciale @code{MAKE_RESTARTS}
(@pxref{Variables spéciales}).@refill

Si vous savez qu'un ou plusieurs de vos makefiles ne peut pas être
reconstruit et que vous ne voulez pas que @code{make} exécute une
recherche de règle implicite sur eux, peut-être pour des raisons
d'efficacité, vous pouvez utiliser n'importe quelle méthode normale qui
empêche les règles implicites d'aller le faire. Par exemple,
vous pouvez écrire une règle explicite avec le fichier makefile comme
cible et une instruction vide (@pxref{Instructions vides,,Utiliser les
instructions vides}).

Si le makefiles a une règle à double double points pour reconstruire
un fichier avec une instruction sans pré-requis, ce fichier sera toujours
reconstruit (@pxref{Double double points}).  Dans les cas des makefiles,
un makefile qui a une règle avec double double points avec une instruction
sans pré-requis sera reconstruit chaque fois que @code{make} est lancé,
et de nouveau ensuite après que @code{make} recommence et relis de
nouveau les makefiles.  Ceci peut créer une boucle infinie@tie{}: @code{make}
reconstruirait le makefile constamment et ne rien faire d'autre.  Donc,
pout éviter ceci, @code{make} ne cherchera @strong{pas} à reconstruire
des makefiles qui sont définis comme des cibles d'une règle à double
double-points avec une instruction sans pré-requis.@refill

Si vous ne définissez aucun makefiles pour être lu avec l'option
@samp{-f} ou @samp{--file}, @code{make} rechercher les noms de makefile
par défaut@tie{}; @pxref{Les Makefiles, ,Quel nom donner à vos Makefile}. À la
différence, les makefiles réclamés explicitement avec l'option @samp{-f}
ou @samp{--file}, @code{make} n'est pas certains que ces makefiles
puissent exister.  Cependant, si un makefile par défaut n'existe pas,
mais peut être créé en lançant les règles @code{make}, vous voudrez
probablement que les règles soient exécutées de telle façon que le
makefile puisse être utilisé.

C'est pourquoi, si aucun des makefiles par défaut n'existe, @code{make}
essayera de construire chacun d'entre-eux dans le même ordre qu'ils ont
été recherchés (@pxref{Les noms des makefiles, ,Quels nom donner à vos
Makefile}) jusqu'à ce qu'il réussisse à en construire un, ou qu'il
épuise les noms à essayer.  Notez que c'est pas une erreur si
@code{make} ne peut pas trouver ou contruire aucun makefile@tie{}; un
makefile n'est pas toujours nécessaire.@refill

Quand vous utilisez l'option @samp{-t} ou @samp{--touch} (@pxref{À la
place d'une exécution, ,Instead of Executing Recipes}), vous ne voudriez
pas utiliser un makefile périmé pour décider quelles cibles il faut
toucher.  Donc l'option @samp{-t} n'a aucun effet sur la mise à jour des
makefiles@tie{}; ils ne sont véritablement mis à jour si @samp{-t} est
spécifié.  De la même façon, @samp{-q} (ou @samp{--question}) et
@samp{-n} (ou @samp{--just-print}) n'empêche pas de mettre à jour les
makefiles, parcequ'un fichier périmé donnerait une sortie erronée pour
les autres cibles.  Donc, @samp{make -f mfile -n foo} mets à jour
@file{mfile}, le lis, et ensuite imprime l'instruction pour mettre à jour
@file{foo} et ce pré-requis sont les exécuter.  Ce instruction imprimée pour
@file{foo} sera l'une de celle qui est spécifiée dans le contenu mise à
jour de @file{mfile}.

Cependant, dans certaines occasion, vous pourriez réellement vouloir
éviter de mettre à jour même les makefiles.  Vous pouvez le faire en
définissant les makefiles comme objectifs sur la ligne de commande comme
aussi en les spécifiant comme des makefiles.  Quand le nom du makefile
est défini explicitement comme un objectif, les options @samp{-t} et
autres s'applique alors à eux.

Donc @samp{make -f mfile -n mfile foo} lirait le makefile @file{mfile},
imprime l'instruction requise pour le mettre à jour sans l'exécuter, et
ensuite imprime l'instruction requise pour mettre à jour @file{foo} sans
avoir à les exécuter.  L'instruction pour @file{foo} sera celle spécifiée
pour les contenus de @file{mfile}.


@node Forcer les makefiles, Lire les Makefiles, Reconstruire les Makefiles, Les Makefiles
@section Remplacer les parties d'un autre Makefile

@cindex forcer les makefiles
@cindex makefile, forçage
Parfois il est utile d'avoir un makefile qui est presque comme un autre
makefile.  Vous pouvez souvent utiliser la directive @samp{include} pour
les inclure l'un dans l'autre and ajouter plus de cibles ou de
définition variable. Cependant, il n'est pas permis à deux makefiles de
donner des instructions différentes à la même cible.  Mais il y a une autre
façon de faire.

@cindex la règle qui correspond à tout, utilisation pour faire un forçage
Dans le makefile contenant (celui qui veut inclure l'autre), vous pouvez
utiliser le modèle de la règle qui correspond à tout pour dire que pour
la reconstruction de toute cible qui ne peut pas être construite à
partir des informations contenues dans le makefile, @code{make} devra
rechercher un autre makefile.  @xref{Modèle de règles}, pour plus
d'informations sur les modèles de règles.

Par exemple, si vous avez un makefile appelé @file{Makefile} qui di
comment fabriquer la cible @samp{foo} (et d'autres cibles), vous pouvez
écrire un makefile appelé @file{GNUmakefile} qui contient:

@example
foo:
        frobnicate > foo

%: force
        @@$(MAKE) -f Makefile $@@
force:@tie{};
@end example

Si vous entrez @samp{make foo}, @code{make} trouvera @file{GNUmakefile},
le lira et verra que pour construire @file{foo}, il a besoin d'exécuter
l'instruction @samp{frobnicate > foo}.  Si vous entrez @samp{make bar},
@code{make} ne trouvera aucun moyen de construire @file{bar} dans
@file{GNUmakefile}, donc il utilisera l'instruction du modèle de règle@tie{}:
@samp{make -f Makefile bar}.  Si @file{Makefile} fournit une règle pour
mettre à jour @file{bar}, @code{make} appliquera cette règle.  Et de la
même façon pour tout autre cible que @file{GNUmakefile} ne dit pas
comment faire.

La façon dont cela fonctionne est que le modèle de règle utise le motif
utilisant simplement la caractère @samp{%} de telle façon que cela
puisse correspondre à n'importe quelle cible.  La règle spécifie un pré-requis
@file{force} pour garantie que l'instruction sera exécutée même si le
fichier cible existe déjà.  Nous donnons à la cible @file{force} un
instruction vide pour empêcher que  @code{make} recherche une règle
implicite pour la contruire ---@tie{}sinon cela elle appliquerait la même
règle qui correspond à tout à @file{force} elle-même et créérait une
boucle sur les pré-requis@tie{}!

@node Lire les Makefiles, Analyser les makefiles, Forcer les makefiles, Les Makefiles
@section Comment @code{make} lit les Makefile
@cindex Lire les makefiles
@cindex makefile, lire

GNU @code{make} réalise sa tâche en deux phases distinctes.  Pendant la
première phase, il lit tous les makefiles, les makefiles inclus, etc. et
internalise toutes les variables et leur valeurs, les règles implicites
et explicites et bâtit les graphes de dépendance pour toutes les cibles
et leur pré-requis. Durant la deuxième phase, @code{make} utilise ces
données internalisées pour déterminer quelles cibles ont besoin d'être
mises à jour et exécute les instructions qui sont nécessaire pour y
parvenir.

Il est important de comprendre que cette approches en deux phases, car
elle a un impact direct sur la façon dont le développement de variable
et fonction se déroule@tie{}; c'est souvent une source de confusion quand on
écrit des makefiles.  Ci-dessous se trouve un résumé des différentes
constructions qui peuvent être trouvées dans un makefile et la phase
dans laquelle se déroule de développement pour chaque partie de la
construction.

On pourrait dire que le développement est @dfn{immediat} s'il se
déroulait pendant la première phase@tie{}: @code{make} développerait cette
partie de la construction au moment de l'analyse du makefile.  Nous
disons que le développement est @dfn{différé} s'il n'est pas immediat.
Le développement d'une partie différée de la construction est suspendu
jusqu'à ce qu'il soit utilisé@tie{}: soit en étant référencé dans un context
immédiat, soit quand il est requis pendant la deuxième phase.

Vous n'êtes peut être pas encore familier avec ces constructions. Vous
pouvez vous référencer à cette section quand vous deviendrez familliers
avec, plus loin dans les chapitres.


@subheading Variable Assignment
@cindex +=, expansion
@cindex =, expansion
@cindex ?=, expansion
@cindex +=, expansion
@cindex !=, expansion
@cindex define, expansion

Les définitions de variable sont analysées de la manière suivante@tie{}:

@example
@var{immediate} = @var{deferred}
@var{immediate} ?= @var{deferred}
@var{immediate}@tie{}:= @var{immediate}
@var{immediate}@tie{}::= @var{immediate}
@var{immediate} += @var{deferred} or @var{immediate}
@var{immediate} != @var{immediate}

define @var{immediate}
  @var{deferred}
endef

define @var{immediate} =
  @var{deferred}
endef

define @var{immediate} ?=
  @var{deferred}
endef

define @var{immediate} :=
  @var{immediate}
endef

define @var{immediate} ::=
  @var{immediate}
endef

define @var{immediate} +=
  @var{deferred} or @var{immediate}
endef

define @var{immediate} !=
  @var{immediate}
endef
@end example

Pour l'opérator d'ajout @samp{+=}, le côté à main droite est considérée
immédiat si la variable était définit précédemment comme un variable
simple (@samp{:=} ou @samp{::=}) et sinon elle est considérée comme différée.

Pour l'opérateur d'assignement du shell @samp{!=}, le côte à main droite
est évalué immédiatement et traité par le shell.  Le résultat est stocjé
dans la variable nommée à main gauche et cette variable devient une
variable simple (et sera donc ré-évaluée à chaque référence).

@subheading Directives conditionnelles
@cindex ifdef, développement
@cindex ifeq, développement
@cindex ifndef, développement
@cindex ifneq, développement

Les directives conditionnelles sont analysées immédiatement.  Ceci
signifie, par exemple, que les variables automatiques ne peuvent pas
être utilisées dans les directives conditionnelles, car les variables
automatiques ne sont pas définies tant que l'instruction pour cette règle
est invoquée. Si vous devez utiliser une variable automatique dans une
directive conditionnelle, vous @emph{devez} déplacer la condition dans
une instruction and utiliser un syntaxe conditionnelle du shell à la place.

@subheading Rule Definition
@cindex cible, développement
@cindex pre-requis, développement
@cindex règles implicite, développement
@cindex modèle de règle, développement
@cindex règle explicite, développement

Une règle est toujours développée de la même façon, quelque soit sa forme@tie{}:

@example
@var{immediate} : @var{immediate}@tie{}; @var{deferred}
        @var{deferred}
@end example

Ce qui veut dire que la section cible et pré-requise sont développées
immédiatement et l'instruction utilisée pour construire la cible est
toujours différée. Ceci est vrai pour les règles explicite, les modèles
de règles, les règles de suffixes, les modèles statiques de règles et
les simples définition de pré-requis.

@node Analyser les makefiles, Les développements secondaires, Lire les Makefiles, Les Makefiles
@section Comment sont analysés les Makefiles
@cindex analyser les makefiles
@cindex makefiles, analyse

GNU @code{make} analyse les makefiles ligne par ligne.  L'analyse se
fait suivant les étapes suivantes@tie{}:

@enumerate
@item
Lecture d'une ligne logique complète, incluant les lignes échappées avec
des barres obliques inversée (@pxref{Couper les lignes, , Splitting Long Lines}).

@item
Enlèvement des commentaires (@pxref{Le contenu d'un makefile, ,
Qu'est-ce contiennent les Makefiles}).

@item
Si une ligne débute avec un caractère de préfixe pour les instructions et
que que nous sommes dans un contexte de règle, ajoute la ligne à la
instruction en cours et lit la prochaine ligne (@pxref{La syntaxe des instructions}).

@item
Développe les éléments de la ligne qui sont un context de développement
@emph{immediat} (@pxref{Lire les Makefiles, ,Comment make lit un
Makefile}).@refill

@item
Recherche un caractère de séparation dans la ligne, comme @samp{:} ou
@samp{=}, pour déterminer si la ligne est une assignation de macro ou
une règle (@pxref{La syntaxe des instructions}).

@item
Internalise le résultat de l'opération et lit la prochaine ligne.
@end enumerate

Une conséquence importante de ceci est que la macro peut se développer
en une règle complète @emph{si elle est longue d'une seule ligne}.  Cela
fonctionnera@tie{}:

@example
myrule = target : ; echo built

$(myrule)
@end example

Cependant, cela ne fonctionnera pas car @code{make} ne redivise pas les
lignes après les avoir développées.

@example
define myrule
target:
        echo built
endef

$(myrule)
@end example

Le makefile ci-dessus résulte en la définition de la cible @samp{target}
avec les pré-requis @samp{echo} et @samp{built} comme si le makefile
avait contenu @code{target: echo built} plutôt qu'une règle avec une
instruction.  Les nouvelles lignes toujours présentes avec que le
développement soit fini sont ignorée comme des espaces blancs normaux.

Pour développer correctement un macro qui s'écrit sur plusieurs lignes,
vous devez utiliser la fonction @code{eval}@tie{}: ceci oblige l'analyseur de
@code{make} d'être exécuté sur les résultats de la macro développée (@pxref{Fonction Eval}).

@node Les développements secondaires, , Analyser les makefiles, Les Makefiles
@section Les développements secondaires
@cindex développement secondaire
@cindex développement, secondaire

@findex .SECONDEXPANSION
Nous avons vu précédemment que GNU @code{make} travaille en deux phases
distinctes@tie{}: une première phase de lecture et une phase de mise à jour
des cibles (@pxref{Lire les Makefiles, , Comment @code{make} lit les
Makefile}).  GNU @code{make} peut aussi activer un @emph{développemet
secondaire} des pré-requis (seulement) pour certaines des cibles
définies dans le makefile.  Pour que ce seond développment intervienne,
la cible spéciales @code{.SECONDEXPANSION} doit être définie avant la
première liste de pré-requis qui va utiliser cette fonctionalité.

Si cette cible spéciale est définie entre deux les deux phases
mentionées ci-dessus, juste avant la fin de la phase de lecture, tous
les les pré-requis définis dans les cibles venant après cette cible
spéciale sont développés une @emph{seconde fois}.  La plupart du temps
ce développement secondaire n'aura pas d'effet, car toutes les variable
et références de fonctions auront été développées pendant la phase
initiale d'analyse des makefiles.  Pour tirer avantage de ce second
développement de l'analysieur, il est nécessaire @emph{d'échapper} la
variable ou la référence de fonction dans le makefile.  Dans ce cas, le
premier développement ne fera que de dé-échapper la référence, mais il
ne le développera pas et le développement est laissé pour la deuxième
phase de développement.  Par exemple, considérons cet exemple de
makefile:

@example
.SECONDEXPANSION:
ONEVAR = onefile
TWOVAR = twofile
myfile: $(ONEVAR) $$(TWOVAR)
@end example

Après la première phase de développement, la liste des pré-requis de la
cible @file{myfile} sera @code{onefile} et @code{$(TWOVAR)}@tie{}; la
première référence de variable (non-échappée) à @var{ONEVAR} est
développée, alors que la seconde référence de variable (échappée) est
simplement dé-échappée, sans être reconnu comme une référence de
variable.  Maintenant, pendant le second développement, le premier mot
est développé de nouveau, mais comme il ne contient ni une variable, ni
une référence de fonction, il rest à sa valeur @file{onefile}, tandis
que le second mot est maintenant une référence normale à la variable
@var{TWOVAR}, qui est développé à la valeur @file{twofile}. Le résultat
final est qu'il y a deux pré-requis, @file{onefile} et @file{twofile}.

Évidemment, ce n'est pas un cas très intéressant car le même résultat
aurait pu être obtenu simplement en faisant apparaitre les deux
variables non-échappées dans la liste des pré-requis. La différence va
apparaitre si les variables sont remises à jour@tie{}; voyez cet exemple@tie{}:

@example
.SECONDEXPANSION:
AVAR = top
onefile: $(AVAR)
twofile: $$(AVAR)
AVAR = bottom
@end example

Ici le pré-requis de @file{onefile} est développé immédiatement et se
résout à la valeur @file{top}, pendant que les pré-requis de @file{twofile}
ne vont pas être développé tant que le deuxième développement ne donne
pas une valeur à @file{bottom}.

C'est un plus intéressant, mais la véritable puissance de cette
fonctionalité devient apparent seulement quand vous découvrez que le
second développment se passe toujours dans le scope des variables
automatiques pour cette cible. Ceci veut dire que vous pouvez utiliser
des variables comme @code{$@@}, @code{$*}, etc. pendant le second
développement et elles auront les valeurs attendue, juste comme dans les
instructions.  Tout ce que vous avez à faire et de déférencer le
développement en l'échappant avec @code{$}.  Le développement secondaire
se déroule pour les règles ou modèles de règle implicite et
explicite. Sachant ceci, les usages possible de cette fonctionalité
augmentent considérablement. Par exemple@tie{}:

@example
.SECONDEXPANSION:
main_OBJS := main.o try.o test.o
lib_OBJS := lib.o api.o

main lib: $$($$@@_OBJS)
@end example

Ici, après le premier développement, les pré-requis des deux cibles
@file{main} et @file{lib} seront @code{$($@@_OBJS)}.  Pendant le
deuxième développement, la variable @code{$@@} est définie comme le nom
de la cible et donc le developppement de la cible @file{main} donnera
@code{$(main_OBJS)}, ou @code{main.o try.o test.o}, tandis que le
deuxième développement pour la cible @file{lib} donnera
@code{$(lib_OBJS)}, ou @code{lib.o api.o}.

Vous pouvez aussi mélanger les fonctions ici, tant qu'elles sont
échappées proprement@tie{}:

@example
main_SRCS := main.c try.c test.c
lib_SRCS := lib.c api.c

.SECONDEXPANSION:
main lib: $$(patsubst %.c,%.o,$$($$@@_SRCS))
@end example

Cette version permet aux utilisateurs de spécifier les fichiers source
au lieu des fichiers objets, mais elle donne le même résultat sur les
pré-requis que l'exemple précédent.

L'évaluation des variables automatique pendant la phase du second
développement, particulièrement pour la variable de nom de cible
@code{$$@@}, se comporte comme dans une évaluation faite dans une
instruction. Cependant, il y a des différences subtiles et des ``cas dans
les coins'' qui rentrent en jeu pour les diffèrents types de définition
de règles que @code{make} comprend.  Les subtilités dans l'utilisation
des différentes variables automatiques est décrit ci-dessous .


@subheading Développement secondaire et règles explicites
@cindex développement secondaire et règles explicites
@cindex débeloppeemnt secondaire, règles explicites

Durant le développement secondaire des règles explicites, @code{$$@@} et
@code{$$%} prenent respectivement la valeur du nom du fichier et du nom
de la cible et quand la cible est un membre d'archive, le nom de ce
membre pour la cible.  La variable @code{$$<} prend la valeur du premier
pré-requis dans la première règle de cette cible. @code{$$^} et
@code{$$+} prennent comme valeur la liste de tous les pré-requis des
règles @emph{qui ont déjà été traitées} pour la même cible (avec
répétitions pour @code{$$+} et sans pour @code{$$^}).  L'exemple suivant
aidera à illustrer ces comportements@tie{}:

@example
.SECONDEXPANSION:

foo: foo.1 bar.1 $$< $$^ $$+    # line #1

foo: foo.2 bar.2 $$< $$^ $$+    # line #2

foo: foo.3 bar.3 $$< $$^ $$+    # line #3
@end example

Dans la première liste de pré-requis, les trois variables (@code{$$<},
@code{$$^}, et @code{$$+}) se développent dans la chaîne vide.  Dans la
seconde, elles auront respectivement les valeurs @code{foo.1},
@code{foo.1 bar.1}, et @code{foo.1 bar.1}.  Dans la troisième elles
auront respectivement les valeurs @code{foo.1}, @code{foo.1 bar.1 foo.2
bar.2}, et @code{foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1}.

Les règles entreprennent leur développement secondaire dans l'ordre du
makefile, excepté que la règle aynt l'instruction est toujours évaluée en
dernier.

Les variables @code{$$?} et @code{$$*} ne sont pas disponible et se
développent dans la chaine vide.

@subheading Développement secondaire et modèle de règles statiques
@cindex développement secondaire et modèle de règles statiques
@cindex modèle de règles statiques, développement secondaire

Les règles pour l'expansion secondaire des modèles statiques de règles
sont identiques à celles des règles explicites, vues ci-dessus avec une
seule exception@tie{}: pour les modèles statique de règles, la variable
@code{$$*} est définie comme le radical du modèle.  Comme dans les règles
explicites, @code{$$?} n'est pas disponible et se développe en un chaine
vide.

@subheading Développement secondaire et règles implicites
@cindex développement secondaire et règles implicites
@cindex règles implicites, développement secondaire

Quand @code{make} fait la recherche d'une règle implicte, il substitue
le radical et ensuite réalise le développement secondaire de toute règle
correspondant au modèle de la cible. La valeur des vairables
automatiques est dérivée dans le même mode pour que pour les règles
statiques. Sur un exemple@tie{}:

@example
.SECONDEXPANSION:

foo: bar

foo foz: fo%: bo%

%oo: $$< $$^ $$+ $$*
@end example

Quand la règle implicite est essayée pour la cible @file{foo},
@code{$$<} se développe en @file{bar}, @code{$$^} se développe en
@file{bar boo}, @code{$$+} se développe aussi en @file{bar boo}, et 
@code{$$*} se développpe en @file{f}.

Notez que le répertoire préfixé (D) est jouté (après développement) à
tous les modèles de la liste des pré-requis comme décrit dans in
@ref{Recherche de règles implicites, ,Algorithme de recherche de règle
implicite}.  Voici un exemple:@refill

@example
.SECONDEXPANSION:

/tmp/foo.o:

%.o: $$(addsuffix /%.c,foo bar) foo.h
        @@echo $^
@end example

La liste des pré-requis retournée après le développement secondaire
et après la construction du préfixe des répertoires donnera
@file{/tmp/foo/foo.c /tmp/bar/foo.c foo.h}.  Si vous n'êtes pas
intéressé par cette construction, vous pouvez utilser @code{$$*} à la
place de @code{%} dans la liste des pré-requis.


@node Les règles, Les instructions, Les Makefiles, Top
@chapter Écrire des règles
@cindex écrire les règles
@cindex règle, comment les écrire
@cindex cible
@cindex pré-requis

Une @dfn{règle} (ndt. @dfn{rule}) apparaît dans un @file{makefile} pour
dire quand et comment recompiler certains fichiers, qui sont appelés les
@dfn{cibles} de cette règle (le plus souvent il n'y a qu'une seule cible
par règle). Elle liste les autres fichiers qui sont les @dfn{pré-requis}
de cette cible et @dfn{l'instruction} à utiliser pour créer ou mettre à
jour cette cible.

@cindex objectif par défaut
@cindex objectif, par défault
L'ordre des règles n'est pas significatif, excepté pour déterminer le
@dfn{but par défaut}@tie{}: la cible à considérer par @code{make} si vous
n'en spécifier pas d'autre. L'objectif par défaut est la cible de la
première règle du fichier @file{makefile}. Si la première règle a
plusieurs cibles, seule la première cible sera prise comme choix par
défaut. Il y a deux exceptions@tie{}: une cible commençant par un point n'est
pas un choix par défaut, sauf si elle contient aussi une ou plusieurs
barres obliques, @samp{/}@tie{}; et une cible qui définie une règle pour un
schéma n'a pas d'effet sur l'objectif par défaut. (@xref{Modèle de règles,
,Defining and Redefining Pattern Règles}.)

C'est pourquoi, on écrit d'habitude un @file{makefile} de telle façon
que la première règle soit celle qui compile le programme dans son
entier ou tous les programmes décrits par le @file{makefile} (cette
règle par défaut s'appelle souvent @samp{all}). @xref{Objectifs,
,Arguments pour spécifier les objectifs}.

@ifnottex
@node Exemple de règle, Règles syntaxiques, Les règles, Les règles
@section Exemple de règle

Voici un exemple de règle@tie{}:

@example
foo.o : foo.c defs.h       # module for twiddling the frobs
        cc -c -g foo.c
@end example

La cible est @file{foo.o} et les pré-requis sont @file{foo.c} et
@file{defs.h}. Cette règle a une commande dans son instruction@tie{}: @samp{cc -c -g
foo.c}.  L'instruction commence par une tabulation pour identifier qu'il
s'agit bien d'une instruction.

Cette règle dit deux choses@tie{}:

@itemize @bullet
@item
Comment décider si @file{foo.o} n'est plus à jour@tie{}: il n'est plus à jour
s'il n'existe pas ou si l'un des deux fichiers @file{foo.c} ou
@file{defs.h} est plus récent que lui.

@item
Comment mettre à jour le fichier @file{foo.o}@tie{}: en exécutant le compilateur
@code{cc} comme indiqué. L'instruction ne mentionne pas explicitement
@file{defs.h}, mais elle présume que @file{foo.c} l'inclut et c'est pourquoi
@file{defs.h} est ajouté au pré-requis.
@end itemize
@end ifnottex

@node Règles syntaxiques, Les types de pré-requis, Exemple de règle, Les règles
@section Règles syntaxiques

@cindex règles syntaxiques
@cindex règles syntaxiques
En général, une règle ressemble à ceci@tie{}:

@example
@var{cibles} : @var{pré-requis}
        @var{instruciton}
        @dots{}
@end example

@noindent
ou à ceci@tie{}:

@example
@var{cibles} : @var{pré-requis}@tie{}; @var{instruction}
        @var{instruction}
        @dots{}
@end example

@cindex cibles
@cindex règles pour les cibles
Les @dfn{cibles} sont des noms de fichiers, séparés par des espaces. Les
caractères spéciaux peuvent être utilisés (@pxref{Les caractères
génériques, , Utiliser les caractères génériques dans les noms de
fichiers}) et un nom de la forme @file{@var{a}(@var{m})} représente les
membres @var{m} dans un fichier d'archive @var{a} (@pxref{Les membres
d'une archive, , Les membres d'archive sont des cibles}). Normalement, il n'y a qu'une
seule cible par règle, mais certaines règles peuvent avoir
occasionnellement plusieurs cibles (@pxref{Les cibles multiples, , Les cibles multiples
pour une règle}). @refill

@cindex instructions
@cindex caractère de tabulation (dans les commandes)
Les lignes @dfn{d'instruction} démarrent par une tabulation (ou bien le
premier caractère de la valeur retournée par la variable
@code{.RECIPEPREFIX}@tie{}; @pxref{Variables spéciales}). La première
ligne d'instruction peut apparaitre sur la ligne suivant les pré-requis,
avec une tabulation, ou bien sur la même ligne après un point
virgule. Les deux écritures produisent le même effet. Il y a d'autres
différences dans la syntaxe des instructions. @xref{Les instructions,
,Écrire les instructions dans les règles}.

@cindex Le signe dollar (@code{$}), dans les règles
@cindex @code{$}, dans les règles
@cindex règles et @code{$}
Comme le signe dollar est utilisé pour débuter une référence à une
variable @code{make}, si vous voulez vraiment l'utiliser dans la
définition d'une cible ou dans un pré-requis, vous devez le doubler,
@code{$$} (@pxref{Utiliser les variables, , Comment utiliser les
variables}). Si vous avez activé les expansions secondaires (@pxref{Les
développements secondaires}) et que vous vouliez utiliser un signe dollar
dans une liste de pré-requis, vous devrez en fait écrire quatre signes
dollar consécutifs (@samp{$$$$}).

Vous pouvez interrompre une longue ligne en insérant une barre oblique
inversée suivie par une nouvelle ligne, mais ceci n'est pas obligatoire,
car @code{make} ne donne pas de limites pour la longueur des lignes d'un
@file{makefile}.

Une règle dit à @code{make} deux choses@tie{}: quand la cible n'est plus
à jour et si nécessaire, comment la mettre à jour.

@cindex pré-requis
@cindex règles de pré-requis
C'est au travers des @var{pré-requis} (ndt. @var{prequisites}), qui
consistent en des noms de fichiers séparés par des espaces, que l'on
détermine si une cible n'est plus à jour. (les caractères spéciaux et les
membres d'une archive (@pxref{Les fichiers archivés} sont aussi permis
ici.@tie{}) Une cible ne sera plus à jour si elle n'existe plus ou si
elle est plus ancienne que l'un de ses fichiers pré-requis (en comparant
la date de dernière modification). L'idée est que le contenu du fichier
cible est construit sur la base des informations contenues dans les
fichiers pré-requis, donc tout changement d'un pré-requis invalide à
priori le contenu du fichier cible.

La façon de mettre à jour est spécifiée dans @dfn{l'instruction}. Il
s'agit d'une ou plusieurs lignes à excécuter par le shell (normalement
@samp{sh}), mais avec quelques fonctionalités supplémentaires (@pxref{Les
instructions, , Écrire les instructions dans les règles}).

@node Les types de pré-requis, Les caractères génériques, Règles syntaxiques, Les règles
@comment  node-name,  next,  previous,  up
@section Types de pré-requis
@cindex types de pré-requis
@cindex types de pré-requis

@cindex pré-requis, normaux
@cindex pré-requis normaux
@cindex pré-requis, ordonnancement seul
@cindex pré-requis d'ordonnancement seuls
Il y a deux types différents de pré-requis que GNU @code{make}
comprend@tie{}: les pré-requis normaux comme ceux décrits dans le section
précédante, et les pré-requis @dfn{d'ordonnancement seul}. Un pré-requis
normal fait deux actions@tie{}: d'abord il impose un ordre dans lequel les
instructions vont être invoquées@tie{}: les instructions de tous les pré-requis d'une
cible seront excécutées et terminées avant que l'instruction pour
construire la cible ne soit lancée. Deuxièmement, il impose une relation
de dépendance@tie{}: si l'un des pré-requis est plus récent que la cible,
alors la cible est considérée comme plus à jour et doit être recompilée.

Normalement, c'est exactement ce que vous voulez@tie{}: si un pré-requis
d'une cible est mis à jour, alors la cible doit être mise à jour.

Cependant il peut arriver qu'occasionnellement vous ayez des situations
dans lesquelles vous voulez imposer un certain ordre sur les règles à
invoquer @emph{sans} forcer la mise à jour de la cible, si l'une de
ces règles est exécutée. Dans ce cas, vous voulez définir un préquis
@dfn{d'odonnancement seul}. Les pré-requis d'ordonnancement seul peuvent
être spécifiés en plaçant un symbole d'exécution dans un tuyaux
(@code{|}) dans la liste des pré-requis@tie{}: tous les pré-requis sur la
gauche du symbole @code{|} sont normaux@tie{}; tous les pré-requis sur la
droite sont des pré-requis d'ordonnancement seuls@tie{}:

@example
@var{cibles}@tie{}: @var{pré-requis_normaux} | @var{pré-requis_ordonnacement_seul}
@end example

La section des pré-requis normaux peut bien sûr être vide. Vous pouvez
aussi toujours déclarer plusieurs lignes de pré-requis pour la même
cible@tie{}: il sont concaténés comme approprié (les pré-requis normaux
sont concaténés à la liste des pré-requis normaux@tie{}; les pré-requis
d'ordonnancement seul sont concaténés à la liste des pré-requis
d'ordonnancement seul). Notez que si vous déclarez le même fichier comme
un pré-requis normal et comme un pré-requis d'ordonnancement seul, le
pré-requis normal prend la priorité (car son comportement correspond à
un sur-ensemble de celui d'un pré-requis d'ordonnancement seul).

Considérez un exemple dans lequel vos cibles doivent être placées dans
un répertoire séparé et que ce répertoire puisse ne pas exister avant
que la commande @code{make} soit lancée. Dans cette situation, vous
voulez que le répertoire soit créé avant qu'aucune cible n'y soit
placée, mais comme la date d'un répertoire change dès qu'un fichier y
est ajouté, enlevé ou renommé, nous ne voulons certainement pas
recompiler toutes les cibles dès que la date de ce répertoire
change. Une façon de gérer ceci et d'utiliser un pré-requis
d'ordonnancement seul@tie{}: il fait de la création de ce répertoire un
pré-requis d'ordonnancement seul pour toutes les cibles@tie{}:

@example
OBJDIR := objdir
OBJS@ := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)
$(OBJDIR)/%.o : %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $<
all: $(OBJS)
$(OBJS): | $(OBJDIR)
$(OBJDIR):
        mkdir $(OBJDIR)
@end example

Maintenant la règle pour créer le répertoire @file{objdir} est lancée,
quand c'est nécessaire, mais avant qu'aucune cible @samp{.o} ne soit
compilée. Aucune cible @samp{.o} ne sera recompilée si la date du
répertoire @file{objdir} change.

@node Les caractères génériques, Rechercher dans les répertoires, Les types de pré-requis, Les règles
@section Utiliser les caractèrs génériques dans les noms de fichiers
@cindex caractères génériques
@cindex noms de fichier avec des caractères génériques
@cindex englobement (caractère générique)

@cindex @code{*} (caractère générique)
@cindex @code{?} (caractère générique)
@cindex @code{[@dots{}]} (caractère générique)
Un nom de fichier peut à lui seul spécifier beaucoup de fichiers en
utilisant des @dfn{caractères génériques}. Les caractères génériques dans
@code{make} sont @samp{*}, @samp{?} et @samp{[@dots{}]}, les mêmes que
pour le Shell Bourne. Par exemple, @file{*.c} spécifie une liste de tous
les fichiers dont le nom termine par @samp{.c} sur le répertoire
courant.@refill

@cindex @code{~} (tilde)
@cindex tilde (@code{~})
@cindex répertoire utilisateur
Le caractère @samp{~} en début d'un nom de fichier a aussi une
signification particulière. S'il est seul ou suivi d'une barre oblique,
il represente le répertoire utilisateur. Par exemple @file{~/bin} se
développe en @file{/home/you/bin}. Si le caractère @samp{~} est suivi
par un mot, la chaine représente le répertoire de l'utilisateur nommé
par ce mot. Par exemple @file{~john/bin} se développe en
@file{/home/john/bin}. Sur les systèmes qui n'ont pas de répertoire
utilisateur pour chaque utilisateur (comme MS-DOS ou MS-Windows), cette
fonctionalité peut être simulée en définissant la variable
d'environnement @var{HOME}.@refill

Le développement des expressions avec caractères génériques est fait
automatiquement par @code{make} pendant la lecture des définitions des
cibles ou des pré-requis. Dans les instructions, c'est le Shell qui est
responsable de l'interprétation des caractères génériques. Dans d'autres
contextes, le développement des caractères génériques se déroule
seulement si vous le demandez explicitement avec la fonction
@code{wildcard}.

La signification d'un caractère générique peut être désactivée en le
faisant précéder d'une barre oblique inversée. Ainsi, @file{foo\\*bar}
refère à un nom de fichier particulier qui consiste en @samp{foo}, une
astérisque et le mot @samp{bar}.@refill

@node Exemples de caractères génériques, Les pièges des caractères génériques, Les caractères génériques, Les caractères génériques
@subsection Exemples de caractères génériques

Les caractères génériques peuvent être utilisés dans les instructions d'une
règle, où ils seront alors developpés par le Shell. Par exemple,
voici une règle pour effacer tous les fichiers objets@tie{}:

@example
@group
clean:
        rm -f *.o
@end group
@end example
@cindex @code{rm} (shell command)

Les caractères génériques sont aussi utiles dans les pré-requis d'une
règle. Avec la règle suivante dans le @file{Makefile}, @samp{make print}
imprimera tous les fichiers @samp{.c} qui ont changé depuis la dernière
fois que vous les aviez imprimés.

@example
print: *.c
        lpr -p $?
        touch print
@end example

@cindex @code{print} cible
@cindex @code{lpr} (commande shell)
@cindex @code{touch} (commande shell)
@noindent
Cette règle utilise le mot @code{print} comme nom de fichier cible
vide@tie{}; voir @ref{Les cibles vides, ,Fichier cible vide pour
enregistrer un évènement}. (La variable automatique @samp{$?} est
utilisée pour imprimer seulement les fichiers qui ont changé@tie{}; voir
@ref{Les variables automatiques}.)@refill

Le développement des caractères génériques n'intervient pas quand on
définit une variable. Donc si on écrit ceci@tie{}:

@example
objects = *.o
@end example

@noindent
alors la valeur de la variable @code{objects} est précisément la chaîne
@samp{*.o}. Cependant, si vous utilisez la valeur de @code{objects} dans
la définition d'une cible ou d'un pré-requis, le développement de
caractère spéciaux s'effectuera à cet endroit. Si vous utilisez la
valeur de @code{objects} dans une instruction, le Shell pourra développer le
caractère générique quand l'instruction sera exécutée. Pour définir
@code{objects} immediatement comme sa valeur développée, il faut
utiliser à la place@tie{}:

@example
objects := $(wildcard *.o)
@end example

@noindent
@xref{La fonction Wildcard}.

@node Les pièges des caractères génériques, La fonction Wildcard, Exemples de caractères génériques, Les caractères génériques
@subsection Danger d'utiliser des caractères génériques
@cindex pièges avec les caractèrs spéciaux
@cindex pièges avec les caractèrs spéciaux
@cindex erreurs avec les caractères génériques
@cindex erreurs avec les caractères génériques
@cindex prblèmes avec les caractèrs spéciaux

Maintenant voici un exemple d'utilisation naïve du développement de
caractères génériques, qui ne donne pas le résultat attendu. Supposez que
vous vouliez dire que le fichier executable @file{foo} est fait à partir
de tous les fichiers objets du répertoire et qui vous écriviez ceci@tie{}:

@example
objects = *.o

foo@tie{}: $(objects)
        cc -o foo $(CFLAGS) $(objects)
@end example

@noindent
La valeur de @code{objects} est précisément la chaîne @samp{*.o}. Le
développement de caractères génériques intervient dans la règle pour la cible
@file{foo}, de telle façon que chaque fichier @samp{.o} @emph{existant}
devient
un pré-requis de le cible @file{foo} et sera recompilé si nécessaire.

Mais si vous avez effacé tous les fichiers @samp{.o}@tie{}? Quand un
caractère générique ne correspond à aucun fichier, il est laissé tel quel,
donc la cible @file{foo} va maintenant dépendre du fichier bizarement
nommé @file{*.o}. Comme aucun fichier avec ce nom n'existe, @code{make}
va retourner une erreur disant qu'il ne sait pas comment fabriquer
@file{*.o}. Ce n'est pas ce que vous vouliez@tie{}!

En fait, il est possible d'obtenir le résultat désiré avec un
développement de caractère générique, mais vous devez utiliser des
techniques plus élaborées, incluant la fonction @code{wildcard} et la
substitution de chaîne.
@ifnottex
@xref{La fonction Wildcard, ,The Function wildcard}.
@end ifnottex
@iftex
Ceci est décrit dans la section suivante.
@end iftex

@cindex caractèrs spéciaux et la barre inversée de MS-DOS/MS-Windows
@cindex barre inversée dans les noms de chemin de répertoire et développement de caractères génériques

Les systèmes d'explotation Microsoft (MS-DOS et MS-Windows) utilisent la
barre oblique inversée pour séparer les noms de répertoire dans le nom
de chemin, comme ceci@tie{}:

@example
  c:\foo\bar\baz.c
@end example

Ceci est équivalent au style Unix @file{c:/foo/var/baz.c} (la partie
@file{c:} est appelé la lettre du disque). Quand @code{make} s'exécute
sur ces systèmes, il supporte aussi les barres obliques inversées comme
les barres obliques du style Unix dans les noms de fichier. Cependant,
le développement de caractère spéciaux n'est @emph{pas} supporté, car la
barre oblique inversée signifie une quotation. Donc vous @emph{devez}
utiliser la style Unix des barres de séparation de répertoire pour ces
cas.


@node La fonction Wildcard, , Les pièges des caractères génériques, Les caractères génériques
@subsection La fonction wildcard
@findex caractères génériques

Le développement de caractères génériques (ndt. ``wildcard
characters'') s'effectue automatiquement dans les règles. Mais ce
développement ne s'effectue normalement pas dans la définition d'une
variable ou dans les arguments d'une fonction. Si vous voulez faire un
développement de caractères génériques à ces endroits, vous devez
utiliser la fonction @code{wildcard} comme ceci@tie{}:

@example
$(wildcard @var{pattern}@dots{})
@end example

@noindent
Cette chaîne, qui peut être utilisée n'importe ou dans un makefile, est
remplacée par la liste de noms de fichiers existants, séparés par des
espaces, et qui correspond au modèle de nom de fichiers.  Si aucun
fichier existant ne correspond à au modèle, alors ce modèle est omis de
la sortie de la fonction @code{wildcard}.  Notez que c'est différent de
la façon dont les caractères génériques qui ne correspondent pas se
comportent dans une règle, où ils sont utilisés verbatim plutôt qu'ignorés
(@pxref{Les pièges des caractères génériques}).

Une utilisation de la fonction @code{wildcard} est d'obtenir la liste de
tous les fichiers source C du répertoire comme ceci@tie{}:

@example
$(wildcard *.c)
@end example

Nous pouvons échanger la liste des fichiers source C avec la liste des
fichiers objet en complaçant le suffixe @samp{.c} avec @samp{.o} dans le
résultat, comme ceci@tie{}:

@example
$(patsubst %.c,%.o,$(wildcard *.c))
@end example

@noindent

(Ici, nous avons utilisé une autre fonction, @code{patsubst}.  @xref{Fonctions
de texte,,Fonctions pour la substitution dans les chaînes et l'analyse}.)@refill

Donc un makefile pour compiler tous les fichiers source C dans le
répertoire et ensuite pour les lier ensemble pourrait être écrit de la
manière suivante@tie{}:

@example
objects := $(patsubst %.c,%.o,$(wildcard *.c))

foo@ : $(objects)
        cc -o foo $(objects)
@end example

@noindent
(Ceci tire avantage de la règle implicite pour compiler les programmes
C, donc il n'y a pas besoin d'écrire les règles explicites pour compiler
ces fichiers.  @xref{La fonction Flavor, ,Les deux versions des variables},
pour une explication de @samp{:=}, qui est une variante de @samp{=}.)

@node Rechercher dans les répertoires, Les cibles fictives, Les caractères génériques, Les règles
@section Rechercher les pré-requis dans un répertoire
@vindex VPATH
@findex vpath
@cindex vpath
@cindex rechercher le chemin pour les pré-requis (@code{VPATH})
@cindex Chercher dans un répertoire (@code{VPATH})

Pour les grands systèmes, il est souvent souhaitable de mettre les
sources dans un répertoire séparés des binaires. Les fonctionalités de
@dfn{recherche de répertoire} de @code{make} le facilite en recherchant
dans plusieurs répertoires automatiquement pour trouver un
pré-requis. Quand vous distribuez les fichiers sur plusieurs
répertoires, vous n'avez pas besoin de changer les fichiers
individuellement, vous ne changez que le chemin de recherche.


@node Recherche générale, Recherche sélective, Rechercher dans les répertoires, Rechercher dans les répertoires
@subsection @code{VPATH}: rechercher le chemin vers tous les pré-requis
@vindex VPATH

La valeur de la variable @code{make} @code{VPATH} définit la liste des
répertoires dans lesquels @code{make} devrait rechercher. Les plus
souvent, on s'attends à ce que les répétoires contiennent des fichiers
de pré-requis qui ne sont pas dans le répertoire courant@tie{}; cependant,
@code{make} utilise @code{VPATH} comme une liste de recherche pour à la
fois les pré-requis et les cibles des règles.

Donc, si un fichier qui est listé en cible ou en pré-requis n'existe pas
dans le répertoire courant, @code{make} recherche dans les répertoires
listés dans @code{VPATH} un fichier ayant ce nom. Si un fichier est
trouvé dans l'un d'entre eux, ce fichier peut devenir le pré-requis
(voir plus bas). Les règles peuvent alors spécifier des noms de fichiers
dans la liste des pré-requis comme s'ils existaient dans le répertoire
courant. @xref{Instruction/recherche, ,Écrire une instruction avec une recherche
dans un répertoire}.

Dans une variable @code{VPATH}, les noms des répertoires sont séparés
par des doubles points ou des blancs. L'ordre dans lequel les
répertoires sont listé est l'ordre suivi par @code{make} dans ses
recherches. (Sur MS-DOS et MS-Windows, les points virgules sont utilisés
comme séparateurs des noms de répertoires dans @code{VPATH}, car les
double points peuvent être utilisé dans le nom du chemin lui même, après
la lettre du lecteur.)

Par exemple,

@example
VPATH = src:../headers
@end example

@noindent
specifies a path containing two directories, @file{src} and
@file{../headers}, which @code{make} searches in that order.

Avec cette valeur de @code{VPATH}, la règle suivante,

@example
foo.o : foo.c
@end example

@noindent
est interprétée comme si elle avait été écrite ainsi@tie{}:

@example
foo.o : src/foo.c
@end example

@noindent
en faisant l'hypothèse que @file{foo.c} n'existe pas dans le répertoire
courant
mais est trouvé dans le répertoire @file{src}.

@node Recherche sélective, Algorithme de recherche, Recherche générale, Rechercher dans les répertoires
@subsection La directive @code{vpath}
@findex vpath

Comme la variable @code{VPATH}, mais plus sélective, la directive
@code{vpath} (notez les minuscules) permet des spécifier un chemin pour
une classe particulière de noms de fichiers@tie{}: les noms qui correspondent
à un modèle particulier. Donc vous pourvez donner un répertoire de
recherche pour une classe de noms de fichier et un autre répertoire (ou
rien) pour une autre série de noms de fichiers.

Il y a trois formes de directive @code{vpath}@tie{}:

@table @code
@item vpath @var{pattern} @var{directories}
Spécifie le chemin de recherche @var{directories} pour les noms de
fichiers qui correspondent à @var{pattern}.

Le chemin de recherche, @var{directories}, est une liste de répertoires
à investiguer, les doubles points de séparation (des points virgules
sous MS-DOS et MS-WINDOWS) ou les blancs, juste comment un chemin de
recherche utilisé par la variable @code{VPATH}.

@item vpath @var{pattern}
Clear out the search path associated with @var{pattern}.

@c Extra blank line makes sure this gets two lines.
@item vpath

Clear all search paths previously specified with @code{vpath} directives.
@end table

A modèle @code{vpath} est une chaîne qui contient un caractère @samp{%}.
La chaîne doit correspondre au nom de fichier du pré-requis qui est
recherché, le caractère @samp{%} correspond à n'importe quelle séquence
de zéro ou plus de caractères (comme dans les modèles de règles@tie{};
@pxref{Modèle de règles, ,définir et redéfinir des modèles de règles}).
Par exemple, @code{%.h} correspond aux fichiers qui terminent par
@code{.h}.  (S'il n'y a pas de @samp{%}, ce modèle doit correspondre
exactement au pré-requis recherché, ce qui n'est souvent pas utile.)

@cindex @code{%}, citation dans @code{vpath}
@cindex @code{%}, citer avec @code{\} (barre oblique inversée)
@cindex @code{\} (barre oblique inversée), pour citer @code{%}
@cindex barra oblique inversée (@code{\}), pour citer @code{%}
@cindex citer @code{%}, dans @code{vpath}
Les caractères @samp{%} dans le modèle d'une directive @code{vpath}
peuvent être cité avec une barre oblique inversée (@samp{\}) mise
devant.  Les barres obliques inversées qui devraient sinon échapper les
caractères @samp{%} peuvent être elles même échappée par plus de barres
obliques inversées.  Les barres obliques inversées qui échappent les
caractères @samp{%} ou les autres barres obliques inversées sont
enlevées du modèle avant qu'il soit comparé aux noms de fichiers. Les
barres obliques inversées qui ne risquent pas d'échapper un caractère
@samp{%} ne sont pas affectées.@refill

Quand la recherche d'un pré-requis dans le répertoire courant échoue, si
la variable @var{pattern} dans la directive @code{vpath} correspond au
nom du fichier pré-requis, on étend alors la recherche aux répertoires
listés dans la variable @var{directories}, juste comme on le ferait pour
les répertoires listés dans la variable @code{VPATH} (mais en le faisant
ici avant).

Par exemple,

@example
vpath %.h ../headers
@end example

@noindent
dit à @code{make} de rechercher les pré-requis dont le nom se termine par
@file{.h} dans le répertoire @file{../headers} si le fichier n'est pas
trouvé dans le répertoire courant.

Quand plusieurs modèles de @code{vpath} correspondent aux noms de
fichiers pré-requis, alors @code{make} exécute chacune des directive
@code{vpath} qui a des correspondance, une à une, recherchant tous les
répertoires mentionés dans chaque directive.  @code{make} gère plusieurs
directives @code{vpath} dans l'order dans lequel elles apparaissent dans
le makefile@tie{}; des directives différentes avec le même modèle sont
indépendantes les unes des autres.

@need 750
Donc,

@example
@group
vpath %.c foo
vpath %   blish
vpath %.c bar
@end group
@end example

@noindent
recherchera les fichiers terminant par @samp{.c} sans @file{foo}, ouis dans @file{blish},
et enfin dans @file{bar}, alors que 

@example
@group
vpath %.c foo:bar
vpath %   blish
@end group
@end example

@noindent
recherchera un fichier terminant par @samp{.c} dans @file{foo}, puis
@file{bar}, et ensuite @file{blish}.

@node Algorithme de recherche, Instruction/recherche, Recherche sélective, Rechercher dans les répertoires
@subsection Comment sont réalisées les recherches dans un répertoire
@cindex algorithme pour la recherche dans un répertoire
@cindex algorithme de recherche dans un répertoire

Quand un pré-requis est trouvé au cours d'une recherche dans un
répertoire, indépendament du type de recherche (selective ou générale),
le nom de chemin localisé pourrait ne pas être celui que @code{make}
vous fournit effectivement dans la liste des pré-requis. Parfois, le
chemin trouvé à travers une recherche de répertoire est rejetté.

L'algorithme @code{make} décide normalement de conserver ou d'abandonner
un chemin trouvé à travers une recherche de répertoire selon les règles suivantes@tie{}:

@enumerate
@item
Si un fichier cible n'existe pas sur le chemin spécifié dans le
makefile, une recherche de répertoire est démarrée.


@item
Si une recherche de répertoire aboutie à une solution, ce répertoire est
conservé et ce fichier est conservé comme une solution possible de cible.

@item
Tous les pré-requis de cette cible sont examiné en utilisant la même méthode.

@item
Après avoir travaillé sur les pré-requis, la cible peut avoir besoin
d'être recompilée ou non@tie{}:

@enumerate a
@item
Si la cible n'a @emph{pas} besoin d'être recompilée, alors le chemin du
fichier trouvé durant la recherche dans les répertoires est utilisé pour
chacun des listes des pré-requis qui contiennent cette cible. En résumé,
si @code{make} n'a pas besoin de recompiler la cible, vous utilisez le
chemin trouvé avec le recherche dans les répertoires.

@item
Si la cible @emph{a} besoin d'être recompilée (elle n'est plus à jour),
le nom de chemin trouvé pendant la recherche dans les répertoires est
@emph{rejeté} et la cible est recompilée en utilisant le nom de
fichier défini dans le makefile.  En résumé, si @code{make} doit
recompiler, alors la cible est recompilée localement et non dans le
répertoire trouvé à travers la recherche dans les répertoires.
@end enumerate
@end enumerate

Cet algorithm peut paraitre complexe, mais en pratique, c'est très
souvent exactement ce que vous voulez.

@cindex recherche traditionnelle dans le répertoire (GPATH)
@cindex recherche dans les répertoires, traditionelle (GPATH)
D'autres versions de @code{make} utilisent un algorithme plus simple@tie{}:
si le ficher n'existe pas et qu'il est trouvé à travers la recherche
dans les répertoires, alors ce nom de chemin est toujours celui utilisé,
que la cible ait besoin ou non d'être mise à jour.  Donc si la cible est
recompilée, si la cible est recompilée elle reçoit le nom de chemin
trouvé pendant le recherche dans le répertoires.

@vindex GPATH
Si, c'est en fait le comportement que vous souhaitez pour quelques uns
de vos répertoires, vous pouvez utiliser la variable @code{GPATH} pour
l'indiquer à @code{make}.

@code{GPATH} a la même syntaxe et le même format que @code{VPATH} (c'est
à dire, une liste de noms de chemins séparés par des espaces ou des
virgules).  Si pendant la recherche une autre cible périmée est trouvée
dans un des répertoires indiqués par @code{GPATH}, alors ce nom de
fichier et rejeté.  La cible est recompilée en utilisant le nom de
chemin développé.

@node Instruction/recherche, Recherche implicite, Algorithme de recherche, Rechercher dans les répertoires
@subsection Writing Recipes with Directory Search
@cindex recipes, and directory search
@cindex directory search (@code{VPATH}), and recipes

Quand un pré-requis est trouvé dans un autre répertoire à travers la
recherche dans les répertoires, ceci ne peut pas changer l'instruction de
cette règle@tie{}; elles seront exécutées comme elles sont écrites. C'est
pourquoi, vous devez écrire les instructions en faisant attention qu'elles
iront rechercher les pré-requis dans le répertoire dans lequel
@code{make} le trouvera.

Ceci est fait au travers des @dfn{variables automatiques} comme @samp{$^}
(@pxref{Les variables automatiques}).  Par exemple, la valeur de @samp{$^}
est une listee de tous les pré-requis de la règle, incluant les noms des
répertoires dans ils se trouvent et la valeur de @samp{$@@} est la
cible.  Donc@tie{}:@refill

@example
foo.o : foo.c
        cc -c $(CFLAGS) $^ -o $@@
@end example

@noindent
(La variable @code{CFLAGS} existe de telle façon que vous puissiez
définir les options pour la compilation C en utilisant des règles
implicites@tie{}; nous l'utilisons ici pour rester rester consistant et qu'il
affecte toute les compilations C uniformément@tie{}; @pxref{Les variables implicites,
,Les variables utilisées par les règles implicites}.)

Souvent les pré-requis incluent aussi des fichiers d'en-têtes, que vous
ne voudriez pas mentioner dans vos instructions. La variable automatique
@samp{$<} est juste le premier pré-requis@tie{}:

@example
VPATH = src:../headers
foo.o : foo.c defs.h hack.h
        cc -c $(CFLAGS) $< -o $@@
@end example

@node Recherche implicite, Recherche dans les bibliothèques, Instruction/recherche, Rechercher dans les répertoires
@subsection Recherche dans les répertoires et règles implicites
@cindex @code{VPATH}, et règles implicites
@cindex recherche dans les répertoires (@code{VPATH}), et règles implicites
@cindex chemin de recherche des pré-requis (@code{VPATH}), et règles implicites
@cindex règles implicites, et recherche dans les répertoires
@cindex règles implicites, et @code{VPATH}
@cindex règles, implicites, et recherche dans les répertoires
@cindex règles, implicites, et @code{VPATH}

La recherche dans les répertoires spécifiés par @code{VPATH} ou par
@code{vpath} se fait aussi en considérant les règles implicites
(@pxref{Les règles implicites, ,Utiliser les règles implicites}).

Par exemple, quand un fichier @file{foo.o} n'a pas de règle explicite, @code{make}
considère les règles implicites, comme les règles prédéfinies de
compilation de @file{foo.c}, si ce fichier existe. Si ce fichier manque
dans le répertoire courant, les répertoires appropriés sont examinés
pour l'y rechercher.  Si @file{foo.c} existe (ou est mentioné dans le
makefile) dans l'un quelconque des répertoires, la règle implicite pour
une compilation C est appliquée.

Les instructions pour les règles implicites utilisent normalement les
variables automatique comme une nécessité@tie{}; par conséquent, elles
utilisent les noms de fichiers trouvés au travers de la recherche dans
les répertoire sans effort supplémentaire.

@node Recherche dans les bibliothèques, , Recherche implicite, Rechercher dans les répertoires
@subsection Recherche dans les répertoire et bibliothèques liées
@cindex bibliothèques liées, et recherche dans les répertoires
@cindex bibliothèques pour l'édition de liens, recherche dans les répertoires
@cindex recherche dans les répertoires (@code{VPATH}), et bibliothèques liées
@cindex @code{VPATH}, et les bibiliothèques liées
@cindex chercher les pré-requis dans le PATJ (@code{VPATH}), et bibliothèques liées
@cindex @code{-l} (library search)
@cindex bibliothèques liées, correspondance de modèles
@cindex @code{.LIBPATTERNS}, et bibliothèques liées
@vindex .LIBPATTERNS

Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a prerequisite
whose name is of the form @samp{-l@var{name}}.  (You can tell something
strange is going on here because the prerequisite is normally the name of a
file, and the @emph{file name} of a library generally looks like
@file{lib@var{name}.a}, not like @samp{-l@var{name}}.)@refill

When a prerequisite's name has the form @samp{-l@var{name}}, @code{make}
handles it specially by searching for the file @file{lib@var{name}.so}, and,
if it is not found, for the file @file{lib@var{name}.a} in the current
directory, in directories specified by matching @code{vpath} search paths
and the @code{VPATH} search path, and then in the directories @file{/lib},
@file{/usr/lib}, and @file{@var{prefix}/lib} (normally
@file{/usr/local/lib}, but MS-DOS/MS-Windows versions of @code{make} behave
as if @var{prefix} is defined to be the root of the DJGPP installation
tree).

For example, if there is a @file{/usr/lib/libcurses.a} library on your
system (and no @file{/usr/lib/libcurses.so} file), then

@example
@group
foo : foo.c -lcurses
        cc $^ -o $@@
@end group
@end example

@noindent
would cause the command @samp{cc foo.c /usr/lib/libcurses.a -o foo} to be
executed when @file{foo} is older than @file{foo.c} or than
@file{/usr/lib/libcurses.a}.@refill

Although the default set of files to be searched for is
@file{lib@var{name}.so} and @file{lib@var{name}.a}, this is customizable via
the @code{.LIBPATTERNS} variable.  Each word in the value of this variable
is a pattern string.  When a prerequisite like @samp{-l@var{name}} is seen,
@code{make} will replace the percent in each pattern in the list with
@var{name} and perform the above directory searches using each library file
name.

The default value for @code{.LIBPATTERNS} is @samp{lib%.so lib%.a}, which
provides the default behavior described above.

You can turn off link library expansion completely by setting this variable
to an empty value.

@node Les cibles fictives, Les cibles forcées, Rechercher dans les répertoires, Les règles
@section Les cibles fictives
@cindex Les cibles fictives
@cindex phony targets
@cindex cibles, fictives
@cindex les cibles sans fichier

Une cible fictive est une cible qui n'est pas vraiment un nom de
fichier@tie{}; c'est plutôt le nom d'une instruction à exécuter quand
vous faites une requète explicite. Il y a deux raisons pour utiliser une
requête fictive@tie{}: éviter les conflits avec un fichier du même nom et
améliorer les performances.

Si vous écrivez une règle dont l'instruction ne crée pas de fichier
cible, l'instruction va être exécutée chaque fois que vous demandez à
make de créer cette cible. Voici un exemple@tie{}:

@example
@group
clean:
        rm *.o temp
@end group
@end example

@noindent
Comme la commande @code{rm} ne crée pas de fichier nommé @file{clean},
probablement un tel fichier n'existera jamais.  C'est pourquoi la
commande @code{rm} va s'exécuter à chaque fois que vous entrez
@samp{make clean}.
@cindex @code{rm} (commande shell)

@findex .PHONY
Dans cet exemple, la cible @file{clean} ne fonctionnerait pas
correctement si un fichier nommé @file{clean} avait été crée dans ce
répertoire.  Comme il n'y a pas de pré-requis, @file{clean} serait
considéré comment toujours à jour et son instruction ne se serait pas
exécutée. Pour éviter ce problème, vous pouvez déclarer explicitement la
cible comme fictive en le mettant comme un pré-requis de la cible spéciale
@code{.PHONY} (@pxref{Les cibles spéciales, ,les noms de cibles intégrées})
de la façon suivante:

@example
@group
.PHONY: clean
clean:
        rm *.o temp
@end group
@end example

@noindent
Une fois que c'est fait, @samp{make clean} exécutera l'instruction sans
tenir compte si un fichier nommé @file{clean} existe ou non.

Les cibles fictives sont aussi utiles en conjonction avec la résursion
d'invocations de @code{make} (@pxref{Récursion, ,Utilisation récursive
de make}@tie{}). Dans cette situation, le makefile contient souvent une
variable, qui liste un nombre de sous-répertoires à compiler. Une
approche simpliste pour gérer ceci est de définir une règle avec une
instruction, qui boucle dans les sosu-répertoires comme ceci@tie{}:

@example
@group
SUBDIRS = foo bar baz

subdirs:
        for dir in $(SUBDIRS); do \
          $(MAKE) -C $$dir; \
        done
@end group
@end example

Cette méthode entraine cependant des problèmes. D'abord, toute erreur
détectée dans une sous-compilation est ignorée par cette règle, de telle
manière que les compilations vont continuer avec les répertoires
suivants, même si l'une a échoué. Ceci peut être réglé en ajoutant une
commande shell pour noter les erreurs et sortir, mais alors ceci est
fait même si @code{make} est invoqué avec l'option @code{-k}, ce qui
n'est pas très heureux.  Ensuite, et peut être de manière plus
importante, vous ne pouvez pas bénéficier de l'avantage de la capacité
de @code{make} de compiler des cibles en parallèle
(@pxref{Parallèle,,Exécution Parallèle}), car il n'y a qu'une seule
règle.

En déclarant les sous-répertoires comme des cibles fictives
(@code{.PHONY}), vous enlevez ces désagréments (vous pouvez le faire,
si tous les sous-répertoires existent toujours de manière
évidente@tie{}; sinon, la compilation échouera):

@example
@group
SUBDIRS = foo bar baz

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

$(SUBDIRS):
        $(MAKE) -C $@@

foo: baz
@end group
@end example

Dans cet exemple, nous avons aussi déclaré que le sous-répertoire
@file{foo} ne peut pas être compilé avant que les sous-répertoire
@file{baz} n'ait été complété@tie{}; ce type de déclaration de relation
est particulièrement important, quand on essaye de faire des
compilations parallèles.

La recherche de règle implicite (@pxref{Les règles implicites}) est omise
pour les cibles fictives (@code{.PHONY}).  C'est pourquoi déclarer une
cible comme fictive (@code{.PHONY}) est bon pour la performance, même si
vous n'êtes pas soucieux de l'existence effective du fichier.

Une cible fictive ne devrait pas être un pré-requis d'un fichier cible réel@tie{};
si c'était le cas, son instruction serait exécutée chaque fois que
@code{make} irait mettre à jour ce fichier.  Tant qu'une cible fictive
n'est jamais un pré-requis d'une cible réelle, l'instruction de la cible
fictive est exécutée seulement quand la cible fictive est spécifiée
expressément (@pxref{Objectifs, ,Arguments pour spécifier les objectifs}).

Les cibles fictives peuvent avoir des pré-requis. Quand un répertoire
contient plusieurs programmes, il est plus pratique de déclarer tous les
programmes dans un @file{./Makefile}. Comme la cible recompilée par
défaut est la première dans le makefile, il est courant d'en faire une
cible fictive nommée @samp{all} et de lui donner comme pré-requis tous
les programmes individuels.  Par exemple@tie{}:

@example
all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

prog2 : prog2.o
        cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
@end example

@noindent
Maintenant, vous pouvez juste entrer @samp{make} pour recompiler les
trois programmes ou spécifier comme argument lequel doit être recompilé
(comme dans @samp{make prog1 prog3}).  Le caractère fictif n'est pas
hérité@tie{}: les pré-requis d'une cible fictive ne sont pas eux-mêmes
fictif, sauf s'ils ont été explicitement déclarés comme tels.

Quand une cible fictive est le pré-requis d'une autre, elle sert de
sous-routine à l'autre. Par exemple, ici @samp{make cleanall} va effacer
tous les fichiers objet, les fichiers de différence ans le fichier
@file{program}:

@example
.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
@end example

@node Les cibles forcées, Les cibles vides, Les cibles fictives, Les règles
@section Règles sans instructions ni pré-requis
@cindex Les cibles forcées
@cindex cibles, forcées
@cindex @code{FORCE}
@cindex règle, sans instruction ni pré-requis

Si une règle n'a ni de pré-requis ni d'instruction et que la cible de la
règle est un fichier non-existant, alors @code{make} imagine que cette
cible a été mise à jour à chaque fois que cette règle est exécutée. Ceci
implique que toutes les cibles dépendant de celles-ci verront toujours
leurs instructions exécutée.

Voici un exemple d'illustration@tie{}:

@example
@group
clean: FORCE
        rm $(objects)
FORCE:
@end group
@end example

Ici la cible @samp{FORCE} satisfait les conditions spéciales, de
telle sorte que @file{clean} qui en dépend est forcé d'exécuté cette
instruction.  Il n'y a rien de spécial avec le nom @samp{FORCE}, mais
celui-ci est utilisé couramment de cette façon.

Comme vous pouvez le constater, utiliser @samp{FORCE} de cette façon
produit le même résultat qu'utiliser @samp{.PHONY: clean}.

Utiliser @samp{.PHONY} est plus explicite et plus efficace.  Cependant,
d'autres version de @code{make} ne supporte pas @samp{.PHONY}@tie{}; donc
@samp{FORCE} apparait dans beaucoup de makefiles.  @xref{Les cibles
fictives}.

@node Les cibles vides, Les cibles spéciales, Les cibles forcées, Les règles
@section Les fichiers cibles vides pour enregistrer un évènement
@cindex Les cibles vides
@cindex cibles, vides
@cindex enregister un évènement avec une cible vide

La @dfn{cible vide} est une variante de la cible fictive@tie{}; elle est
utilisée pour conserver l'instruction d'une action que vous requérez de
temps en temps. Mais contrairement à un fictive cible, le fichier cible
peut réellement exister@tie{}; mais son contenu n'a pas d'importance et le
plus souvent il reste vide.

L'objectif d'un fichier cible vide et d'enregistrer, avec sa dernière
date de modification, la moment où cette règle a été exécutée. Ceci
fonctionne ainsi car l'une des commandes de l'instruction est la commande
@code{touche} qui met à jour le fichier cible en le laissant vide.

Le fichier cible vide devrait avoir des pré-requis (sinon, cela n'a pas
de sens). Quand vous demandez de recompiler une cible vide, l'instruction
est exécutée si l'un des pré-requis est plus récent que cette cible@tie{}; en
d'autres termes, si l'un des pré-requis a changé depuis la dernière fois
que vous aviez lancé l'exécution de cette cible. Voici un exemple@tie{}:

@example
print: foo.c bar.c
        lpr -p $?"
        touch print
@end example
@cindex @code{print} cible
@cindex @code{lpr} (commande shell)
@cindex @code{touch} (commande shell)

@noindent
Acec cette règle, la règle @code{make print} n'exécute la commande
@code{lpr}
que si l'une des sources a changées depuis la dernière exécution de cette
règle. La variable automatique @samp{$?} est utilisée pour n'imprimer que
les
fichiers qui ont changés (@pxref{Les variables automatiques}).

@node Les cibles spéciales, Les cibles multiples, Les cibles vides, Les règles
@section Les noms spéciaux de cibles déjà intégrés
@cindex Les cibles spéciales
@cindex Les cibles spéciales intégrées
@cindex cibles, spéciales intégrées

Certains noms ont des significations spéciales s'ils apparaissent comme
cibles.

@table @code
@findex .PHONY
@item .PHONY

Les pré-requis de la cible spéciale @code{.PHONY} sont des cibles fictives
(ndt. phony=faux). Quand c'est le moment de traiter ce type de cible,
@code{make} exécute cette instruction inconditionnellement, sans tenir compte si
un
fichier ayant ce nom existe ou non ou quelle est la date de sa dernière
modification. @xref{Les cibles fictives, , Les cibles fictives}.

@findex .SUFFIXES
@item .SUFFIXES

Les pré-requis de la cibles spéciales @code{.SUFFIXES} sont les listes de
suffixes à utiliser pour vérifier les règles de suffixes.
@xref{Règle des suffixes, ,Ancienne règle des suffixes}.

@findex .DEFAULT
@item .DEFAULT

L'instruction spécifiée par @code{.DEFAULT} est utilisée pour toutes cibles
pour laquelle aucune règle n'a été trouvée (quelle soit explicite ou
implicite). @xref{Dernier ressort}. Si une instruction @code{.DEFAULT} est
spécifiée, tout fichier mentionné comme un pré-requis, mais non comme
une cible dans une règle, verra cette instruction exécuté pour son
compte. @xref{Recherche de règles implicites, ,Implicit Rule Search Algorithm}.

@findex .PRECIOUS
@item .PRECIOUS
@cindex cibles précieuses
@cindex préserver avec @code{.PRECIOUS}

Les cibles listées par @code{.PRECIOUS} recoivent un traitement
particulier@tie{}: si @code{make} est tué ou interrompu pendant l'exécution
de ses instructions, ces cibles ne sont pas effacée.  @xref{Interruptions,
,Intérrompre ou tuer @code{make}}.  Aussi, si une cible est un fichier
intermédiaire, elle ne sera pas effacée après qu'elle ne soit plus
utile, comme c'est normalement le cas.  @xref{Enchaînement de règles implicites,
,Enchaînement de règles implicites}. D'ailleurs, ceci se superpose avec
la règle spéciale @code{.SECONDARY}.

Vous pouvez aussi lister les modèles de règles pour les règles
implicites (comme pour @samp{%.o}) comme un fichier pré-requis de la
cible spéciale @code{.PRECIOUS} pour préserver les fichiers
intermédiaires créés par des règles dont le modèle correspond
à ce nom de fichier.


@findex .INTERMEDIATE
@item .INTERMEDIATE
@cindex cibles intermédiaires, explicites

Les cibles dont dépendent @code{.INTERMEDIATE} sont traitées comme des
fichiers intermédiaires. Les @xref{Enchaînement de règles implicites, ,Enchaînement de
règles implicites}, @code{.INTERMEDIATE} sans pré-réquis n'ont aucun
effet.

@findex .SECONDARY
@item .SECONDARY
@cindex cibles secondaires
@cindex preserver avec @code{.SECONDARY}

Les cibles listées par @code{.SECONDARY} sont traités comme des fichiers
intermédiaires, excepté qu'ils ne sont jamais effacés automatiquement.
@xref{Enchaînement de règles implicites, ,Enchaînement de règles implicites}.

Toutes les cibles listées dans @code{.SECONDARY} sans pré-requis sont
traitées comme secondaires (c'est à dire qu'une cible est enlevée
parqu'elle est considérée comme intermediaire).

@findex .SECONDEXPANSION
@item .SECONDEXPANSION

Si @code{.SECONDEXPANSION} est mentioné comme une cible n'importe où
dans le makefile, alors touts les pré-requis listés définis @emph{après}
qu'il apparaisse dans le fichier seront développés une seconde fois
après que tout les makefiles aient été lus.  @xref{Les développements secondaires,
,Les développements secondaires}.

@findex .DELETE_ON_ERROR
@item .DELETE_ON_ERROR
@cindex enlever des cibles après une erreur

Si @code{.DELETE_ON_ERROR} est mentioné comme une cible n'importe où
dans le makefile, donc @code{make} effacera la cible d'une règle si elle
a changé et l'instruction retournera un status non nul, juste comme ceci
est fait quand elle reçoit un signal. @xref{Erreurs dans les instructions, ,Erreurs dans les
instructions}.

@findex .IGNORE
@item .IGNORE

If you specify prerequisites for @code{.IGNORE}, then @code{make} will
ignore errors in execution of the recipe for those particular files.  The
recipe for @code{.IGNORE} (if any) is ignored.

If mentioned as a target with no prerequisites, @code{.IGNORE} says to
ignore errors in execution of recipes for all files.  This usage of
@samp{.IGNORE} is supported only for historical compatibility.  Since this
affects every recipe in the makefile, it is not very useful; we recommend
you use the more selective ways to ignore errors in specific recipes.
@xref{Erreurs dans les instructions, ,Erreurs dans les instructions}.

@findex .LOW_RESOLUTION_TIME
@item .LOW_RESOLUTION_TIME

If you specify prerequisites for @code{.LOW_RESOLUTION_TIME}, @command{make}
assumes that these files are created by commands that generate low
resolution time stamps.  The recipe for the @code{.LOW_RESOLUTION_TIME}
target are ignored.

The high resolution file time stamps of many modern file systems lessen the
chance of @command{make} incorrectly concluding that a file is up to date.
Unfortunately, some hosts do not provide a way to set a high resolution file
time stamp, so commands like @samp{cp -p} that explicitly set a file's time
stamp must discard its sub-second part.  If a file is created by such a
command, you should list it as a prerequisite of @code{.LOW_RESOLUTION_TIME}
so that @command{make} does not mistakenly conclude that the file is out of
date.  For example:

@example
@group
.LOW_RESOLUTION_TIME: dst
dst: src
        cp -p src dst
@end group
@end example

Since @samp{cp -p} discards the sub-second part of @file{src}'s time stamp,
@file{dst} is typically slightly older than @file{src} even when it is up to
date.  The @code{.LOW_RESOLUTION_TIME} line causes @command{make} to
consider @file{dst} to be up to date if its time stamp is at the start of
the same second that @file{src}'s time stamp is in.

Due to a limitation of the archive format, archive member time stamps are
always low resolution.  You need not list archive members as prerequisites
of @code{.LOW_RESOLUTION_TIME}, as @command{make} does this automatically.

@findex .SILENT
@item .SILENT

If you specify prerequisites for @code{.SILENT}, then @code{make} will not
print the recipe used to remake those particular files before executing
them.  The recipe for @code{.SILENT} is ignored.

If mentioned as a target with no prerequisites, @code{.SILENT} says not to
print any recipes before executing them.  You may also use more selective
ways to silence specific recipe command lines.  @xref{Donner un retour, ,Recipe
Echoing}.  If you want to silence all recipes for a particular run of
@code{make}, use the @samp{-s} or @w{@samp{--silent}} option
(@pxref{Résumé des options}).

@findex .EXPORT_ALL_VARIABLES
@item .EXPORT_ALL_VARIABLES

Simply by being mentioned as a target, this tells @code{make} to export all
variables to child processes by default.  @xref{La récursion et les variables,
,Communicating Variables to a Sub-@code{make}}.

@findex .NOTPARALLEL
@item .NOTPARALLEL
@cindex parallel execution, overriding

If @code{.NOTPARALLEL} is mentioned as a target, then this invocation of
@code{make} will be run serially, even if the @samp{-j} option is given.
Any recursively invoked @code{make} command will still run recipes in
parallel (unless its makefile also contains this target).  Any prerequisites
on this target are ignored.

@findex .ONESHELL
@item .ONESHELL
@cindex recipe execution, single invocation

If @code{.ONESHELL} is mentioned as a target, then when a target is built
all lines of the recipe will be given to a single invocation of the shell
rather than each line being invoked separately (@pxref{Exécution, ,Recipe
Exécution}).

@findex .POSIX
@item .POSIX
@cindex POSIX-conforming mode, setting

If @code{.POSIX} is mentioned as a target, then the makefile will be parsed
and run in POSIX-conforming mode.  This does @emph{not} mean that only
POSIX-conforming makefiles will be accepted: all advanced GNU @code{make}
features are still available.  Rather, this target causes @code{make} to
behave as required by POSIX in those areas where @code{make}'s default
behavior differs.

In particular, if this target is mentioned then recipes will be invoked as
if the shell had been passed the @code{-e} flag: the first failing command
in a recipe will cause the recipe to fail immediately.
@end table

Any defined implicit rule suffix also counts as a special target if it
appears as a target, and so does the concatenation of two suffixes, such as
@samp{.c.o}.  These targets are suffix rules, an obsolete way of defining
implicit rules (but a way still widely used).  In principle, any target name
could be special in this way if you break it in two and add both pieces to
the suffix list.  In practice, suffixes normally begin with @samp{.}, so
these special target names also begin with @samp{.}.  @xref{Règle des suffixes,
,Ancienne règle des suffixes}.

@node Les cibles multiples, Les règles multiples, Les cibles spéciales, Les règles
@section Les cibles multiples pour une règle
@cindex cibles multiples
@cindex plusieurs cibles pour une règle
@cindex cibles, multiples
@cindex règle, avec des cibles multiples

Quand une règle explicite a plusieurs cibles, elles peuvent être
traitées de l'une des deux façons suivantes@tie{}: comme cibles
indépendantes ou comme cibles groupées. La façon dont elles seront
traitée est déterminée par le séparateur qui apparaît après la liste des cibles.

@subsubheading Règles avec des cibles indépendantes
@cindex cibles independantes
@cindex cibles, independantes

Les règles qui utilisent le séparateur de cible standard @code{:},
définissent des cibles indépendantes.  Ceci est équivalent à écrire la
même règle à chaque fois pour chaque cible, ce qui duplique les
pré-requis et les instructions.  Typiquement, l'instruction utiliserait des
variables comme @samp{$@@} pour spécifier quelle cible doit être
compilée.

Les règles avec des cibles indépendantes sont utiles dans deux cas@tie{}:

@itemize @bullet
@item
Vous voulez juste des pré-requis, sans instruction. Par exemple@tie{}:

@example
kbd.o command.o files.o: command.h
@end example

@noindent
donne un pré-requis additionnel pour chacun des trois fichiers objet mentionés.
Ceci est équivalent d'écrire@tie{}:

@example
kbd.o: command.h
command.o: command.h
files.o: command.h
@end example

@item
Des instructions similaires fonctionnent pour toutes les cibles. La variable
automatique @samp{$@@} peut être utilisée pour se substituer à la cible particulière
pour être recompilé en commandes (@pxref{Les variables automatiques}).  Par exemple@tie{}:

@example
@group
bigoutput littleoutput : text.g
        generate text.g -$(subst output,,$@@) > $@@
@end group
@end example
@findex subst

@noindent
est équivalent à

@example
bigoutput : text.g
        generate text.g -big > bigoutput
littleoutput : text.g
        generate text.g -little > littleoutput
@end example

@noindent
Ici nous faisons l'hypothèse que le programme hypothétique
@code{generate} construit deux types de sortie, la première si l'option
utilisée est @samp{-big} la deuxième si c'est l'option @samp{-little}.
@xref{Fonctions de texte, ,Fonctions pour la substitution dans les
chaînes et leur analyses}, pour une explication de la fonction
@code{subst}.
@end itemize

Supposez que vous vouliez changer les pré-requis en fonction des cibles,
comme la variable @samp{$@@} vous permet de le faire dans une instruction.
Vous ne pouvez pas le faire avec plusieurs cibles dans une règle
ordinaire, mais vous pouvez le faire avec un @dfn{modèle statique de
règles}.  @xref{Les modèles statiques, ,Les modèles statiques de règle}.


@subsubheading Règles dans des cibles groupées
@cindex cibles groupées
@cindex cibles, groupées
Si à la place de cibles indépendantes, vous avez une instruction qui génère
plusieurs fichiers à partir d'une seule invocation, vous pouvez exprimer
cette relation en utilisant @emph{grouped targets} (ndt. cibles
groupées).  Une règle de cible groupées utilise le séparateur @code{&:}
(le caractère @samp{&} veut ici dire ``tout'').

Quand @code{make} compile n'importe laquelle de ces cibles, il comprend
que toutes les autres cibles du groupes sont aussi créées comme résultat
de l'invocation de l'instruction. De plus, si seulement quelques unes des
cibles groupées sont périmées ou manquante, @code{make} réalisera
qu'exécuter l'instruction mettra toutes les cibles à jour.

Voici par exemple une règle qui définit une cible groupée@tie{}:

@example
@group
foo bar biz &: baz boz
        echo $^ > foo
        echo $^ > bar
        echo $^ > biz
@end group
@end example

Pendant l'exécution d'une instruction de cibles groupées, la variable
automatique @samp{$@@} a le nom de la cible particulière du groupe qui a
déclenché cette règle. Il faut faire attention si l'instruction de règle de
cibles groupées dépend de cette variable.

À la différence des cibles indépendantes, une règle de cibles groupées
@emph{doit} inclure une instruction.  Cependant, les cibles qui sont membre
de cibles goupées peuvent aussi apparaitre dans les définitions
de règles pour des cibles indépendantes et qui n'ont pas d'instructions.

Chaque cible peut n'avoir qu'une instruction qui lui soit associée. Si des
cibles groupées apparaissent soit dans une règle de cible indépendante
ou dans une autre règle de cible groupée ayant une instruction, vous
recevrez un message d'avertissement et la dernière instruction remplacera
celles qui précèdent.  De plus la cible sera enlevée du groupe précédent
et apparaîtra seulement dans le nouveau groupe.

Si vous voulez qu'une cible apparaisse dans plusieurs groupes, vous
devez utiliser les cibles groupées séparées par des double double
points, @code{&::}, quand vous déclarez tous les groupes contenant cette
cible. Les cibles groupées avec des double double points sont
considérées à chaque indépendament et chaque groupe d'instruction de règles
groupées avec des double double point ne sera exécuté qu'une fois au
plus, si au moins l'une de ses multiples cibles demande une muse à jour.

@node Les règles multiples, Les modèles statiques, Les cibles multiples, Les règles
@section Les règles multiples pour une cible
@cindex Les règles multiples pour une cible
@cindex plusieurs règles pour une cible
@cindex règles, multiples pour pour une cible
@cindex cible, Les règles multiples pour une

Un fichier peut être la cible de plusieurs règles. Tous les pré-requis
mentionnés dans toutes les règles sont fusionnés en une liste de
pré-requis pour cette cible.  Si la cible est plus ancienne que
n'importe quel pré-requis de n'importe quelle règle, l'instruction est
exécutée.

Il ne peut y a avoir qu'une seule exécutée pour un fichier.  Si plus
d'une règle donne une instruction pour le même fichier, @code{make} utilise
la dernière qui a été donnée et renvoie un message d'erreur. (Un cas
particulier est quand le nom du fichier commence par un point, dans ce
cas aucune erreur n'est renvoyée. Ce comportement bizarre n'existe que
pour garder une compatibilité avec les autres implémentations de
@code{make}@dots{} et vous devriez éviter de l'utiliser).  De temps en
temps il peut etre utile d'avoir la même cible qui invoque plusieurs
instructions, qui sont définies à différents endroits de votre
makefile@tie{}; vous pouvez utiliser les @dfn{règles à double double
points} (@pxref{Double double points}) pour cela.

Une règle supplémentaire avec juste des pré-requis peut être utilisée
pour donner des pré-requis supplémentaires à plusieurs fichiers d'un
seul coup. Par exemple, les makefiles ont souvent une variable, comme
@code{objects}, qui contient une liste de tous les fichiers de sortie du
compilateur sur le système en train d'etre construit. Un moyen simple
pour les recompiler tous si @file{config.h} change et d'écrire les
instructions suivantes@tie{}:

@example
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
@end example

Ceci pour être inséré ou enlever sans changer les règles qui spécifient
réellement comment compiler les fichiers objets, ce qui donne une façon
pratique de faire si vous voulez ajouter momentanément un pré-requis
additionel.

Un autre bon tuyaux est que les pré-requis additionnel peuvent être
spécifiés avec une variable que vous définissez à @code{make} par des
arguments en ligne de commande (@pxref{Forcer, ,Variables de
remplacement}).  Par exemple,

@example
@group
extradeps=
$(objects) : $(extradeps)
@end group
@end example

@noindent
signifie que la commande @samp{make extradeps=foo.h} considèrera 
@file{foo.h} comme un pré-requis de chaque fichier objet, mais un 
@samp{make} de base ne le fera pas.

Si aucune des règles explicites de la cible n'a d'instruction, @code{make}
recherche une règle impicite qui puisse s'appliquer @pxref{Les règles
implicites, ,Utiliser les règles implicites}).

@node Les modèles statiques, Double double points, Les règles multiples, Les règles
@section modèles statiques de règles
@cindex static pattern rule
@cindex rule, static pattern
@cindex pattern rules, static (not implicit)
@cindex varying prerequisites
@cindex prerequisites, varying (static pattern)

Les @dfn{modèles statiques de règles} sont des règles, qui spécifient
plusieurs cibles et construisent les noms des pré-requis pour chaque
cible en se basant sur le nom de la cible. Elles sont plus générales que
les règles ordinaires avec des cibles multiples car les cibles n'ont pas
besoin d'avoir les mêmes pré-requis. Leur pré-requis doivent être 
@emph{analogues}, mais non nécessairement @emph{identiques}.

@node Utilisation statique, Statique ou implicite, Les modèles statiques, Les modèles statiques
@subsection Syntaxe des modèles de règles statiques
@cindex les modèles statiques de règles, syntaxe
@cindex modèles de règles, statique, syntaxe

Voici la syntaxe des modèles statiques de règles@tie{}:

@example
@var{cibles} @dots{}: @var{modèle de cible}: @var{modèles de pré-requis} @dots{}
        @var{instruction}
        @dots{}
@end example

@noindent
La liste des @var{cibles} spécifie les cibles pour lesquelles la règle
s'applique. Les cibles peuvent contenir des caractères génériques, juste
comme les cibles des règles ordinaires (@pxref{Les caractères génériques,
,Utiliser les caractères génériques dans les noms de fichiers}).

@cindex modèle de règle, statique (et non implicite)
@cindex radical
Le @var{modèle de cible} et les @var{modèles de pré-requis}  disent
comment construire les pré-requis pour chaque cible. Chaque cible est
comparée avec le @var{modèle de cible} pour en extraire la partie du nom
de la cible, appelée le @dfn{radical}.  Ce radical est substitué dans
chacun des @var{modèles des pré-requis} pour construire les noms des
pré-requi (un pour chacun des @var{modèles de pré-requis}).

Chaque modèle contient normalement le caractère @samp{%} une seule
fois. Quand la @var{modèle de cible} correspond à une cible, le
caractère @samp{%} peut correspondre à n'importe quelle partie du nom de
la cible@tie{}; cette partie est appelée le @dfn{radical}.  Le reste du
modèle doit correspondre exactement.  Par exemple, la cible @file{foo.o}
correspond au modèle @samp{%.o}, avec @samp{foo} comme radical.  Les
cibles @file{foo.c} et @file{foo.out} ne correspondent pas à ce modèle.@refill

@cindex modèle de pré-requis, statique (non implicite)
Les noms des pré-requis pour chaque cible sont faire en substituant le
radical pour chaque @samp{%} dans le modèle du pré-requis.  Par exemple,
si un modèle de pré-requis est @file{%.c}, la substitution du radical
@samp{foo} donnera le nom de pré-requis @file{foo.c}.  On peut aussi
écrire un modèle de pré-requis sans qu'il contienne de caractère
@samp{%}@tie{}; dans ce cas, le pré-requis est le même pour toutes les
cibles.

@cindex @code{%}, échappement dans un modèle statique
@cindex @code{%}, échapper avec @code{\} (barre oblique inversée)
@cindex @code{\} (barre oblique inversée), pour échapper @code{%}
@cindex barre oblique inversée (@code{\}), pour échapper @code{%}
@cindex échappement @code{%}, dans un modèle statique
Les caractères @samp{%} dans les modèle de règles peuvent être échappés
en les précédant d'une barre oblique inversée (@samp{\}).  Les barres
obliques inversées, qui autrement échapperaient les caractères @samp{%}
peuvent être à leur tour échappées avec plus de barres obliques.  Les
barres obliques inversées qui échappent les caractères @samp{%} ou
d'autres barres obliques inversées sont enlevés du modèle avant qu'il
soit comparé aux noms de fichiers ou qu'un radical y soit substitué.  Les
barres obliques inversées qui ne risquent pas d'échapper les caractères
@samp{%} ne sont pas affectées.  Par exemple, le motif
@file{the\%weird\\%pattern\\} a @samp{the%weird\} qui précède le
caractère @samp{%} opérationnel et @samp{pattern\\} qui le suit. Les
deux barres obliques inversées sont finalement laissées seules,
parcequ'elles ne peuvent pas affecter aucun caractère @samp{%}.@refill

Voici un exemple, qui compile chacun des fichiers @file{foo.o} et
@file{bar.o} depuis le fichier @file{.c} correspondant@tie{}:

@example
@group
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@@
@end group
@end example

@noindent
Ici la variable automatique @samp{$<} contient le nom du pré-requis et
@samp{$@@} la variable qui contient le nom de la cible@tie{}; see
@ref{Les variables automatiques}.

Chaque cible spécifiée doit correspondre au modèle de cible@tie{}; un
avertissement est retourné pour chaque cible qui ne le fait pas. Si vous
avez une liste de fichiers, dont seulement certains d'entre-eux
correspondent au modèle, vous pouvez utiliser la fonction @code{filter}
pour retirer les noms de fichiers qui n'ont pas de correspondance
(@pxref{Fonctions de texte, ,Fonctions pour faire des subtitutions dans
les chaînes et les analyser}):

@example
files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $<
@end example

@noindent
Dans cet exemple, le résultat de @samp{$(filter %.o,$(files))} est @file{bar.o
lose.o} et le premier modèle statique de règle oblige chacun de ces
fichiers à être mise à jour en compilant le fichier source C correspondant.
Le résultat de @w{@samp{$(filter %.elc,$(files))}} est @file{foo.elc},
de telle sorte que le fichier est fabriqué à partir de @file{foo.el}.@refill

Un autre exemple montre comment utiliser @code{$*} dans un modèle
satique de règles@tie{}:
@vindex $*@r{, et les modèles statiques}

@example
@group
bigoutput littleoutput : %output : text.g
        generate text.g -$* > $@@
@end group
@end example

@noindent
Quand la commande @code{generate} est exécutée, @code{$*} se développe
comme le radical, c'est à dire soit @samp{big}, soit @samp{little}.


@node Statique ou implicite, ,Utilisation statique, Les modèles statiques
@subsection Modèle statique de règles versus règles implicites
@cindex règle, modèle statique versus implicite
@cindex modèle statique de règle, versus implicite

Un modèle statique de règle a beaucoup de chose en commun avec une règle
implicite définie comme un modèle de règle (@pxref{Modèle de règles,
,Définir et redéfinir des modèles de règles}).  Les deux ont un modèle
pour la règle et un modèle pour construire les noms des pré-requis.  La
différence est comment @code{make} decide @emph{quand} la règle s'applique.

Une règle implicte @emph{peut} s'applique à n'importe quelle cible qui
correspond à son modèle, mais elle @emph{s'applique} seulement si la
cible n'a pas d'autre instruction spécifiée et seulement quand les
pré-requis peuvent être trouvés. Si plus d'une règle implicite apparait
applicable, une seule d'entre elles sera appliquée@tie{}; le choix
dépendant de l'ordre d'apparition des règles.

Par contrate, un modèle statique de règle s'applique à une liste
précise de cibles, que vous avez spécifiées dans la règle. Il ne peut
pas s'appliquer à aucune autre règle et il s'applique invariablement à
chacune des cibles qui ont été spécifiées. Si deux règles entrent en
conflit et que chacune a une instruction, c'est une erreur.

Le modèle statique de règle peut être meilleur qu'une règle implicite
pour ces raisons@tie{}:

@itemize @bullet
@item
Vous pourriez vouloir remplacer la règle implicite usuelle pour
quelques-uns des fichiers dont les noms ne peuvent pas être définis dans
des catégories syntaxiques, mais peuvent être donné dans une liste explicite.

@item
Si vous ne pouvez pas être sûr des contenus précis des répertoires que
vous utilisez, vous pourriez ne pas être certains que certains fichiers
non adéquats et présents dans les répertoires ne conduisent pas une
mauvaise utilisation d'une règle implicite par @code{make}.  Le choix
peut dépendre de l'ordre dans lequel les règles implicites sont
recherchées. Avec des modèles statique de règles, il n'y a pas
d'incertitude@tie{}: chaque règle s'applique précisément aux cibles
spécifiées.
@end itemize


@node Double double points, Pré-requis automatiques, Les modèles statiques, Les règles
@section Règles avec double double points
@cindex règle avec double double points
@cindex règle, double double point (@code{::})
@cindex Les règles multiples pour une cibles (@code{::})
@cindex @code{::} règles (double double points)

Les règles à @dfn{double double points} sont des règles explicites
écrites avec @samp{::} au lieu de @samp{:} après les noms de leur
cibles. Elles sont traitées différemment des règles ordinaires quand la
même cible apparaît dans plus d'une règle. Les modèles de règles avec
double double points ont une signification totalement différente
(@pxref{Régles pour correspondre à tout}).

Quand une cible apparait dans plusieurs règles, toutes les règles
doivent être du même type@tie{}: soit toutes avec double points, soit
toutes avec double double points. Si elles sont du type double double
points, chacune est indépendante l'une de l'autre. Chaque instruction à
double double points est exécutée si la cible est plus ancienne que
n'importe lequel de ses pré-requis.  S'il n'y a pas de pré-requis pour
cette règle, son instruction est toujours exécutée (même si la cible existe
déjà).  Ceci peut aboutir à n'en exécuter aucune, une ou toute les
règles à double double points.

Les règles à double double points qui ont la même cible sont en fait
complètement séparées les unes des autres. Chacune de ces règles est
exécutée individuellement, juste comme les sont les règles pour des
cibles différentes.

Les règles à double double points sont exécutées pour une cible dans
l'ordre d'apparition dans le makefile. Cependant, les cas où les règles à
double double points sont réellement utiles, sont ceux pour lesquels
l'ordre d'exécutions des instructions n'est pas utile.

Les règles à double double points sont un peu obscures et elles ne sont
pas souvent utiles@tie{}; elles donnent un mécanisme pour les cas où la
méthode de mise à jour de la cible est différente selon les fichiers
pré-requis qui en sont à l'origine, et ces cas sont rares.

Chaque règle à double double points devrait spécifier une instruction@tie{};
si elle ne le fait pas, une règle implicite sera utilisée, si l'une
d'entre-elles peut s'appliquer. @xref{Les règles implicites, ,Utiliser les
règles implicites}.

@node Pré-requis automatiques, , Double double points, Les règles
@section Générer les pré-requis automatiquement
@cindex pré-requis, génération automatique
@cindex génération automatique des pré-requis
@cindex générer les pré-requis automatiquement

Dans le makefile d'un programme, beaucoup des règles dont vous avez
besoin ne font souvent que dire que certains fichiers objet dépendent de
certains fichiers d'en-tête. Par exemple, si @file{main.c} utilise
@file{defs.h} à travers une directive @code{#include}, vous
écrivez@tie{}:

@example
main.o: defs.h
@end example

@noindent
Vous avez besoin de cette règle, pour que @code{make} sache qu'il doit
recompliler @file{main.o} à chaque fois que @file{defs.h} change. Vous
pouvez voir que pour un gros programme, vous auriez à écrire des
douzaines de règles de ce type dans votre makefile.  Et vous devrez
faire attention à toujours mettre à jour le makefile, à chaque fois que
vous ajoutez ou que vous enlevez une directive @code{#include}.
@cindex @code{#include}

@cindex @code{-M} (to compiler)
Pour éviter ces tâches un peu harrassantes, la plupart des compilateurs
C modernes peuvent écrire ces règle pour vous, en examinant les lignes
@code{#include} de vos fichiers source. La plupart du temps, ceci est
fait en donnant l'option @samp{-M} au compilateur. Par exemple, la
commande@tie{}:

@example
cc -M main.c
@end example

@noindent
Génèrera la sortie@tie{}:

@example
main.o@tie{}: main.c defs.h
@end example

@noindent
Donc nous n'aurez plus à écrire ces règles par vous même. Le compilateur
le fera pour vous.

Notez qu'une telle règle revient à mentionner @file{main.o} dans un
makefile, de telle sorte qu'il ne pourra jamais être considéré comme un
fichier intermédiaire pour une recherche de règle implicite. Ceci veut
dire que @code{make} n'enlèvera jamais ce fichier après l'avoir
utilisé@tie{}; @pxref{Enchaînement de règles implicites, ,Enchaînement de règles
implicites}.

@cindex @code{make depend}
Avec les vieux programmes @code{make}, c'était traditionnellement la
pratique d'utiliser cette fonctionalité du compilateur pour générer les
pré-requis sur demande avec une commande du genre @samp{make depend}.
Cette commande créait un fichier @file{depend} contenant tous les
pré-requis générés automatiquement@tie{}; et le makefile pouvait alors
utiliser @code{include} pour les lire (@pxref{Inclure d'autres makefiles}).

Dans GNU @code{make}, cette fonctionalité de re-faire des makefiles rend
cette pratique obsolète ---@tie{}vous n'avez jamais à dire explicitement
à @code{make} de générer les pré-requis, parcequ'il regénère toujours
n'importe quel makefile qui n'est plus à jour.  @xref{Reconstruire
les Makefiles}.

La pratique que nous recommendons pour la génération de pré-requis
automatiques est d'avoir une makefile correspondant à chaque fichier
source.  Pour chaque fichier sources @file{@var{name}.c} il y aura un
makefile @file{@var{name}.d} qui listera de quels fichiers dépend le
fichier objet @file{@var{name}.o}.  De cette façon, seuls les fichiers
source qui ont changés ont besoin d'être re-examinés pour produire les
nouveaux pré-requis.

Voici le modèle de règle pour générer un fichier de pré-requis (c'est à
dire un makefile) appelé @file{@var{name}.d} depuis un fichier source C
appelé @file{@var{name}.c}:

@smallexample
@group
%.d: %.c
        @@set -e; rm -f $@@; \
         $(CC) -M $(CPPFLAGS) $< > $@@.$$$$; \
         sed 's,\($*\)\.o[@tie{}:]*,\1.o $@@@tie{}: ,g' < $@@.$$$$ > $@@; \
         rm -f $@@.$$$$
@end group
@end smallexample

@noindent
@xref{Modèle de règles}, pour retrouver les explications sur la façon de
définir un modèle de règle. L'option @samp{-e} donnée au shell l'oblige
à s'arrêter immédiatement si la commande @code{$(CC)} (ou tout autre
commande) échoue (il s'arrête en retournant un code de status non nul).
@cindex @code{-e} (option du shell)

@cindex @code{-MM} (au compilateur GNU)
Avec le compilateur GNU C, vous pourriez vouloir utiliser l'option
@samp{-MM} à la place de @samp{-M}.  Ceci omets les pré-requis pour les
fichiers d'en-têtes système.
@xref{Preprocessor Options, , Contrôler les options du pré-processeur, gcc,
Utiliser GNU CC}, pour plus de details.

@cindex @code{sed} (shell command)
La commande @code{sed} sert à traduire (par exemple):

@example
main.o : main.c defs.h
@end example

@noindent
en :

@example
main.o main.d : main.c defs.h
@end example

@noindent
@cindex @code{.d}
Ceci rend chaque fichier @samp{.d} dépendant de tous les fichiers source
et de tous les fichiers d'en-tête correspondant au fichier @samp{.o} qui
dépend d'eux.  Le programme @code{make} sait alors qu'il doit regénérer 
les pré-requis chaque fois que l'un des fichiers source ou l'un des
fichiers d'en tête change.

Une fois que vous avez défini la règle pour refaire les fichiers
@samp{.d}, il vous suffit d'utiliser la directive @code{include} pour
les lire tous.  @xref{Inclure d'autres makefiles}.  Par exemple@tie{}:

@example
@group
sources = foo.c bar.c

include $(sources:.c=.d)
@end group
@end example

@noindent
(Cet exemple utilise la référence d'une substitution de variable pour
traduire la liste des fichiers source @samp{foo.c bar.c} en une liste de
makefiles pré-requis @samp{foo.d bar.d}.  @xref{Références de
substitution}, pour de plus amples explication sur les références de
substitutions.)  Comme les fichiers  @samp{.d} sont des makefiles comme
n'importe quel autre, @code{make} les reconstruira quand ce sera
nécessaire sans vous demander plus de travail.  @xref{Reconstruire les Makefiles}.

Notez que les fichiers @samp{.d} contiennent les définitions des
cibles@tie{}; vous devriez vous assurer de placer une directive
@code{include} @emph{après} la première cible, cible par défaut, dans
votre makefiles ou vous risquez d'avoir un fichier objet aléatoire qui
devienne la cible par défaut.  @xref{Comment fonctionne Make}.


@node Les instructions, Utiliser les variables, Les règles, Top
@chapter Écrire des instructions dans les règles
@cindex instructions
@cindex instruction, comment les écrire
@cindex écrire des instructions

L'instruction d'une règle consiste en une ou plusieurs lignes de commande
shell à exécuter, l'une après l'autre, dans leur ordre d'apparition. Le
résultat typique de l'exécution de ces commandes est que la cible est
mise à jour.

Les utilisateurs peuvent utiliser plusieurs programmes shell différents,
mais les instructions d'un makefiles sont toujours interprétées par 
@file{/bin/sh}, sauf si le makefile l'a spécifié autrement.
@xref{Exécution, ,Exécution d'une instruction}.

@node La syntaxe des instructions, Donner un retour, Les instructions, Les instructions
@section La syntaxe des instructions
@cindex syntaxe d'une instruction
@cindex syntaxe des instructions

Les makefiles ont la fonctionnalité inhabituelle d'utiliser deux
syntaxes différentes dans un même fichier.  La plus grande partie du
makefile utilise la syntaxe de @code{make} (@pxref{Les Makefiles,
,Écrire des makefiles}). Cependant, les instructions sont conçues
pour être interprétées par le shell et elles sont donc écrites en
utilisant sa syntaxe. Le programme @code{make} n'essaie pas de
comprendre la syntaxe du shell@tie{}: il ne fait que quelques
traductions bien spécifiques sur le contenu de l'instruction avant de la
redonner au shell.

Chaque ligne d'une instruction doit commencer par une tabulation (ou le
premier caractère défini dans le contenu de la variable
@code{.RECIPEPREFIX}; @pxref{Variables spéciales}), excepté que la
première ligne d'instruction peut être attachée à la ligne contenant la
cible et les pré-requis en étant alors séparée par un point virgule.
@emph{Toutes} les lignes d'un makefile qui débutent par une tabulation
et apparaissent dans le ``contexte d'une règle'' (c'est à dire, après
que la définition d'une règle ait commencé jusqu'à la définition d'une
autre règle ou d'une variable), toutes ces lignes seront considérées
comme une partie d'instruction pour cette règle.  Les lignes blanches et
les lignes qui ne contiennent que des commentaires seront ignorées
parmis les lignes d'instructions.

Quelques unes des conséquences de ces règles sont@tie{}:

@itemize @bullet
@item
Une ligne blanche, qui démarre par une tabulation n'est pas une ligne
blanche@tie{}: c'est une ligne d'instruction vide (@pxref{Instructions vides}).

@cindex commentaires, dans les instructions
@cindex instructions, commentaires
@cindex @code{#} (commentaires), dans les instructions
@item
Un commentaire dans une instruction n'est pas un commentaire
@code{make}; il sera passé au shell tel que. C'est donc le shell qui
décidera de le traiter comme un commentaire ou non.

@item
Une définition de variable dans un ``contexte de définition de règle'',
qui est donc sur une ligne dont le premier caractère est une tabulation
sera considérée comme faisant partie de l'instruction, et non comme une
défintion de variable @code{make}. Elle sera donc transmise au shell.

@item
Une expression conditionnelle (@code{ifdef}, @code{ifeq},
etc. @pxref{Syntaxe conditionnelle, ,Syntaxe de conditions}) dans un
``contexte de définition de règle'', qui est donc sur une ligne dont le
premier caractère est une tabulation, sera considérée comme faisant
partie de l'instruction et sera passée au shell.
@end itemize

@node Couper les lignes d'instructions, Les variables dans les instructions, La syntaxe des instructions, La syntaxe des instructions
@subsection Couper les lignes d'instructions
@cindex instructions, couper
@cindex couper les instructions
@cindex instructions, barre oblique inversée (@code{\})
@cindex instructions, échapper le caractère de nouvelle ligne
@cindex barre oblique inversée (@code{\}), dans les instructions
@cindex @code{\} (barre oblique inversée), dans les instructions
@cindex échapper les nouvelles lignes, dans les instructions
@cindex nouvelle ligne, échapper, dans les instructions

Un des quelques cas où @code{make} interprète une ligne d'instruction est
la vérification des barres obliques inversées juste avant un caractère
de nouvelle ligne. Comme dans la syntaxe habituelle, une seule ligne
logique peut être coupée en plusieurs lignes physiques dans le makefile
en plaçant des barres obliques inversées devant chaque caractères de
nouvelles lignes.  Une séquence de lignes comme celles ci est considérée
comme une seule ligne d'instruction et une instance du shell sera invoquée
pour l'exécuter.

Cependant, à la différence de la façon dont ils sont traitées à d'autres
endroits dans le makefile (@pxref{Couper les lignes, , Couper les lignes
longues}), les paires de barres obliques inversées et caractères de
nouvelle ligne ne sont @emph{pas} enlevées des instructions. Les deux
caractères, barre oblique inversée et nouvelle ligne sont préservés et
passés au shell. Si le premier caractère de la ligne suivant les
caractères barre oblique inversée et nouvelle ligne est le préfixe des
lignes d'instructions (une tabulation par défaut@tie{}; @pxref{Variables
spéciales}), alors ce caractère (et seulement celui ci) est enlevé.
Les espaces blancs ne sont jamais ajoutés à l'instruction.

Par exemple, l'instruction pour toutes les cibles dans ce makefile@tie{}:

@example
@group
all@tie{}:
        @@echo no\
space
        @@echo no\
        space
        @@echo one \
        space
        @@echo one\
         space
@end group
@end example

@noindent
consiste en quatre commandes séparées dont la sortie est@tie{}:

@example
@group
nospace
nospace
one space
one space
@end group
@end example

Pour un exemple plus complexe, voici ce makefile@tie{}:

@example
@group
all@tie{}:@tie{}; @@echo 'hello \
        world'@tie{}; echo "hello \
    world"
@end group
@end example

@noindent
invoquera un shell avec la commande@tie{}:

@example
@group
echo 'hello \
world'@tie{}; echo "hello \
    world"
@end group
@end example

@noindent
qui, selon les règles d'échappement du shell donnera la sortie suivante@tie{}:

@example
@group
hello \
world
hello     world
@end group
@end example


@noindent
Notez comment les paires de barres obliques inversées et nouvelles
lignes ont été enlevées à l'intérieur de la chaîne mises entre doubles
guillemets (@code{"@dots{}"}), mais pas de la chaîne mise entre simple
guillemets (@code{'@dots{}'}).  C'est la façon par défaut du shell
(@file{/bin/sh}) de traiter les paires barres obliques inversées et
nouvelle lignes.  Si vous spécifiez un shell différent dans votre
makefiles, il pourrait les traiter différemment.

Parfois, vous pouvez vouloir couper une longue ligne à l'intérieur de
guillemets, mais vous ne voulez pas que les caractère barre oblique
inversée et nouvelle ligne apparaissent dans le contenu entre guillemets.
C'est souvent la cas, quand vous passez des scripts à des langages comme
Perl, pour lequel les barres obliques inversées externes dans un script
peuvent en changer la signification ou conduire à une erreur de
syntaxe. Une façon simple de gérer ceci est de placer la chaîne entre
guillemet, ou même la commande entière, dans une variable @code{make} et
d'utiliser ensuite cette variable dans l'instruction. Dans cette situation,
la règle des nouvelles lignes échappée pour les makefiles sera utilisée
et les paires de barres obliques inversées et caractère de nouvelle
ligne seront enlevées. Si nous ré-écrivons notre exemple ci-dessous en
utilisant cette méthode@tie{}:

@example
@group
HELLO = 'hello \
world'

all@tie{}:@tie{}; @@echo $(HELLO)
@end group
@end example

@noindent
we will get output like this:

@example
@group
hello world
@end group
@end example

Si vous le voulez, vous pouvez aussi utiliser des variables spécifique à
la cible (@pxref{Variables spécifiques à la cible, ,Valeurs des variables
spécifiques aux cibles}) pour obtenir une correspondance plus étroite
entre la variable et l'instruction qui l'utilise.

@node Les variables dans les instructions, , Couper les lignes d'instructions, La syntaxe des instructions
@subsection Utiliser les variables dans les instructions
@cindex référence de variable dans les instructions
@cindex instructions, utilisation des variables

Une action de transformation de @code{make} sur les instructions est le
développement de toute référence de variable qu'elles contiennent
(@pxref{Référencer une variable,les bases des références de variables}).  Ceci se
passe quand @code{make} a fini de lire tous les fichiers makefiles et
que la cible a été déterminée comme obsolète@tie{}; donc les instructions
pour les cibles qui ne sont pas recompilées n'ont jamais été développées.

Les références de variables ou de fonctions dans les instructions ont la
même syntaxe et sémantique que les références faites à d'autres endroits
dans le makefile.  Elles ont aussi les mêmes règles d'échappement@tie{}:
si vous voulez qu'un signe dollar apparaisse dans votre instruction, vous
devez le doubler (@samp{$$}).  Pour les shells comme le shell par
défaut, cette utilisation du dollar est un signe qui introduit les
variables, il est important de garder clairement à l'esprit si la
variable que vous voulez se réfère à une variable @code{make} (utilisant
un signe dollar unique) ou une variable du shell (utilisant deux signes
dollar).  Par exemple@tie{}:

@example
@group
LIST = one two three
all:
        for i in $(LIST); do \
            echo $$i; \
        done
@end group
@end example

@noindent
fait la commande suivante est passée au shell@tie{}:

@example
@group
for i in one two three; do \
    echo $i; \
done
@end group
@end example

@noindent
ce qui génèrera le résultat attendu@tie{}:

@example
@group
one
two
three
@end group
@end example

@node Donner un retour, Exécution, La syntaxe des instructions, Les instructions
@section Recipe Echoing
@cindex donner un retour dans les instructions
@cindex opération silencieuse
@cindex @code{@@} (dans les instructions)
@cindex instructions, donner un retour
@cindex imprimer les instructions

Normalement @code{make} retourne chacune des lignes de l'instruction avant
de l'exécuter. Nous appelons cela @dfn{donner un retour}
(ndt. ``echoing'') car cela donne l'impression que vous tapez ces
lignes vous-même.

Quand une ligne débute avec @samp{@@}, le retour de cette ligne est supprimé.
Le signe @samp{@@} est effacé avant que la ligne soit passée au shell.
Normalement, vous utiliserez ceci pour les commandes dont l'effet est de
retourner quelque chose, comme une command @code{echo} pour indiquer
l'avancement dans le makefile:

@example
@@echo About to make distribution files
@end example

@cindex @code{-n}
@cindex @code{--just-print}
@cindex @code{--dry-run}
@cindex @code{--recon}
Quand @code{make} reçoit l'option @samp{-n} ou @samp{--just-print}, il
ne fait que donner les retours de la plupart des instructions, sans les
exécuter. @xref{Résumé des options, ,Résumé des options}.  Dans ce cas,
même les lignes d'instructions démarrant par @samp{@@} sont retournées.
Cette option est utile pour rechercher quelles sont les instructions que
@code{make} pense utile d'exécuter sans le faire réellement.

@cindex @code{-s}
@cindex @code{--silent}
@cindex @code{--quiet}
@findex .SILENT
L'option @samp{-s} ou @samp{--silent} de @code{make} empêche les retours
d'information, @samp{s} est pour toutes les instructions démarrant par
@samp{@@}.  Une règle dans un makefile pour l'instruction spéciale
@code{.SILENT} sans pré-requis a le même effet (@pxref{Les cibles
spéciales, ,Nom pré-inclus de cibles spéciales intégrées}).@refill

@node Exécution, Parallèle, Donner un retour, Les instructions
@section Exécuter une instruction
@cindex instruction, exécution
@cindex exécution, instructions
@vindex @code{SHELL} @r{(exécution des instructions)}

Quand c'est le moment d'exécuter les instructions pour mettre à jour une
cible, celles-ci sont exécutées en invoquant un sous-shell pour chaque ligne
d'instruction, saut si la cible spéciale @code{.ONESHELL} est effective à
ce moment (@pxref{Un shell unique, ,Utiliser une seul shell}) (En
pratique, @code{make} peut utiliser des racourcis qui n'impactent pas le
résultat.)

@cindex @code{cd} (commande shell)
@cindex variables shell, définir dans les instructions
@cindex instruction définissant des variables
@strong{Notez bien :} ceci implique que la définition d'une variable
shell ou l'invocation d'une commande comme @code{cd}, qui crée un
contexte local au moment de l'exécution, ces définitions n'affecteront
pas les lignes suivantes de l'instruction.@footnote{Sur MS-DOS, la
valeur du répertoire courant est @strong{globale}, donc la changer
@emph{affectera} les lignes d'instructions qui suivent.} Si vous voulez
utiliser @code{cd} en impactant les déclaractions suivantes, mettez
toutes ces déclarations sur une seule ligne d'instruction.  Dans ce cas
@code{make} invoquera un shell pour exécuter la ligne entière et le
shell exécutera ces déclarations les unes après les autres. Par
exemple@tie{}:

@example
foo@tie{}: bar/lose
        cd $(<D) && gobble $(<F) > ../$@@
@end example

@noindent
Ici nous utilisons l'operateur ET du shell (@code{&&}) de telle manière
que si la commande @code{cd} échoue, le script échouera sans essayer
d'invoquer la commande @code{gobble} sur le mauvais répertoire, ce qui
pourrait causer des problèmes (dans ce cas, elle tronquerait
problablement @file{../foo}, au moins).

@node Un shell unique, Choisir le Shell, Exécution, Exécution
@subsection Utiliser un seul shell
@cindex lignes d'instruction, un seul shell
@cindex @code{.ONESHELL}, utilisation
@findex .ONESHELL

Parfois vous préferiez que toutes les lignes d'une instruction soit passées
à un seul shell invoqué. Il y a généralement deux situations où ceci est
utile@tie{}: d'abord, ceci peut améliorer la performance de makefiles
dans lesquels les instructions en plusieurs lignes de commandes, en évitant
les processus supplémentaires.  Ensuite, vous pourriez vouloir que les
caractères de nouvelle ligne soit inclus dans vos commandes (par
exemple, vous pourriez utiliser un interpréteur très différent de votre
@code{SHELL}).  Si la cible spéciale @code{.ONESHELL} apparaît quelque
part de le makefile, alors @emph{toutes} les lignes des instructions pour
chaque cible seront traitées dans une seule invocation du shell.  Les
nouvelles lignes entre les lignes de l'instruction seront préservées. Par
exemple@tie{}:

@example
.ONESHELL:
foo@tie{}: bar/lose
        cd $(@@D)
        gobble $(@@F) > ../$@@
@end example

@noindent
ne fonctionnera pas comme attendu, même si les lignes sont sur
différentes lignes d'instructions.

Si @code{.ONESHELL} est fourni, alors le script ne vérifiera la présence
des préfixes spéciaux (@samp{@@}, @samp{-}, and @samp{+}) seulement pour
la première ligne de l'instruction.  Les lignes suivantes seront
incluses avec leurs caractères génériques dans la ligne d'instruction
quand le @code{SHELL} sera invoqué. Si vous voulez que votre instruction
avec l'un de ces caractères, vous devez vous arranger pour qu'ils ne
soint pas les premiers caractères de la première ligne, peut être en
ajoutant un commentaire ou quelque chose de similaire. Par exemple, ce
serait une erreur de syntaxe pour Perl, parceque le premier @samp{@@}
est enlevé par make:

@example
.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        @@f = qw(a b c);
        print "@@f\n";
@end example

@noindent
Cependnant, l'une ou l'autre de ces alternative fonctionnera
correctement@tie{}:


@example
.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        # Make sure "@@" is not the first character on the first line
        @@f = qw(a b c);
        print "@@f\n";
@end example

@noindent
or

@example
.ONESHELL:
SHELL = /usr/bin/perl
.SHELLFLAGS = -e
show :
        my @@f = qw(a b c);
        print "@@f\n";
@end example

L'@emph{enlèvement} des caractères génériques préfixés en ``interne''
des lignes des instructions avant que l'instruction soit exécutée est
une fonctionalité spéciale, si @code{SHELL} est déterminé comme un shell
ayant le style POSIX. Cette fonctionalité est prévue pour permettre aux
makefiles existants d'ajouter la cible spéciale @code{.ONESHELL} et de
toujours fonctionner correctement sans avoir à faire des modifications
plus importantes. Comme les caractères génériques de préfixe ne sont pas
légaux en début de ligne dans un script pour un shell POSIX, ce n'est
pas une perte de fonctionalité. Par exemple, ceci fonctionne comme
prévu@tie{}:

@example
.ONESHELL:
foo@tie{}: bar/lose
        @@cd $(@@D)
        @@gobble $(@@F) > ../$@@
@end example

Même avec cette fonctionalité spéciale, les makefiles avec
@code{.ONESHELL} se comportent cependant de manière assez différente
pour que cela se remarque.  Par exemple, si une ligne de instruction
échoue, ceci fait normalement échouer la règle et plus aucune ligne
d'instruction n'est exécutée. Avec @code{.ONESHELL} une défaillance de
n'importe quelle ligne d'instruction, exceptée la dernière, ne sera pas
détectée par @code{make}.  Vous pouvez modifier @code{.SHELLFLAGS} pour
ajouter l'option @code{-e} au shell, ce qui causera une défaillance du
shell sur toute défaillance n'importe où sur la ligne commande, mais
ceci pourrait par la même changer le comportement de votre instruction.
En définitive, vous pourriez avoir besoin de renforcer vos lignes de
instructions pour leur permettre de fonctionner avec @code{.ONESHELL}.

@node Choisir le Shell, , Un shell unique, Exécution
@subsection Choisir le Shell
@cindex shell, choisir
@cindex @code{SHELL}, valeur
@cindex @code{.SHELLFLAGS}, valeur

@vindex SHELL
@vindex .SHELLFLAGS
Le programme utilisé comme shell est lu dans la variable @code{SHELL}.
Si cette variable n'a pas été définie dans votre makefile, le programme
@file{/bin/sh} est utilisé comme shell.  Les arguments passés au shell
sont lus dans la variable @code{.SHELLFLAGS}.  La valeur par défaut de
@code{.SHELLFLAGS} est normalement @code{-c} ou @code{-ec} pour le mode
en conformité POSIX.

@cindex environnement, dans @code{SHELL}
À la différence de la plupart des variables, @code{SHELL} n'est jamais
définie par l'environnement.  Ceci parceque la variable d'environnement
@code{SHELL} est utilisée pour spécifier votre choix personnel de
programme shell pour un usage interactif.  Ce serait très mauvais pour
les choix personnels de ce type, d'affecter le fonctionnement des
makefiles.  @xref{Variables d'environnement, ,Variables depuis l'environnement}.

De plus, quand vous définissez @code{SHELL} dans votre makefile, cette
valeur n'est @emph{pas} exportée dans l'environnement pour être
transmise aux lignes d'instructions que @code{make} invoque.  À la place,
c'est la valeur héritée de l'environnement utilisateur, s'il y en a une,
qui est exportée. Vous pouvez changer ce comportement en exportant
explicitement @code{SHELL} (@pxref{La récursion et les variables,
,Communiquer des variables à des sous-@code{make}}) et en le forçant
ainsi à être passé à l'environnement pour les lignes d'instructions.

@vindex @code{MAKESHELL} @r{(alternative MS-DOS au @code{SHELL})}
Cependant, sur MS-DOS et MS-Windows, la valeur de @code{SHELL} dans
l'environnement @strong{est} utilisée, car sur ces systèmes, la plupart
des utilisateurs ne définissent pas cette variable et donc il est
probable qu'elle sera définie par by @code{make}.  Sur MS-DOS, si la
définition de @code{SHELL} ne convient pas à @code{make}, vous pouvez
spécifier la variable @code{MAKESHELL} au shell que @code{make} doit
utiliser@tie{}; si elle est définie, elle sera utilisée pour définir le
shell à la place de la valeur de @code{SHELL}.


@subsubheading Choisir un shell dans DOS ou Windows
@cindex shell, dans DOS ou Windows
@cindex DOS, choisir un shell
@cindex Windows, choisir un shell

Choisi un shell pour MS-DOS et MS-Windows est beaucoup plus complexe que
sur les autres systèmes d'exploitation.

@vindex COMSPEC
Sur MS-DOS, si la variable d'environnement @code{SHELL} n'est pas
définie, c'est la valeur de la variable @code{COMSPEC} (toujours
définie) qui est utilisée à la place.

@cindex @code{SHELL}, spécificités de MS-DOS
Les lignes définissant la variable @code{SHELL} dans les Makefiles sont
éxécutées différement sur MS-DOS. La zone mémoire du shell,
@file{command.com}, est ridiculeusement limitée ainsi que ses
fonctionalitésis et beaucoup d'utilisateurs de @code{make} tente
d'installer un shell de remplacement. C'est pourquoi @code{make} examine
sur MS-DOS la valeur de @code{SHELL} et change son comportement selon
qu'il désigne un shell dans le style Unix ou DOS. Ceci permet de
conserver un nombre raisonnable de fonctionalités, même si @code{SHELL}
désigne le programme @file{command.com}.

Si @code{SHELL} désigne un shell dans le style Unix, @code{make} sur MS-DOS
vérifie en plus si ce shell peut véritablement être trouvé@tie{}; si ce
n'est pas le cas, il ignore la ligne qui définit la variable
@code{SHELL}.  Sur MS-DOS, GNU @code{make} recherche le shell aux
endroits suivants@tie{}:

@enumerate
@item
À l'endroit précisément indiqué par @code{SHELL}. Par exemple, sur le
makefile spécifie @samp{SHELL = /bin/sh}, @code{make} recherchera
@file{/bin} sur le répertoire du disque courant.

@item
Dans le répertoire courant.

@item
Dans chaque répertoire indiqué par la variable @code{PATH} en respectant
l'ordre.

@end enumerate

Dans chaque répertoire qu'il examine, @code{make} recherchera d'abord le
fichier spécifiquement désigné (@file{sh} dans l'exemple ci-dessus).
S'il n'est pas trouvé, il cherchera aussi le fichier dans ce répertoire
en lui adjoignant les extensions connues pour identifier les fichiers
exécutables. Par exemple @file{.exe}, @file{.com},
@file{.bat}, @file{.btm}, @file{.sh}, et quelques autres.

Si l'une de ces tentative est remplie de succès, la valeur de
@code{SHELL} est définie comme la nom complet (comportant le chemin
d'accès) du programme shell qui a été trouvé. Cependant, si rien n'a été
trouvé, la valeur de @code{SHELL} n'est pas changée et la ligne qui le
définie est donc effectivement ignorée. De cette façon, @code{make} ne
supportera les fonctionalités d'un shell de style Unix que si un tel
shell a été effectivement installé sur le système sur lequel il
fonctionne.

Notez que cette recherche étendue d'un shell est limitée au cas où la
variable @code{SHELL} est définie par le Makefile@tie{}; s'il est défini
dans l'environnement ou sur la ligne de commande, vous devez entrer le
nom complet du shell (incluant son chemin d'accès), exactement comme
cela est fait sur Unix.

L'effet de ces exécutions spécifiques à DOS est qu'un Makefile qui
contient @samp{SHELL = /bin/sh} (comme beaucoup de makefile Unix le
font), ne fonctionnera pas sur un système MS-DOS non modifié,
typiquement si @file{sh.exe} n'est pas installé dans un répertoire sur
votre @code{PATH}.

@vindex SHELL
@vindex .SHELLFLAGS

@node Parallèle, Erreurs dans les instructions, Exécution, Les instructions
@section Exécution parallèle
@cindex instructions, exécution en parallèle
@cindex exécution en parallèle
@cindex exécution, en parallèle
@cindex insertion de tâches
@cindex job slots
@cindex @code{-j}
@cindex @code{--jobs}

GNU @code{make} sait comment exécuter plusieurs instructions en un
coup. Normalement @code{make} n'exécutera qu'une seule instruction à la
fois, attendant qu'elle soit finie pour exécuter la
prochaine. Cependant, les options @samp{-j} ou @samp{--jobs} demandent à
@code{make} d'exécuter plusieurs instructions simultanément. Vous pouvez
inhiber le parallélisme dans un makefile particulier avec la
pseudo-cible @code{.NOTPARALLEL} (@pxref{Les cibles
spéciales, Noms des cibles spéciales prédéfinies}).@refill

Sur MS-DOS, l'option @samp{-j} n'a aucun effet, car ce système ne
supporte pas des exécutions parallèles.

Si l'option @samp{-j} est suivie d'un entier, il désigne le nombre
d'instructions qui peuvent être exécutée en même temps@tie{}; ceci est
appelé le nombre de @dfn{créneaux de tâches} (ndt. @dfn{job slots}).
S'il n'y a rien qui ressemble à un entier après l'option @samp{-j},
c'est qu'aucune limite n'est fixée pour le nombre de créneaux
possible. Le nombre de créneaux par défaut est un, ce qui signifie une
exécution séquentielle slots is one, which means serial execution (une
chose à la fois).

La gestion des appels récurssifs de @code{make} peut soulever des
problèmes d'exécution parallèle. Pour plus d'information sur ceci, voir
@ref{Les options de récursions, ,Communiquer les options à un
sous-@code{make}}.

Si une instruction échoue (est tuée par un signal ou s'interrompt avec
un status non nul) et que les erreurs ne sont pas ignorées pour cette
instruction (@pxref{Erreurs dans les instructions, ,Erreurs dans les
instructions}), les lignes d'instructions suivantes pour recomplier la
cible ne seront pas exécutées. Si une instruction échoue et que l'option
@samp{-k} ou @samp{--keep-going} n'est pas donnée (@pxref{Résumé des
options, ,Résumé des options}), @code{make} interrompt l'exécution. Si
@code{make} s'interrompt pour n'importe quelle raison (incluant un
signal externe) avec des processus enfant en fonctionnement, il attendra
qu'ils aient fini avant de réellement s'interrompre.@refill

@cindex moyenne de charge
@cindex limiter les tâches sur la base de la charge
@cindex tâches, limitation basée sur la charge
@cindex @code{-l} (moyenne de charge)
@cindex @code{--max-load}
@cindex @code{--load-average}
Quand le système est lourdement chargé, vous voudrez probablement
exécuter moins de tâches que s'il ne l'est que légèrement. Vous pouvez
utiliser l'option @samp{-l} pour dire à @code{make} de limiter le nombre
de tâches à exécuter en même temps en se basant sur la moyenne de
charge. Les options @samp{-l} ou @samp{--max-load} sont suivies d'un
nombre à virgule flottante. Par exemple@tie{}:

@example
-l 2.5
@end example

@noindent
ne laissera pas @code{make} démarrer plus d'une tâche si la charge
moyenne est au dessus de 2.5.  L'option @samp{-l} sans nombre qui suit
enlève la limitation de charge précédante.@refill

Plus précisément, quand @code{make} va démarrer une tâche, et qu'il a
déjà au moins une tâche en exécution, il vérifie la charge moyenne
actuelle@tie{}; si elle n'est pas plus basses que la limite qui a été
donnée avec @samp{-l}, @code{make} attend que la charge moyenne descende
plus bas que cette limite ou jusqu'à ce que les autres tâches terminent.

Par défaut, il n'y a pas de limite de charge.


@node Sortie parallèle, Les entrées en parallèle, Parallèle, Parallèle
@subsection Sortie pendant un exécution en parallèle
@cindex sortie pendant une exécution parallèle
@cindex exécution parallèle, sortie

Quand on exécute plusieurs règles en parallèle, la sortie de chacune de
ces règles est renvoyées dès qu'elle est générée, ce qui resulte en un
entrelacement des messages venant des différentes règles, quelque fois
même sur la même ligne. Ceci peut rendre la lecture difficile.

@cindex @code{--output-sync}
@cindex @code{-O}
Pour l'éviter, vous pouvez utiliser l'option @samp{--output-sync}
(@samp{-O}). Cette option instruit @code{make} de sauvegarder la sortie
des commandes qu'il invoque et de n'imprimer que quand elles auront
toutes été terminées. De plus, s'il y a des appels récursifs multiples
de @code{make} s'exécutant en parallèle, ils communiqueront de telle
sorte que seul l'un d'entre eux génère une sortie à un instant donné.

Si l'option d'impression du répertoire de travail est activée (@pxref{-w
Option, ,L'option @samp{--print-directory}}), les messages
d'entrée/sorties seront retournés autour de chaque regroupement de
sorties. Si vous préférez ne pas voir ces messages, ajouter l'option
@samp{--no-print-directory} à @code{MAKEFLAGS}.

Il y a quatre niveaux de granularité quand on synchronise les sorties,
qui sont spécifiés en donnant un argument à l'option @samp{-Oline} ou
@samp{--output-sync=recurse}.

@table @code
@item none
C'est la choix par défaut: toute sortie est envoyée directement comme
elle est générée et aucune synchronisation n'est réalisée.

@item line
Les sorties de chaque lignes individuelles de la règle sont groupées et
renvoyées dès que cette ligne est complétée. Si une règle consiste en
plusieurs lignes, elles seront entrecroisées avec les lignes des autres
règles.

@item target
La sortie de la règle entière de chaque cible est groupée et renvoyée
une fois que le cible est terminée. C'est le comportement par défaut le
option @code{--output-sync} ou @code{-O}, quand elles sont données sans
argument.

@item recurse
Les sorties de chaque invocation récursive de @code{make} sont groupées
et renvoyées une fois que toutes les recursions sont finies.

@end table

Quelque soit le mode choisi, le temps de total de compilation reste le
même. La seule différence est comment la sortie apparaît.

Les modes @samp{target} et @samp{recurse} collationnent tous le deux la
règle complète d'une règle pour montrer la sortie de façon ininterrompue
quand la règle a été exécutée. La différence entre eux est le traitement
des règles qui contiennent des invocations récursives (@pxref{Récursion,
,Utilisation récursive de @code{make}}). Pour toutes les règles qui
n'ont pas de ligne faisant des appels récursifs, les deux modes,
@samp{target} et @samp{recurse}, se comportent de manière identique.

Si le mode @samp{recurse} est choisi, les règles qui contiennent des
invocations résursives de @code{make} sont traitées de la même façon que
pour les autres cibles@tie{}: la sortie d'une règle, incluant la sortie
des appels récursifs de @code{make}, est sauvgardée et renvoyée après
que la règle est été entièrement exécutée. Ceci assure que les sorties
des toutes la cibles bâties par une instance récursive de @code{make}
soient groupées ensemble, ce qui peut rendre la sortie plus facile à
comprendre. Cependant, ceci conduit aussi à une longue période de temps
pendant la compilation pendant laquelle rien n'est renvoyé à l'écran,
suivi d'un large éclatement de sortie. Si vous ne regardez pas l'écran
pendant la compilation, mais que vous préférez regarder le log après que
la compilation ait été effectuée, ceci peut être la meilleure option
pour vous.

Si vous regardez la sortie pendant la compilation, la long gap d'absence
de retour pendant la compilation peut être frustrant. La synchronisation
de la sortie de @samp{target} détecte quand @code{make} va invoquer des
appels récursifs, en utilisant des méthodes standards, et les sorties de
ces lignes ne seront pas synchronisées. Le @code{make} récursif fera la
synchronisation pour ses cibles et les sorties de chaque ligne seront
renvoyées immédiatement quand leur exécutions seront achevées.  Soyez
conscient que les sorties des lignes récursive des règles ne sont pas
synchronisées (par exemple, si une ligne renvoie un message avant
d'exécuter @code{make}, ce message ne sera pas synchronisé).

La mode @samp{line} peut être utile pour les interfaces qui examine la
sortie de @code{make} pour tracer quand l'exécution d'une règle
commence, puis se termine.

Quelques programmes invoqués par @code{make} peuvent se comporter
différement s'ils déterminent qu'ils sont en train d'écrire la sortie
sur un terminal au lieu d'un fichier (souvent décrit comme mode
``interactif'' vs. ``non-interactif''). Par exemple, beaucoup de
programmes qui donnent des sorties colorisées ne le feront pas s'ils
déterminent qu'ils ne sont pas en train d'écrire sur un terminal. Si
votre makefile invoque un programme comme ceux là, alors utiliser l'option
de synchronisation des sorties fera croire au programme, qu'il exécute en
mode ``non-interactif'' même si la sortie ira finalement vers un terminal.


@node Les entrées en parallèle, , Sortie parallèle, Parallèle
@subsection Les entrées pendant une exécution en parallèle
@cindex les entrées pendans les exécutions parallèles
@cindex exécution parallèle, entrée pendant
@cindex entrée standard

Deux processus ne peuvent pas prendre en même temps l'entrée à partie
d'un même périphérique en même temps. Pour s'assurer qu'une seule règle
cherchera à obtenir une entrée depuis un terminal à un moment donné,
@code{make} invalidera les flux d'entrée standard de toutes sauf une
règle.  Si une autre règle tente de lire depuis l'entrée standard, cela
causera créera normalement une erreur fatale (un signal @samp{Broken pipe}).
@cindex broken pipe

On ne peut pas prédire quelle règle aura un flux d'entrée validé (qui
viendra du terminal, ou où que ayez redirigez l'entrée standard de
@code{make}). La première règle exécutée l'obtiendra toujours la
première, et la permière recette démarrée après celle ci, l'aura ensuite
et ainsi de suite.

Nous changerons cet aspect du fonctionnement @code{make} si nous
trouvons une meilleure alternative. En même temps, vous ne devriez pas
vous reposer sur une recette qui utilise l'entrée sandard si vous
utilisez la fonctionalité d'exécution parallèle@tie{}; mais si vous
n'utilisez pas cette fonctionalité, alors l'entrée standard fonctionne
normalement pour toutes les règles.

@node Erreurs dans les instructions, Interruptions, Parallèle, Les instructions
@section Erreurs dans les instructions
@cindex erreurs (dans les instructions)
@cindex instructions, erreurs
@cindex status de sortie (erreurs)

Après chaque retours d'invocation du shell, @code{make} regarde le
status de sortie (ndt. ``exit status''). Si les commandes shell ont
été exécutées sans erreur (le status de sortie est zéro), la ligne
suivante de l'instruction est exécutée dans un nouveau shell@tie{}; quand
la dernière ligne est terminée, la règle est finie.

S'il y a une erreur (un status de sortie non nul), @code{make} abandonne
sur la règle en cours et peut être sur toutes les règles.

Parfois la défaillance de certaine ligne d'instruction particulière
n'indique pas un problème. Par exemple, vous pourriez utiliser la
commande @code{mkdir} pour être sûr que ce répertoire existe.  Si le
répertoire existe, @code{mkdir} retourne une erreur, mais vous voudrez
probablement que @code{make} continue son exécution sans en tenir
compte.

@cindex @code{-} (dans les instructions)
Pour ignorer ces erreurs sur les lignes d'instructions, écrivez un @samp{-}
au début du texte de la ligne (après le caractère de tabulation
initial).  Le @samp{-} est enlevé avant que la ligne ne soit passée au
shell pour exécution.

Par exemple,

@example
@group
clean:
        -rm -f *.o
@end group
@end example
@cindex @code{rm} (shell command)

@noindent
Ceci fera que @code{make} continuera même si @code{rm} n'est pas capable
d'enlever un fichier.

@cindex @code{-i}
@cindex @code{--ignore-errors}
@findex .IGNORE
Quand vous exécuter @code{make} avec l'option @samp{-i} ou
@samp{--ignore-errors}, les erreurs sont ignorées dans toutes les
instructions de toutes les règles.  Un règle dans le makefile pour la cible
spéciale @code{.IGNORE} a le même effet, s'il n'y a pas de
pré-requis. C'est moins flexible, mais parfois utile.

Quand les erreurs doivent être ignorées, parceque l'option @samp{-} ou @samp{-i}
ont été utilisées, @code{make} considère les retours d'erreur juste
comme des succès, excepté  qu'il retourne un message qui donne le code
du status avec lequel le shell est sorti et dit que l'erreur a été ignorée.

Quand une erreur apparaît et que @code{make} n'a pas été instruit de
l'ignorer, ceci implique que la cible actuelle ne peut pas être
recompilée correctement, et de même aucune autre qui peut en dépendre
directement ou indirectement. Aucune autre instruction ne sera exécutée pour
cette cible, car les pré-conditions n'ont pas été obtenues.

@cindex @code{-k}
@cindex @code{--keep-going}
Normalement @code{make} abandonne immédiatement dans ces circonstances,
retournant un status différent de zéro. Cependant avec l'option
@samp{-k} ou @samp{--keep-going} spécifiée, @code{make} continue
d'examiner les autres pré-requis de la cible en attente, les
reconstruisant si nécessaire, avant d'abandonner et de retourner les
status non nul. Par exemple, après une erreur dans le compilation d'un
fichier objet, @samp{make -k} continuera de compiler les autres fichiers
objets, même s'il sait déjà que l'édition de liens sera impossible.
@xref{Résumé des options, ,Résumé des options}.

Le comportement habituel présume que votre objectif est d'obtenir les
mises à jour des cibles spécifiée@tie{}; une fois que @code{make}
apprendra que c'est impossible, il le reportera immédiatement.  L'option
@samp{-k} dit que l'objectif réel est de tester autant faire se peut
tous les changements qui ont été faits dans le programme, peut être pour
trouver plusieurs problèmes indépendants les uns des autres, de telle
façon que vous puissiez les corriger tous avant de relancer un essai de
compilation.  C'est pourquoi la commande @code{compile} d'Emacs utilise
cette option @samp{-k} par défaut.
@cindex Emacs (@code{M-x compile})

@findex .DELETE_ON_ERROR
@cindex effacement de fichiers cibles
@cindex enlèvement de fichiers cibles
@cindex cible, effacement sur erreur
Normalement, quand une ligne d'instruction échoue, si elle a changé
complètement le fichier cible, ce fichier est corrompu and ne peut pas
être utilisé ---@tie{}ou au moins au minimum, il n'est pas complètement
mis à jour. Mais le tampon date du fichier dit que le fichier est
maintenant mis à jour, donc la prochaine exécution de @code{make} ne
cherchera pas à mettre à jour ce fichier.  La situation est la même
quand le shell a reçu un signal d'interruption@tie{};
@pxref{Interruptions}.  Donc généralement la bonne chose à faire est
d'effacer ce fichier cible si l'instruction échoue après avoir commencé
à le modifier. Le programme @code{make} le fera si
@code{.DELETE_ON_ERROR} apparaît comme une cible. C'est presque toujours
ce que vous voulez que @code{make} fasse, mais ce n'est pas la pratique
historique@tie{}; donc pour des raisons de compatibilité, vous devez le
demander explicitement.

@node Interruptions, Récursion, Erreurs dans les instructions, Les instructions
@section Arrêter ou interrompre @code{make}
@cindex interruption
@cindex signal
@cindex effacement des fichiers cibles
@cindex enlèvement des fichiers cibles
@cindex cible, effacement sur interruption
@cindex interrompre brutalement

Si @code{make} reçoit un signal fatal alors qu'il est en train de
s'exécuter, il peut effacer le fichier cible que l'instruction en cours
était supposée mettre à jour. Ceci est fait si la date de dernière
modification du fichier cible a changé depuis que @code{make} l'a
vérifié la dernière fois.

L'intention derrière cet effacement de la cible et de s'assurer qu'il
sera refait entièrement depuis le début la prochaine fois que
@code{make} sera exécuté.  Pourquoi@tie{}? Supposez que vous tapiez
@kbd{Ctrl-c} alors que le compilateur est en train de s'exécuter et
qu'il ait commencé à écrire un fichier objet @file{foo.o}. Le signal
@kbd{Ctrl-c} interrompt le compilateur, ce qui donne un fichier
incomplet dont la date de dernière modification est plus récente que le
fichier @file{foo.c}.  Mais @code{make} reçoit aussi ce signal
d'interruption @kbd{Ctrl-c} et efface ce fichier incomplet.  Si
@code{make} ne le faisait pas, la prochain invocation de @code{make}
penserait que @file{foo.o} ne requiert pas de mise à jour ---@tie{} ce
qui aurait pour résultat un message d'erreur étrange de l'éditeur de
liens quand il essayerait de lier un fichier objet dont la moitié est
manquante.

@findex .PRECIOUS
Vous pouvez empêcher l'effacement d'un fichier cible en le faisant
devenir un pré-requis de la cible spéciale @code{.PRECIOUS}. Avant de
recompiler une cible, @code{make} vérifie si elle est un pré-requis de
cette cible @code{.PRECIOUS} et alors décide si cette cible doit être
effacée ou non quand un signal d'interruption intervient. Les quelques
raisons où vous pourrez faire ceci sont quand la cible est mise à jour
de manière atomisée, ou quand elle n'existe que pour pour enregistrer
une date de modification (son contenu n'a donc pas d'importance), ou
encore quand elle doit tout le temps exister pour éviter d'autres types
d'ennuis.

Bien que @code{make} fait de son mieux pout nettoyer, il y a certaiens
situations dans lesquelles le nettoyage automatique est impossible.  Par
exemple, @code{make} peut être interrompu par un signal
irrattrapable. Ou l'un des programes qui fait des invocation, peut être
interrompu ou aller au crash, laissant derrière un fichier cible
corrompu, mais dont la date est la plus récente@tie{}: @code{make} ne
réalisera pas que la défaillance demande à la cible d'être nettoyée.  Ou
@code{make} lui même peut rencontrer une erreur interne et aller au
crash.

Pour ces raison, il est mieux d'écrire des @emph{instructions
conservatrices}, qui ne laisseront pas de cibles corrompue derrière
elles même si elles s'interrompent sur une erreur. Le plus courant pour ces
instructions est d'écrire des fichiers temporaires et de les copiers
ensuite sur la cible au lieu de ré-écrire le cible directement. Certains
compilateurs se comportent déjà ainsi, pour que vous n'ayez pas à écrire
des instructions conservatrices.

@node Récursion, Les séquences enregistrées, Interruptions, Les instructions
@section Usage récursif de @code{make}
@cindex récursion
@cindex sous-répertoires, récursion

L'utilisation récursive de @code{make} revient à utiliser @code{make}
comme une commande dans un makefile.  Cette technique est utile quand
vous voulez séparer les makefiles pour les différents sous-systèmes qui
composent un système plus important.  Par exemple, supposez que vous
aillez un sous-répertoire @file{subdir} qui possède son propre makefile,
et que vous vouliez que le makefile du répertoire englobant exécute le 
@code{make} du sous répertoire. Vous pouvez y arriver en écrivant ceci@tie{}:

@example
subsystem:
        cd subdir && $(MAKE)
@end example

@noindent
ou de manière équivalente, ceci (@pxref{Résumé des options, ,Résumé des options}):

@example
subsystem:
        $(MAKE) -C subdir
@end example
@cindex @code{-C}
@cindex @code{--directory}

Vous pouvez écrire des commandes @code{make} récursives en copiant juste
cet exemple, mais il y a beaucoup de choses à savoir sur comment cela
fonctionne et pourquoi, et comment le sous-@code{make} entre en relation
avec le niveau supérieur de @code{make}. Vous pourriez aussi trouver
utile de déclarer des cibles fictive (@samp{.PHONY}), qui utilisent des
commandes @code{make} récursives (pour plus de discussion sur quand ceci
peut être utile, voir @ref{Les cibles fictives}).

@vindex @code{CURDIR}
Pour votre convenance, quand GNU @code{make} démarre (et après qu'il ait
traité les options @code{-C} éventuelles), il définit la variable
@code{CURDIR} comme le chemin du répertoire de travail actuel.  Cette valeur
n'est jamais remodifiée ensuite par @code{make}@tie{}: notez en
particulier que si vous incluez des fichiers venant d'autres
répertoires, la valeur de @code{CURDIR} ne changera pas.  Cette valeur a la
même préséance qu'elle aurait si elle avait été définie dans le makefile
(par défaut, une variable d'environnement @code{CURDIR} ne remplacera
pas cette valeur).  Notez que définir cette variable n'a aucun impact
sur l'exécution de @code{make} (par exemple, cela ne change pas le repértoire de
travail de @code{make}).


@node La variable MAKE, La récursion et les variables, Récursion, Récursion
@subsection Comment fonctionne les variables @code{MAKE}
@vindex MAKE
@cindex récursion, et la variable @code{MAKE}

Les commandes @code{make} récursives devraient toujours utiliser la variable @code{MAKE},
non le nom de commande explicite @samp{make}, comme montré ici@tie{}:

@example
@group
subsystem:
        cd subdir && $(MAKE)
@end group
@end example

La valeur de cette variable est le nom du fichier avec lequel
@code{make} est invoqué. Si ce nom de fichier était @file{/bin/make},
alors l'instruction exécutée est @samp{cd subdir && /bin/make}.  Si vous
utilisez une version spéciale de @code{make} pour exécuter le makefile
de niveau supérieur, la même version spéciale sera exécutée pour des
invocations récursives.
@cindex @code{cd} (commande shell)

@cindex +, et les instructions
En tant que fonctionalité spéciale, utiliser la variable @code{MAKE}
dans une instruction d'une règle altère les effet des options de @samp{-t}
(@samp{--touch}), @samp{-n} (@samp{--just-print}), ou @samp{-q}
(@w{@samp{--question}}).  Utiliser la variable @code{MAKE} a le même
effet qu'utiliser le caractère @samp{+} au début d'une ligne de
instruction. @xref{À la place d'une exécution, ,À la place d'exécuter les
instructions}.  Cette fonctionalité spéciale n'est activée que si la
variable @code{MAKE} apparaît directement dans l'instruction@tie{}: cela ne
s'applique pas si la variable @code{MAKE} est obtenu par le
développement d'une autre variable.  Dans ce dernier cas, vous devez
utiliser le catactère @samp{+} pour obtenir ces effets spéciaux.@refill

Considérez la commande @samp{make -t} dans l'exemple ci-dessus.
(L'option @samp{-t} marque les cibles comme mises à jour sans exécuter
réellement aucune instruction@tie{}; voir @ref{À la place d'une exécution}.)
Suivant les définitions usuelle de @samp{-t}, une commande @samp{make
-t} dans l'exemple créérait un fichier nommé @file{subsystem} et rien
d'autre.  Ce que vous voulez réellement est d'exécuter @samp{@w{cd subdir &&}
@w{make -t}}; mais ceci requèrerait d'exécuter l'instruction, et @samp{-t}
dit de ne pas exécuter les instructions.@refill
@cindex @code{-t}, et la récursion
@cindex récursion, et @code{-t}
@cindex @code{--touch}, et la récursion

Cette fonctionalité spéciale lui fait faire ce que vous voulez@tie{}:
dès qu'une ligne d'instruction d'une règle contient la variable
@code{MAKE}, les options @samp{-t}, @samp{-n} et @samp{-q} ne
s'appliquent pas à cette ligne.  Les lignes d'instruction qui contiennent
@code{MAKE} sont exécutée normalement malgré la présence de ces options
qui empêchent la plupart des instructions d'être exécutées. Le mécanisme
usuel @code{MAKEFLAGS} transmet les options (ndt. ``flags'') aux
sous-@code{make} (@pxref{Les options de récursions, ,Communiquer les
options à un sous-@code{make}}), donc vos requètes pour modifier les
fichiers ou imprimer les instructions sont propagée aux sous-système.@refill


@node La récursion et les variables, Les options de récursions, La variable MAKE, Récursion
@subsection Communiquer les variables au sous-@code{make}
@cindex sous-@code{make}
@cindex environnement, et les récursions
@cindex exporter les variables
@cindex variables, environnement
@cindex variables, exporter
@cindex récursion, et environnement
@cindex récursion, et les variables

Les valeurs des variables du @code{make} de plus haut niveau peuvent
être transmises aux sous-@code{make} par l'environnement par des
requêtes explicites.  Ces variables sont définies dans les
sous-@code{make} par défaut, mais elles ne remplacent pas les variables
définies dans le makefile utilisées par le sous-@code{make}, sauf si vous
utilisez l'option @samp{-e} (@pxref{Résumé des options, ,Résumé des
options}).@refill

Pour transmettre, ou @dfn{exporter}, une variable, @code{make} ajoute la
variable et sa valeur à l'environnement pour exécuter chaque ligne des
l'instruction.  Le sous-@code{make}, à son tour, utilise l'environnement
pour initialiser sa table de valeur de variables.  @xref{Variables d'environnement,
,Variables d'environnement}.

Excepté par requête explicite, @code{make} exporte une variable
seulement si elle est définie initiallement dans l'environnement ou
définie en ligne de commande et si son nom n'est composé que de lettres,
nombres et caractère de soulignement. Quelque shells ne peuvent pas
gérer les noms de variable d'environnement qui sont composées de
caractères autres que les lettres, nombres et caractères de
soulignement.

@cindex SHELL, valeur exportée
La valeur de la variable @code{make} @code{SHELL} n'est pas exportée.
À la place, la valeur de la variable @code{SHELL} de l'environnement
invoquant est passée au sous-@code{make}.  Vous pouvez forcer
@code{make} à exporter sa velur pour @code{SHELL} en utilisant la
directive @code{export} décrite plus bas.  @xref{Choisir le Shell}.

La variable spéciale @code{MAKEFLAGS} est toujours exportée (sauf si
vous l'empêchez).  @code{MAKEFILES} est exportée si vous lui donnez
n'importe quelle définition.

@code{make} transmet automatiquement les valeurs de variables, qui ont
été définie sur la ligne de commande, en les plaçant dans la variable @code{MAKEFLAGS}.
@iftex
Voir la prochaine section.
@end iftex
@ifnottex
@xref{Les options de récursions}.
@end ifnottex

Les variables ne normallement @emph{pas} transmises si elles sont créées
par défaut par @code{make} (@pxref{Les variables implicites, ,Les
variables utilisées par les règles implicites}).  Le sous-@code{make}
les définira pour lui-même.@refill

@findex export
Si vous voulez exporter des variables spécifiques vers un
sous-@code{make}, utilisez la directive @code{export} comme ceci@tie{}:

@example
export @var{variable} @dots{}
@end example

@noindent
@findex unexport
Si vous voulez @emph{emêcher} une variable d'être exportée, utilisez la directive
@code{unexport}, comme ceci@tie{}:

@example
unexport @var{variable} @dots{}
@end example

@noindent
Dans ces deux formes, les arguments de @code{export} et de @code{unexport}
sont développés et peuvent être des variables ou des functions, qui se
développent en une liste de noms de variables à exporter ou ne pas exporter.

Par convenance, vous pouvez définir une variable et l'exporter en même
temps en écrivant@tie{}:

@example
export @var{variable} = value
@end example

@noindent
a le même résultat que@tie{}:

@example
@var{variable} = value
export @var{variable}
@end example

@noindent
et

@example
export @var{variable}@tie{}:= value
@end example

@noindent
a le même résultat que@tie{}:

@example
@var{variable}@tie{}:= value
export @var{variable}
@end example

de la même façon,

@example
export @var{variable} += value
@end example

@noindent
est juste comme@tie{}:

@example
@var{variable} += value
export @var{variable}
@end example

@noindent
@xref{Rajouter du texte à une variable, ,Ajouter du texte aux variables}.

Vous pouvez noter que les directives @code{export} et @code{unexport}
fonctionnent dans @code{make} de la même façon qu'elles fonctionnent
dans le shell, @code{sh}.

Si vous voulez que toutes les variables soient exportées par défaut,
vous pouvez utiliser @code{export} lui même@tie{}:

@example
export
@end example

@noindent
Ceci dit à @code{make} que les variables, qui ne sont pas explicitement
mentionée dans une directive @code{export} ou @code{unexport} doivent
être exportées.  Toute variable donnée dans une directive
@code{unexport} ne sera toujours @emph{pas} exportée.  Si vous utilisez 
@code{export} lui-même pour exporter des variables par defaut, les
variables dont les noms contiennent des caractères autres que les
caractères alphanumériques et de soulignement se seront pas exportées
sauf si mentionnées spécifiquement dans une directive @code{export}.@refill

@findex .EXPORT_ALL_VARIABLES
Le comportement suscité par une directive @code{export} était le
comportement par défaut dans les anciennes version de GNU @code{make}.
Si vos makefiles dépendent de ce comportement et que vous vouliez être
compatible avec les anciennes version de @code{make}, vous pouvez écrire
une règle pour la cible spéciale @code{.EXPORT_ALL_VARIABLES} à la place
d'utiliser la directive @code{export}.  Ceci sera ignoré par les anciens
@code{make}s alors que la directive @code{export} causerait une erreur
des syntaxe.@refill
@cindex compatibilité pour exporter

De la même façon, vous pouvez utiliser @code{unexport} pour dire à
@code{make} de ne @emph{pas} exporter de variables par défaut.  Comme
c'est le comportement par défaut, vous auriez besoin de faire ceci
seulement si @code{export} a été utilisé lui-même auparavant (peut être
dans un makefile inclu).  Vous ne pouvez @strong{pas} utiliser
@code{export} et @code{unexport} par eux-mêmes pour exporter des
variables pour certaines instructions et pas pour les autres.  La dernière
directive @code{export} ou @code{unexport} qui apparaît par elle-même
détermine la comportement pour l'exécution complète de
@code{make}.@refill

@vindex MAKELEVEL
@cindex récursion, niveau
Comme fonctionnalité spéciales, la variable @code{MAKELEVEL} est
modifiée quand elle est passée d'un niveau à l'autre.  La valeur de la
variable est une chaîne qui est le niveau de profondeur donné comme un
nombre décimal. Pour le niveau supérieur de @code{make}, la valeur est
@samp{0}@tie{}; @samp{1} pour un sous-@code{make}, @samp{2} pour un
sous-sous-@code{make}, et ainsi de suite.  L'incrémentation s'effectue
qauand @code{make} défini l'environnement d'une instruction.@refill

L'utilité principale de @code{MAKELEVEL} est de la tester dans directive
dconditionnelle (@pxref{Les parties conditionnelles, ,Parties conditionelle des Makefiles});
de cette façon, vous pouvez écrire un makefile qui se comporte d'une
certaine façon s'il est exécuté récursivement et d'une autre façon s'il
est exécuté directement par vous.@refill

@vindex MAKEFILES
Vous pouvez utiliser la variable @code{MAKEFILES} pour que toutes les
commandes du type sous-@code{make} puissent utiliser des makefiles
additionnels.  La valeur de @code{MAKEFILES} est une liste de noms de
fichiers séparés par des espaces blancs. Cette variable, si elle est
définie dans une niveau extérieur du makefile, est transférée à travers
l'environnement@tie{}; elle sert alors comme liste de makefiles
supplémentaires à faire lire aux sous-@code{make} avant qu'ils lisent
ceux qui sont habituels ou spécifiés. @xref{La Variable MAKEFILES, ,La
variable @code{MAKEFILES}}.@refill


@node Les options de récursions, -w Option, La récursion et les variables, Récursion
@subsection Communiquer des options à un sous-@code{make}
@cindex options, et récursion
@cindex récursion, et options

@vindex MAKEFLAGS
Les options comme @samp{-s} et @samp{-k} sont passées automatiquement au
sous-@code{make} à travers la variable @code{MAKEFLAGS}.  Cette variable
est définie automatiquement par @code{make} pour contenir les options
que @code{make} a reçu sous forme de lettre. Donc si vous écrivez @w{@samp{make -ks}} alors
@code{MAKEFLAGS} contient la valeur @samp{ks}.@refill

En conséquence, tout sous-@code{make} reçoit ses options de
@code{MAKEFLAGS} depuis l'environnement.  En réponse, il prend ces
options données et les exécute comme si elles avaient été données en
arguments.  @xref{Résumé des options, ,Résumé des options}.

@cindex définitions variables en ligne de commande, et récursion
@cindex variables, command line, et récursion
@cindex récursion, et définitions des variables en ligne de commande
De la même façon les variables définies sur la ligne de commande sont
passées au sous-@code{make} à travers @code{MAKEFLAGS}.  Les mots
contenus dans la valeur de @code{MAKEFLAGS} et qui contiennent @samp{=}
sont traités par @code{make} comme des définitions de variable, juste
comme ils l'auraient été s'ils été apparus en ligne de commande.  @xref{Forcer,
,Remplacer les variables}.

@cindex @code{-C}, et récursion
@cindex @code{-f}, et récursion
@cindex @code{-o}, et récursion
@cindex @code{-W}, et récursion
@cindex @code{--directory}, et récursion
@cindex @code{--file}, et récursion
@cindex @code{--old-file}, et récursion
@cindex @code{--assume-old}, et récursion
@cindex @code{--assume-new}, et récursion
@cindex @code{--new-file}, et récursion
@cindex récursion, et @code{-C}
@cindex récursion, et @code{-f}
@cindex récursion, et @code{-o}
@cindex récursion, et @code{-W}
Les options @samp{-C}, @samp{-f}, @samp{-o}, et @samp{-W} ne sont pas
mises dans @code{MAKEFLAGS}@tie{}; ces options ne sont pas transmises
aux sous processus.@refill

@cindex @code{-j}, et récursion
@cindex @code{--jobs}, et récursion
@cindex récursion, et @code{-j}
@cindex job slots, et récursion
L'option @samp{-j} est un cas particulier (@pxref{Parallèle, ,Exécution
parallèle}). Si vous la régler sur une valeur numérique @samp{N} et que
votre système d'exploitation le supporte (la plupart des systèmes UNIX
le supporte@tie{}; et les autres typiquement non), la parent de
@code{make} et tous ses sous-@code{make}s communiqueront pour s'assurer
qu'il n'y ait réellement que @samp{N} tâches exécutées en même temps et
pour eux tous ensembles. Notez que toute tâche marquée comme récursive
(@pxref{À la place d'une exécution, ,À la place d'exécuter des intructions})
ne compte pas pour les tâches totales (autrement, nous nous pourriez
avoir @samp{N} sous-@code{make}s s'exécutant et n'avoir aucune place
laissée disponible pour faire le travail réel@tie{}!)

Si votre système d'exploitation ne supporte pas les communications vues
ci-dessus, alors aucune option @samp{-j} n'est ajoutée à
@code{MAKEFLAGS}, de telle façon que les sous-@code{make}s s'exécutent
en mode non-parallèle.  Si l'option @w{@samp{-j}} est passée au
sous-@code{make}s, vous pouvez avoir beaucoup plus de tâches qui
s'exécutent en parallèle que ce que vous aviez demandé.  Si vous donnez
une valeur non numérique à @samp{-j}, ceci signifie exécuter autant de
tâche en parallèle que possible, et c'est transmis au sous processus car
additioner des infinités revient toujours à un seul infini.@refill

Si vous ne voulez pas passer d'autres options plus bas, vous devez
changer la valeur de of @code{MAKEFLAGS} comme ceci@tie{}:

@example
subsystem:
        cd subdir && $(MAKE) MAKEFLAGS=
@end example

@vindex MAKEOVERRIDES
Les définitions des variables données en ligne de commande n'apparaisse dans
la variable @code{MAKEOVERRIDES}, et la variable @code{MAKEFLAGS}
contient une référence à cette variable.  Si vous voulez passer
les options aux sous-processus comme cela est fait normalement, mais que
vous ne vouliez pas passer les définitions des variables données en
ligne de commande, vous pouvez vider le contenu de la variable
@code{MAKEOVERRIDES} comme ceci@tie{}:

@example
MAKEOVERRIDES =
@end example

@noindent
@cindex Arg list too long
@cindex E2BIG
Il n'est normalement pas utile de le faire. Cependant, certains système
ont une petite limite fixée pour la taille de l'environnement et mettre
trop d'information dans la valeur de @code{MAKEFLAGS} peut la dépasser.
Si vous voyez le message d'erreur @{Arg list too long@}, il se pourrait
que cela soit le problème.
@findex .POSIX
@cindex POSIX
(Pour la conformité stricte à POSIX.2, changer @code{MAKEOVERRIDES}
n'impacte pas @code{MAKEFLAGS} si la cible spéciale @samp{.POSIX}
apparaît dans le makefile.  Mais vous n'aurez sûrement pas besoin de faire
attention à ceci.)

@vindex MFLAGS
Une variable similaire @code{MFLAGS} existe aussi pour des raisons
historiques de compatibilité.  Elle a la même valeur que
@code{MAKEFLAGS} excepté qu'elle ne contient pas les définitions de
variables faites en ligne de commande et qu'elle démarre toujours par un
signe d'hyphénation, sauf si elle est vide (@code{MAKEFLAGS} démarre par
un signe d'hyphénation seulement si elle démarre par une option qui
n'est pas un version à une seule lettre, comme
@samp{--warn-undefined-variables}).  @code{MFLAGS} était
traditionnellement utilisé explicitement dans les commandes récursives
de @code{make} comme ceci@tie{}:

@example
subsystem:
        cd subdir && $(MAKE) $(MFLAGS)
@end example

@noindent
mais maintenant @code{MAKEFLAGS} rend son usage redondant. Si vous
voulez que vos makefiles restent compatible avec les vieux programmes
@code{make}, utlisez cette technique@tie{}; elle fonctionnera toujours
bien sur les versions modernes de @code{make}..

@cindex définir les options depuis environnement
@cindex options, définir depuis l'environnement
@cindex définir les options des makefiles
@cindex options, définir dans les makefiles
La variable @code{MAKEFLAGS} peut aussi être utile si vous voulez avoir
certaines options, comme @samp{-k} (@pxref{Résumé des options, ,Résumé des options}),
définies à chaques vous que vous exécutez @code{make}.  Vous mettez
simplement une valeur pour @code{MAKEFLAGS} dans votre environnement.
Vous pouvez aussi définir @code{MAKEFLAGS} dans un makefile, pour
définir des options supplémentaires, qui devraient aussi être activée
pour ce makefile.  (Notez que vous ne pouvez pas utiliser @code{MFLAGS}
de cette façon.  Cette variable n'est définie pour des raisons de
compatibilité@tie{}; @code{make} n'interpète pas une valeur définie de
cette façon.)

Quand @code{make} interprète la valeur de @code{MAKEFLAGS} (depuis
l'environnement ou depuis un makefile), il ajoute d'abord un signe
d'hyophénation si la valeur n'en contient pas déjà un. Ensuite, il
découpe la valeur en mots séparés par des blancs et analyse ces mots
comme s'ils étaient des options données en ligne de commande (excepté
que @samp{-C}, @samp{-f}, @samp{-h}, @samp{-o},
@samp{-W}, et leur version longues sont ignorées@tie{}; et qu'il n'y a
pas d'erreur générée pour les options invalides).

Si vous mettez @code{MAKEFLAGS} dans votre environnement, vous devez
être sûr de ne pas inclure une option qui pourrait affecter complètement
l'action de @code{make} et rendrait l'objectif des makefiles indéterminé
et de @code{make} lui-même. Par exemple, les options @samp{-t},
@samp{-n} et @samp{-q}, si elles sont mises dans l'une de ces variables,
pourraient avoir des conséquences désastreuses et auraient des effets
très étonnant sur sûrement ennuyeux.@refill

Si vous voulez exécuter d'autres implémentations de @code{make} en plus
de GNU @code{make} et donc que vous ne voulez pas ajouter les options
qui soient spécifiques à GNU @code{make} à la variable @code{MAKEFLAGS},
vous pouvez les ajouter à la place à la variable
@code{GNUMAKEFLAGS}. Cette variable est analysée juste avant
@code{MAKEFLAGS}, de la même façon que pour @code{MAKEFLAGS}. Quand
@code{make} construit @code{MAKEFLAGS} pour passer à un @code{make}
récursif, il incluera toutes les options, même celles venant de
@code{GNUMAKEFLAGS}.  Finalement, après avoir analyser @code{GNUMAKEFLAGS} GNU
@code{make} définit cette variable comme une chaîne vide pour éviter la
duplication des options pendant les récursions.

Il vaut mieux n'utiliser @code{GNUMAKEFLAGS} que pour les options, qui
ne changeront pas matériellement le comportement de vos makefiles.  Si
vos makefiles ont de toutes façons besoin de GNU make, alors utilisez
simplement @code{MAKEFLAGS}.  Les options telles que @samp{--no-print-directory}
ou @samp{--output-sync} sont des options appropriées pour @code{GNUMAKEFLAGS}.

@node -w Option, , Les options de récursions, Récursion
@subsection l'option @samp{--print-directory}
@cindex répértoires, les imprimer
@cindex imprimer les répertoires directories
@cindex récursion, et imprimer les répertoires

Si vous utilisez différents niveaux d'invocations récursifs de
@code{make}, l'option @samp{-w} ou @w{@samp{--print-directory}} peut
rendre le retour d'information beaucoup plus simple à comprendre en
montrant chaque répertoire quand @code{make} commence à travailler
dedans et quand il en a fini. Par exemple, si @samp{make -w} est exécuté
dans le répertoire @file{/u/gnu/make}, @code{make} renverra une ligne
de la forme@tie{}:@refill

@example
make: Entering directory `/u/gnu/make'.
@end example

@noindent
Avant de faire quelque chose d'autre, et une ligne de la forme@tie{}:

@example
make: Leaving directory `/u/gnu/make'.
@end example

@noindent
Quand l'exécution est terminée dans ce répertoire.

@cindex @code{-C}, et @code{-w}
@cindex @code{--directory}, and @code{--print-directory}
@cindex récursion, et @code{-w}
@cindex @code{-w}, et @code{-C}
@cindex @code{-w}, et recursion
@cindex @code{--print-directory}, et @code{--directory}
@cindex @code{--print-directory}, et récursion
@cindex @code{--no-print-directory}
@cindex @code{--print-directory}, désactiver
@cindex @code{-w}, désactiver
Normalement, vous n'avez pas besoin de spécifier cette option, car
@samp{make} le fait pour vous@tie{}: @samp{-w} est activée
automatiquement quand vous utilisez l'option @samp{-C}, et dans ses
sous-@code{make}s.  @code{make} activera automatiquement l'option  @samp{-w}
si vous utilisez l'option @samp{-s}, qui dit d'être silencieux (ndt. ne
pas renvoyer de retour) ou si vous utilisez l'option
@samp{--no-print-directory} pour la désactiver explicitement.

@node Les séquences enregistrées, Instructions vides, Récursion, Les instructions
@section Définir des séquences à enregistrer
@cindex séquences de commandes enregistrées
@cindex séquence de commandes, enregistrées
@cindex sequences de commandes
@cindex commandes, séquences

Quand une même séquence de commandes est utile pour construire plusieurs
cibles différentes, vous pouvez les définir comme une séquence mise en
conserve avec la directive @code{define}, et vous vous référerez à cette
séquence mise en conserve depuis les instructions de ces cibles.  Les
séquences ``en conserve'' sont en fait une variable, dont le nom ne doit
pas rentrer en conflit avec les autres noms de variables.

Ici un exemple pour définir une instruction ``en conserve''@tie{}:

@example
define run-yacc =
yacc $(firstword $^)
mv y.tab.c $@@
endef
@end example
@cindex @code{yacc}

@noindent
Ici @code{run-yacc} est le nom de la variable qui est définie;
@code{endef} marque la fin de la définition@tie{}; les lignes entre sont
les commandes. La directive @code{define} ne développe pas les référencs
de variable et les appels de fonction dans une séquence mise en
conserve@tie{}; les caractères @samp{$}, parenthèses, noms de variables,
et ainsi de suite, tout devient une part de la valeur de la variable que
vos être en train de définir.  @xref{Variables sur plusieurs lignes, ,Définir des
variables sur plusieurs lignes}, pour une explication plus complète sur
@code{define}.

La première commande de cet exemple exécute Yacc sur le premier
pré-requis de n'importe quelle règle qui utilise la séquence mise en
conserve.  Le fichier de sortie de Yacc est toujours appelé @file{y.tab.c}.
La seconde commande déplace la sortie sur le nom de fichier de la cible
de la règle.

Pour utiliser des séquences mises en conserve, substituez la variable
dans l'instruction d'une règle.  Vous pouvez la substituer comme tout
autre variable (@pxref{Référencer une variable, ,Les bases des références de variables}).
Comme les variables définies par @code{define} sont développées
récursivement, toutes les références de variable que vous écrivez à
l'intérieur du @code{define} sont maintenant développées. Par exemple@tie{}:

@example
foo.c : foo.y
        $(run-yacc)
@end example

@noindent
@samp{foo.y} sera substitué pour la variable @samp{$^} quand elle
interviendra dans la valeur de @code{run-yacc} et @samp{foo.c} pour
@samp{$@@}.@refill

Ceci est un exemple réaliste, mais cet exemple particulier n'est pas
nécessaire en pratique, car @code{make} a une règle implicite pour
trouver ces commandes en se basant sur les noms de fichiers
impliqués. (@pxref{Les règles implicites, ,Utiliser les règles implicites}).

@cindex @@, and @code{define}
@cindex -, and @code{define}
@cindex +, and @code{define}
Dans l'exécution d'une instruciton, chaque ligne ligne d'une séquence
mise en conserve est traitée juste comme si cette ligne apparaissait en
tant que tel dans la règle, précédée par une tabulation. En particulier,
@code{make} invoque un sous-shell pour chacune de ces lignes.  Vous
pouvez utiliser les caractères spéciaux de préfixes qui affectent la
ligne de commande (@samp{@@}, @samp{-} et @samp{+}) sur chaque ligne
d'une séquence en conserve.  @xref{Les instructions, ,Écrire les
instructions dans les règles}.  Par exemple, utilisez cette séquence
mise en conserve@tie{}:

@example
define frobnicate =
@@echo "frobnicating target $@@"
frob-step-1 $< -o $@@-step-1
frob-step-2 $@@-step-1 -o $@@
endef
@end example

@noindent
@code{make} ne retournera pas la première ligne, la commande
@code{echo}.  Mais il @emph{retournera} les deux lignes d'instructions
qui suivent.

D'un autre côté, les caractères de préfixe sur les lignes d'instruction
qui se réfèrent à une séquence en conserve s'appliquent à toutes les
lignes dans la séquence. Donc la règle@tie{}:

@example
frob.out: frob.in
        @@$(frobnicate)
@end example

@noindent
ne renverra @emph{aucune} ligne d'instruction.  (@xref{Donner un retour,
,Donner un retour d'instruction}, pour une explication complète de @samp{@@}.)

@node Instructions vides, , Les séquences enregistrées, Les instructions
@section Utiliser les instructions vides
@cindex instructions vides
@cindex instructions, vides

Il est parfois utile de définir des instructions qui ne font rien. Ceci est
faire simplement en donnant une instruction qui consiste en rien d'autre
qu'un espace blanc. Par exemple@tie{}:

@example
target: ;
@end example

@noindent
définit une instruction vide pour @file{target}.  vous pourriez aussi
utiliser une ligne démarrant avec le caractère de préfixe des instructions
pour définir une instruction vide, mais ceci peut conduire à des erreurs car une
telle ligne paraîtrait vide.

@findex .DEFAULT@r{, et les instructions vides}
Vous pourriez vous demander pourquoi définir une instruction qui ne fait
rien. L'une des raisons de son utilité est d'empêcher une cible de recevoir des
instructions implicites (depuis les règles implicites ou celle de la cible
spéciale @code{.DEFAULT}; @pxref{Les règles implicites} et
@pxref{Dernier ressort, ,Définir les règles de dernier ressort par
défaut}).@refill

Les instructions vides peuvent aussi être utilisées pour éviter les erreurs
pour les cibles qui seraient créées par effet de bord d'une autre
instruction@tie{}: si la cible n'existe pas, l'instruction vide assure que
@code{make} ne prétendra pas qu'il ne sait pas compiler la cible et
@code{make} assumera que la cible n'est plus à jour.

Vous pourriez être tenté de définir des instructions vides pour les cibles
qui ne sont pas réellement des fichiers, mais qui n'existent que pour
que leur pré-requis soient reconstruits. Cependant, ce n'est pas la
meilleure façon de le faire, car les pré-requis pourraient ne pas être
reconstruits correctement si le fichier cible n'existe pas dans les faits.
@xref{Les cibles fictives, ,Les cibles fictives}, pour une meilleurs façon de
faire ceci.

@node Utiliser les variables, Les parties conditionnelles, Les instructions, Top
@chapter Comment utiliser les variables
@cindex variable
@cindex value
@cindex le développement des variables récursives
@cindex le développement de variables simples

Une @dfn{variable} est un nom défini dans un makefile pour représenter
une chaîne de texte, appelée la @dfn{valeur} de cette variable.  Ces
valeurs sont substituées par une requète explicite dans les cibles,
pré-requis, instructions, et les autres parties du makefile.  (Dans
d'autres versions de @code{make}, les variables sont appelées
@dfn{macros}.)
@cindex macro

Les variables et les fonctions sont développées quand elles sont lues
dans toutes les parties d'un makefile, excepté dans les instructions,
dans la partie à main droite des définitions de variables utilisant
@samp{=}, et dans les corps des définitions de variable utilisant la
directive @code{define}.@refill

Les variables peuvent représenter des listes de noms de fichiers, des
options à passer aux compilateurs, des programmes à exécuter, des
répertoires dans lesquels rechercher les fichiers source, des
répertoires où écrire ou tout ce que vous pouvez imaginer.

Un nom de variable peut être toute séquence de caractères ne contenant
pas @samp{:}, @samp{#}, @samp{=}, ou d'espace blanc. Néanmoins les
variables contenant autre chose que les lettres, le nombre et les
caractères de soulignement devraient être considérées attentivement, car
dans certains shell, elles ne peuvent pas être transmises par
l'environnement à un sous-@code{make} (@pxref{La récursion et les
variables, ,Transmettre des variables à un sous-@code{make}}).  Les noms
de variable commençant pas @samp{.} et avec avec une lettre majuscule
pourraient avoir une signification particulière dans les futures
versions de @code{make}.

Le noms de variables sont sensibles à la casse. Les noms @samp{foo},
@samp{FOO}, et @samp{Foo} se réfèrent tous à des variables différentes.

Il est traditionel d'utiliser les lettres majuscules pour les noms de
variable, mais nous recommendons d'utiliser les lettres minuscules pour
le noms de variables à usage interne dans le makefile, et de réserver
les lettres majuscules pour les paramètres contrôlant les règles
implicites, ou les paramètres que l'utilisateur doit remplacer par
des options de commandes (@pxref{Forcer, ,Remplacer les variables}).

Quelques variables ont des noms qui sont des simples caractères de
ponctuation ou juste quelques caractères. Ce sont les @dfn{variables
automatiques} qui ont une utilisation particulière.
@xref{Les variables automatiques}.

@node Référencer une variable, Deux catégories de variables, Utiliser les variables, Utiliser les variables
@section Référencer les variables
@cindex variables, comment référencer
@cindex référencer des variables
@cindex @code{$}, dans une référence de variable
@cindex le signe dollar (@code{$}), dans une référence de variable

Pour substituer une valeur à une variable, écrivez un signe dollar suivi
par le nom de la variable entre parenthèses ou accolades@tie{}:
@samp{$(foo)} ou @samp{$@{foo@}} sont des références valables à la variable
@code{foo}. Cette signification spéciale de @samp{$} explique pourquoi
vous devez écrire @samp{$$} pour avoir l'effet d'un signe dollar seul
dans un nom de fichier ou dans une instruction.

Les références de variable peuvent être utilisées dans tous les
contextes@tie{}: les cibles, les pré-requis, les instructions, la
plupart des directives et les nouvelles valeurs de variables. Voici un
exemple de cas courant, dans lequel une variable contient les noms de
tous les fichiers objet d'programme@tie{}:

@example
@group
objects = program.o foo.o utils.o
program : $(objects)
        cc -o program $(objects)

$(objects) : defs.h
@end group
@end example

Les références de variables fonctionnent par stricte substitution de
texte.  C'est pourquoi, la règle

@example
@group
foo = c
prog.o : prog.$(foo)
        $(foo)$(foo) -$(foo) prog.$(foo)
@end group
@end example

@noindent
peut être utilisées pour compiler un programme C qui sera nommé
@file{prog.c}.  Commes les espaces avant la valeur de variable sont
ignorés dans les assignements de variables, la valeur de @code{foo} est
précisément @samp{c}.  (Dans la réalité, n'écrivez pas vos makefiles de
cette façon@tie{}!)

Un signe dollar suivi d'un caracère autre que le signe dollar, une
parenthèse ou une accolade ouvrante, traite ce caractère seul comme un
nom de variable. Vous pouvez donc référencer la variable @code{x} par
@samp{$x}.  Cependant, cette pratique peut entraîner des confusions (par
exemple, @samp{$foo} faisant référence à la variable @code{f} suivie de
la chaîne @code{oo}) et nous recommandons donc d'utiliser des
parenthèses ou des accolades autour de toutes les variables, même les
variables d'une seule lettre, à moins que les omettre ne donne une
amélioration significative à la lisibilité.  Des endroits où la
lisibilité est souvent améliorée sont les variables automatiques
(@pxref{Les variables automatiques}).

@node Deux catégories de variables, Fonctionalité avancée des variables, Référencer une variable, Utiliser les variables
@section Les deux catégories de variables
@cindex catégories de variables
@cindex développement recursif de variable
@cindex variables, catégories
@cindex variables développées récursivement
@cindex variables, développées récursivement

Il y a deux façons pour une variable d'avoir une valeur dans GNU
@code{make}@tie{}; nous les appelons les deux @dfn{catégories} de
variables (ndt. ``two flavors'' dans la version Anglaise).  Les deux
catégories se distinguent par la façon dont elles sont définies et par
ce qu'elles font quand elles sont développées.

@cindex =
La première catégorie de variables sont les variables @dfn{développées
récursivement}.  Les variables de cette sorte sont définies par des
lignes utilisant @samp{=} (@pxref{Définir une variable, ,Définir des variables}) ou
par la directive @code{define} (@pxref{Variables sur plusieurs lignes, ,Définir des
variables sur plusieurs lignes}).  La valeur que vous spécifiez est
comprise tel que (n.d.t ``verbatim''); si elle contient d'autres
références de variables, ces références sont développées au moment de la
subtitution de ces variables (qui s'effectue pendant le développement
d'une autre chaîne). Ceci est alors appelé un @dfn{développement
recursif}.@refill

Par exemple,

@example
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)
@end example

@noindent
retournera @samp{Huh?}: @samp{$(foo)} est développé en @samp{$(bar)},
qui est développé en @samp{$(ugh)}, qui finallement se développe en
@samp{Huh?}.@refill

Cette catégorie de variable est la seule supportée par la plupart des
autres versions de @code{make}. Elle a des avantages et des
désavantages. Un avantage (comme dirait la plupart) est que@tie{}:

@example
CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
@end example

@noindent
fera ce qui prévu@tie{}: quand @samp{CFLAGS} est développé dans une
instruction, il se développe en @samp{-Ifoo -Ibar -O}.  Un désavantage
majeur est que vous ne pouvez pas ajouter quelque chose à la fin d'une
variable, comme dans

@example
CFLAGS = $(CFLAGS) -O
@end example

@noindent
car cela proquerait une boucle infinie sur le développement de cette
variable.  (En fait, @code{make} détecte cette boucle infinie et signale
l'erreur.)
@cindex boucles dans le développement des variables
@cindex variables, boucles pendant le développement

Un autre désavantage est que toute fonction (@pxref{Les fonctions,
,Fonctions de transformation de texte}) référencée dans la définition
sera exécutée à chaque fois que la variable est développée. Ceci
ralentit @code{make}@tie{}; pire, cela peut faire que les fonctions
@code{wildcard} et @code{shell} donnent des résultats imprédictibles,
car vous ne pouvez pas contrôler facilement quand elles sont appelées ou
même combien de fois.

Pour éviter les problèmes et inconvénients liés aux développements
récursifs de variables, il existe une autre catégorie de
variables@tie{}: les variables développées de manière unique
(ndt. ``simply expanded variable'').

@cindex variables développées de manière unique
@cindex variables, développées de manière unique
@cindex :=
@cindex ::=
@dfn{Les variables développées de manière unique} sont définies par des
lignes utilisant @samp{:=} ou @samp{::=} (@pxref{Définir une variable, ,Définir des
variables}). Les deux formes sont équivalentes pour GNU
@code{make}@tie{}; cependant seule la forme @samp{::=} est décrite dans
le standard POSIX (le support de @samp{::=} a été ajouté dans le
standard POSIX en 2012, donc les versions plus anciennes de @code{make}
n'accepteront pas cette forme non plus).

La valeur d'une variable développée de manière unique est analysée une
fois pour toute, en développant toute les références à d'autres
variables ou toutes les fonctions utilisées dans la définition de la
variable.  La valeur effective d'une variable développée de manière
unique est le résultat du développement du texte que vous écrivez. Il ne
contient plus de références à d'autres variables@tie{}; il contient
leurs valeurs @emph{au moment où cette variable a été définie}.  Donc,

@example
x := foo
y := $(x) bar
x := later
@end example

@noindent
est équivalent à

@example
y := foo bar
x := later
@end example

Quand une variable développée de manière unique est référencée, sa
valeur est subtituée tel que..

Voici un modèle un peu plus compliqué, illustrant l'utilisation de 
@samp{:=} en conjonction avec la fonction @code{shell}.  (@xref{La
fonction shell, , La fonction @code{shell}}.)  Cet exemple montre aussi
l'utilisation de la variable @code{MAKELEVEL}, qui est modifiée quand
elle est transmise de niveau en niveau.  (@xref{La récursion et les variables, ,
Transmettre les variables à un sous-@code{make}}, pour plus
d'information sur @code{MAKELEVEL}.)

@vindex MAKELEVEL
@vindex MAKE
@example
@group
ifeq (0,$@{MAKELEVEL@})
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := $@{MAKE@} host-type=$@{host-type@} whoami=$@{whoami@}
endif
@end group
@end example

@noindent
Un avantage de cette utilisation de @samp{:=} est qu'une instruction
typique de ``descente dans les sous-répertoires'' ressemble alors à
ceci@tie{}:

@example
@group
$@{subdirs@}:
        $@{MAKE@} -C $@@ all
@end group
@end example

Les variables développées de manière unique rendent généralement la
programmation évoluée de makefile plus prédictible, car elles
fonctionnent comme les variables qu'on trouve dans la plupart des
langages de programmation.  Elles permettent de redéfinir une variable
chaîne en utilisant sa propre valeur (ou sa valeur transformée d'une
façon ou d'une autre par un développement de fonctions) et d'utiliser le
développement de fonctions de manière beaucoup plus efficace
(@pxref{Les fonctions, ,Fonctions pour transformer de texte}).

@cindex espaces, dans la valeur de variable
@cindex espace blanc,  dans la valeur de variable
@cindex variables, espaces dans les valeurs
Vous pouvez aussi les utiliser pour introduire de manières contrôlée des
espaces blancs en début de chaîne dans les valeurs de variables. Les
caractères d'expace blancs en début de chaîne sont enlevés de votre
entrée avant la substitution des références de variables et des appels
de fonctions@tie{}; ceci veut dire que vous pouvez inclure des espaces
blancs en début de chaîne dans la valeur d'une variable en les
protégeant des références de variables comme ceci@tie{}:

@example
nullstring :=
space := $(nullstring) # end of the line
@end example

@noindent
Ici la la valeur de la variable @code{space} est précisement un espace.
Le commentaire @w{@samp{# end of the line}} a été inclus ici pour plus de
clarté. Comme les espaces blancs qui traînent en fin de chaîne ne sont
@emph{pas} enlevés de la valeur de la variable, mettre juste un espace à
la fin de la ligne aurait le même effet (mais ce serait plutôt difficile
à lire).  Si vous mettez des espaces blancs à la fin de la valeur d'une
variable, c'est une bonne idée de mettre ainsi un commentaire à la fin
de la ligne pour montrer clairement votre intention. Inversement, si
vous ne voulez @emph{pas} d'espace blanc à la fin de la valeur de votre
variable, vous devez vous souvenir de ne pas ajouter un commentaire
éventuel à la fin de la ligne, après quelques espaces blancs, comme
ceci@tie{}:

@example
dir := /foo/bar    # directory to put the frobs in
@end example

@noindent
Ici, la valeur de la variable @code{dir} est @w{@samp{/foo/bar }} (avec
quatre espaces à la fin), ce qui n'était probablement pas l'intention.
(Par exemple, imaginez comment @w{@samp{$(dir)/file}} utiliserait cette
définition@tie{}!)

@cindex assignment conditionel de variable 
@cindex variables, assignment conditionel
@cindex ?=
Il existe un autre opérateur d'assignement pour les variables,
@samp{?=}.  Il est appelé l'opérateur d'assignement conditionnel des
variables, car il n'a d'effet que si la variable n'était pas déjà
définie. Cette déclaration@tie{}:

@example
FOO ?= bar
@end example

@noindent
est exactelment l'équivalent de (@pxref{La fonction origin, ,La fonction origin}):

@example
ifeq ($(origin FOO), undefined)
  FOO = bar
endif
@end example

Notez qu'une variable définie sur une valeur vide est toujours définie, donc @samp{?=}
ne définira pas cette variable.

@node Fonctionalité avancée des variables, Les valeurs des variables, Deux catégories de variables, Utiliser les variables
@section Fonctionalités avancées des référencements de variables
@cindex référencer des variables

Cette section décrit quelques fonctionalité avancées que vous pouvez
utiliser pour référencer les variables de manières plus flexibles.

@node Références de substitution, Noms générés, Fonctionalité avancée des variables, Fonctionalité avancée des variables
@subsection Substitution de références
@cindex référence de variable modifiée
@cindex substitution de référence de variable
@cindex variables, références modifiées
@cindex variables, substitution de référence

@cindex variables, substituer les suffixes
@cindex suffixes, substituer dans les variables
Une @dfn{substitution de référence} consiste à spécifier des
modifications du contenu d'une variable.  Elle a la forme
@samp{$(@var{var}:@var{a}=@var{b})} (ou
@samp{$@{@var{var}:@var{a}=@var{b}@}}) et ceci signifie qu'on prend la
valeur de la variable @var{var}, qu'on remplace chaque occurence de
@var{a} par @var{b} à la fin des mots et qu'on remplace le contenu de
départ par cette nouvelle chaîne.

Quand nous disons ``à la fin des mots'', ceci veut dire que @var{a} doit
apparaitre suivi d'espace blanc ou à la fin du contenu pour être
remplacé@tie{}; les autres occurrences de @var{a} dans le contenu ne
seront pas modifiées.  Par exemple:@refill

@example
foo := a.o b.o l.a c.o
bar := $(foo:.o=.c)
@end example

@noindent
définit @samp{bar} comme @samp{a.c b.c l.a c.c}.  @xref{Définir une variable,
,Définir les variables}.

Un remplacement de référence est un racourcis pour la fonction de
développement @code{patsubst} (@pxref{Fonctions de texte, ,Fonctions de
substitution de d'analyse des chaînes de texte}):
@samp{$(@var{var}:@var{a}=@var{b})} est équivalente à
@samp{$(patsubst %@var{a},%@var{b},@var{var})}.  Nous donnons aussi les 
références de substitution pour @code{patsubst} pour garder la
compatibilité avec les autres implémentations de @code{make}.

@findex patsubst
Un autre type de substitution de révérence vous permet d'utiliser toute
la puissance de la fonction @code{patsubst}.  Elle a la même forme que 
@samp{$(@var{var}:@var{a}=@var{b})} décrit plus haut, excepté que maintenant @var{a}
doit contenir un seul caractère @samp{%}.  Ceci est équivalent à
@samp{$(patsubst @var{a},@var{b},$(@var{var}))}.  @xref{Fonctions de texte,
,Fonctions de substitution de d'analyse des chaînes de texte}, pour la
description de la fonction @code{patsubst}.@refill

@example
@group
@exdent For example:

foo := a.o b.o l.a c.o
bar := $(foo:%.o=%.c)
@end group
@end example

@noindent
définit @samp{bar} comme @samp{a.c b.c l.a c.c}.

@node Noms générés, , Références de substitution, Fonctionalité avancée des variables
@subsection Noms de variables générés à l'exécution
@cindex références de variable liées
@cindex nom de variable généré à l'exécution
@cindex variables, noms générés à l'exécution
@cindex variables, références liées
@cindex variables, @samp{$} dans les noms
@cindex @code{$}, dans les noms de variable
@cindex signe dollar (@code{$}), dans les noms de variables

La génération de noms de variables au moment de l'exécution est un
concept plus compliqué, utile seulement pour la programmation très
avancée de makefile.  Pour la plupart des usages, vous n'aurez pas
besoin de vous en servir, excepté de savoir qu'écrire le nom d'une
variable avec le signe dollar dedans peut avoir des résultats
bizarres. Cecpendant si vous êtes du type de ceux qui veulent tout
comprendre, ou que vous êtes intéressé par ce que ce que vous faites,
continuer la lecture.

Les variables peuvent être référencées à l'intérieur du nom d'une
variable. Ceci est appelé un @dfn{nom de variable généré au moment de
l'exécution} ou une @dfn{référence de variable liée}.  Par exemple,

@example
x = y
y = z
a := $($(x))
@end example

@noindent
définit @code{a} comme @samp{z}: le @samp{$(x)} à l'intérieur de
@samp{$($(x))} se développe en @samp{y}, donc @samp{$($(x))} se
développe en @samp{$(y)} qui à son tour se développe en to @samp{z}.
Ici le nom de la variable à référencer n'est pas donné
explicitement@tie{}; son nom est généré par le développement de
@samp{$(x)}. La référence @samp{$(x)} est ici liée à la référence de
variable la plus extérieure.

L'exemple précédant montre deux niveaux d'imbrication, mais on peut
avoir n'importe quel nombre de niveaux d'imbrication. Voici par exemple
trois niveaux d'imbrication.

@example
x = y
y = z
z = u
a := $($($(x)))
@end example

@c @noindent
Ici la pertie la plus interne @samp{$(x)} se développe en @samp{y}, donc
@samp{$($(x))} se développe en @samp{$(y)}, qui à sont tour se développe
en @samp{z}@tie{}; maintenant nous avons @samp{$(z)}, qui devient @samp{u}.

Les références aux variables développées récursivement dans les noms de
variables sont re-développé de la même manière. Par exemple@tie{}:

@example
x = $(y)
y = z
z = Hello
a := $($(x))
@end example

@noindent
définit @code{a} comme @samp{Hello}@tie{}: @samp{$($(x))} devient @samp{$($(y))},
qui devient @samp{$(z)}, qui devient @samp{Hello}.

Les références de variables liées peuvent aussi contenir des références
modifiées ou des invocations de fonctions (@pxref{Les fonctions, ,Fonctions
de transformation de texte}), juste comme n'importe quelle autre
référence.  Par exemple, l'utilisation de la fonction de substitution @code{subst}
(@pxref{Fonctions de texte, ,Fonctions de substitutions et d'analyse
des chaînes de texte}):

@example
@group
x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))
@end group
@end example

@noindent
Ceci définit finalement @code{a} comme @samp{Hello}.  Il n'est pas sûr
que quelqu'un voudra jamais écrire une référence liées aussi alambiquée
que celle-ci, mais cela fonctionne@tie{}: @samp{$($($(z)))} se développe
en @samp{$($(y))} qui devient @samp{$($(subst 1,2,$(x)))}.  Ceci obtient
la valeur @samp{variable1} de @code{x} et la modifie par substitution
de @samp{variable2} de telle façon que la chaîne entière devienne
@samp{$(variable2)}, une simple référence de variable dont la valeur est
@samp{Hello}.@refill

Un nom de variable calculé n'a pas besoin d'être constitué entièrement
d'une seule référence de variable.  Il peut contenir plusieurs
références de variables comme des parties invariantes de texte.  Par
exemple,

@example
@group
a_dirs := dira dirb
1_dirs := dir1 dir2
@end group

@group
a_files := filea fileb
1_files := file1 file2
@end group

@group
ifeq "$(use_a)" "yes"
a1 := a
else
a1 := 1
endif
@end group

@group
ifeq "$(use_dirs)" "yes"
df := dirs
else
df := files
endif

dirs := $($(a1)_$(df))
@end group
@end example

@noindent
donnera à @code{dirs} la même valeur que @code{a_dirs}, @code{1_dirs},
@code{a_files} ou @code{1_files} selon les réglages de @code{use_a}
et @code{use_dirs}.@refill

Les noms de variable calculés peuvent aussi utilisés dans les
substitutions de références@tie{}:

@example
@group
a_objects := a.o b.o c.o
1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
@end group
@end example

@noindent
définit @code{sources} comme @samp{a.c b.c c.c} ou @samp{1.c 2.c 3.c},
selon la valeur donnée à @code{a1}.

La seule restriction sur ce genre d'utilisation de références de
variables liées est qu'elles ne peuvent pas spécifier une partie du nom
d'une fonction à appler. Ceci vient du fait que le teste pour
reconnaitre un nom de fonction est fait avant le développement des
références liées. Par exemple,

@example
@group
ifdef do_sort
func := sort
else
func := strip
endif
@end group

@group
bar := a d b g q c
@end group

@group
foo := $($(func) $(bar))
@end group
@end example

@noindent
cherche à donner à la valeur de la variable @samp{foo} soit @samp{sort a d b g q
c} soit @samp{strip a d b g q c} plutôt que de donner @samp{a d b g q c}
comme argument à la fonction @code{sort} ou à la fonction @code{strip}.
Cette restriction pourrait être levée dans une version future, si ce
changement s'avère être une bonne idée.

Vous pouvez aussi calculer les noms de variables and dans la partie
main-gauche de l'assignement d'une variable ou dans une directive
@code{define} comme dans@tie{}:

@example
dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print =
lpr $($(dir)_sources)
endef
@end example

@noindent
Cet exemple définit les variables @samp{dir}, @samp{foo_sources}, et
@samp{foo_print}.

Notez que @dfn{les références de variables liées} sont quelque peu
différentes des @dfn{variables développées récursivement}
(@pxref{Deux catégories de variables, ,Les deux catégories de variables}), bien que les
deux soient utilisées ensemble d'une façon complexe quand on fait de la
programmation avancée de makefile.@refill


@node Les valeurs des variables, Définir une variable, Fonctionalité avancée des variables, Utiliser les variables
@section Comment les variables obtiennent leur valeurs
@cindex variables, comme obtiennent elles leur valeurs
@cindex valeur, comment une variable l'obtient-elle

Les variables peuvent obtenir leur valeurs de différentes façons@tie{}:

@itemize @bullet
@item
Vous pouvez définir une valeur de remplacement quand vous exécuter @code{make}.
@xref{Forcer, ,Remplacer les variables}.

@item
Vous pouvez spécifier une valeur dans un makefile avec une instruction
d'assignement (@pxref{Définir une variable, ,Définir les variables}) ou avec une définition verbatim
(@pxref{Variables sur plusieurs lignes, ,Définir des variables sur plusieurs lignes}).@refill

@item
Les variables de l'environment deviennent des variables de @code{make}.
@xref{Variables d'environnement, ,Variables venant le l'environnement}.

@item
Plusieurs variables @dfn{automatiques} reçoivent de nouvelles valeurs
pour chaque règle.  Chacune d'entre elles a un seul usage conventionnel.
@xref{Les variables automatiques}.

@item
Plusieurs variables ont des valeurs initiales contantes.  @xref{Les variables implicites,
,Variables utilisées par les règles implicites}.
@end itemize

@node Définir une variable, Rajouter du texte à une variable, Les valeurs des variables, Utiliser les variables
@section Définir les variables
@cindex définir les variables
@cindex variables, définition
@cindex =
@cindex :=
@cindex ::=
@cindex ?=
@cindex !=

Pour définir une variable depuis le makefile, écrite un ligne démarrant
avec le nom de la variable suivi de @samp{=}, @samp{:=}, or @samp{::=}.
Tout ce qui suit @samp{=}, @samp{:=}, or @samp{::=} sur la ligne devient
la valeur.  Par exemple,

@example
objects = main.o foo.o bar.o utils.o
@end example

@noindent
définit une variable nommée @code{objects}.  Les espaces blancs
entourant le nom de la variable et immédiatement après le @samp{=} sont
ignorés.

Les variables définies avec @samp{=} sont des variables @dfn{développées
récursivement}. Les variables définies avec @samp{:=} ou @samp{::=} sont
des variables @dfn{développées de manière unique}@tie{}; ces définitions
peuvent contenir des références de variables, qui seront développées
avant que la définition soit faite.  @xref{Deux catégories de variables, ,Les deux
catégories de variables}.

Un nom de variable peut contenir une fonction ou une référence de
variable, qui sont développées quand la ligne est lue pour trouver le
véritable nom de variable à utiliser.

Il n'y a pas de limite sur le longueur d'une valeur de variable,
excéptée celle de la mémoire de votre ordinateur. Vous pouvez aussi
couper la valeur d'une variable en plusieurs lignes physiques pour une
meilleure lisibilité (@pxref{Couper les lignes, ,Couper les lignes longues}).

La plupart des noms de variables sont considérés avoir la chaîne vide
comme valeur si vous ne les avez jamais définies. Plusieurs variables
ont des valeurs initiales pré-définies qui ne sont pas la chaîne vide,
mais vous pouvez les redéfinir de la façon habituelle (@pxref{Les variables
implicites, ,Variables utilisées dans les règles implicites}).
Plusieurs variables spéciales sont définie automatiquement à une
nouvelle valeur pour chaque règle@tie{}; ces dernières sont appelées les
variables @dfn{automatique} (@pxref{Les variables automatiques}).

Si vous voulez définir une variable sur une valeur seulement si la
variable n'est pas déjà définie, vous pouvez utiliser en raccourcis
l'opérateur @samp{?=} à la place de @samp{=}.
Ces deux définitions de la variable @samp{FOO} sont identiques
(@pxref{La fonction origin, ,La fonction @code{origin}}):

@example
FOO ?= bar
@end example

@noindent
et

@example
ifeq ($(origin FOO), undefined)
FOO = bar
endif
@end example

L'operateur shell d'assignment @samp{!=} peut être utilisé dans une
instruction d'assignement pour exécuter le script shell et définir la
variable sur sa sortie. Cet opérateur évalue d'abord la partie main
droite de l'instruction, puis passe le résultat au shell pour exécution.
Si le résultat de l'exécution se termine par un caractère de nouvelle
ligne, ce caractère de nouvelle ligne est enlevé@tie{}; toutes les
autres nouvelles lignes sont remplacées par des espaces.  La chaîne
résultante est ensuite placée dans la variable nommée et développée
récursivement. Par exemple:

@example
hash != printf '\043'
file_list != find . -name '*.c'
@end example

Si le résultat d'exécution peut produire un @code{$}, et que vous
n'aillez pas l'intention que ce qui va en découler soit interprété comme
une variable make ou une référence de fonction, alors vous devez
remplacer chaque @code{$} par un @code{$$} pendant l'exécution shell.
Autrement, vous pouvez définir une variable développée simplement sur le
résultat d'un programme en utilisant un appel à la fonction
@code{shell}.  @xref{La fonction shell, , La fonction shell}.  For
example:

@example
hash := $(shell printf '\043')
var := $(shell find . -name "*.c")
@end example

As with the @code{shell} function, the exit status of the just-invoked shell
script is stored in the @code{.SHELLSTATUS} variable.


@node Rajouter du texte à une variable, Directive de forçage, Définir une variable, Utiliser les variables
@section Rajouter du texte à une variable
@cindex +=
@cindex rajouter du texte à une variable
@cindex variable, rajouter

Il est souvent utile de pouvoir ajouter plus de texte à la valeur d'une
variable déjà définie. Vous le faites avec une ligne contenant
@samp{+=}, comme ceci@tie{}:

@example
objects += another.o
@end example

@noindent
Ceci prend la valeur de la variable @code{objects} et lui ajouter le
texte @samp{another.o} (précédée par un seul espace, s'il y a déjà une
valeur).  Donc@tie{}:

@example
objects = main.o foo.o bar.o utils.o
objects += another.o
@end example

@noindent
définie @code{objects} à @samp{main.o foo.o bar.o utils.o another.o}.

Utiliser @samp{+=} est similaire à@tie{}:

@example
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
@end example

@noindent
mais diffère d'une manière qui prend son importance quand vous utilisez
des valeurs plus complexes.

Quand la variable en question n'a pas été définie avant, @samp{+=} agit
juste comme un @samp{=} normal@tie{}: il définit une variable dévéloppée
récursivement. Cependant, quand il @emph{y a} une valeur déjà définie,
ce qui @samp{+=} fait exactement dépend de la catégorie de la variable
que vous avez déjà définie. @xref{Deux catégories de variables, ,Les deux versions des
variables}, pour une explication sur les deux catégories de variables.

Quand vous ajouter à la valeur de la variable avec @samp{+=},
@code{make} agit essentiellement comme si vous aviez inclus du texte
supplémentaire dans la définition originelle de la variable. Si vous
l'aviez d'abord définie avec @samp{:=} ou @samp{::=}, en la définissant
donc comme une variable développée de manière unique, @samp{+=} ajoute à
la définition de cette variable définie de manière unique et développe
le nouveau texte avant de l'ajouter à l'ancienne valeur juste comme
@samp{:=} le fait (voir @ref{Définir une variable, ,Définir les variables}, pour une
explication complète de @samp{:=} ou @samp{::=}).  En fait,

@example
variable := value
variable += more
@end example

@noindent
est l'exact équivalent de@tie{}:

@noindent
@example
variable := value
variable := $(variable) more
@end example

D'un autre côté, quand vous utilisez @samp{+=} avec une variable que
vous avez d'abord définie comme une variable développée récursivement en
utilisant @samp{=}, @code{make} fait quelque chose d'un peu différent.
Rappelez vous que quand vous définissez une variable développée
recursivement, @code{make} ne développe pas immédiatement la valeur que
vous avez définie pour la variable ni les functions que vous auriez
utilisées.  À la place, il enregistre le texte tel que (ndt. verbatim)
et sauvegarde ces références de variables et de fonctions pour les
développer plus tard, quand vous réfèrerez cette nouvelle variable
(@pxref{Deux catégories de variables, ,Les deux catégories de variables}).  Quand vous
utilisez @samp{+=} sur une variable développée récursivement,
@code{make} ajoute le nouveau texte que vous avez spécifié à du texte
qui n'a pas encore été développé.

@example
@group
variable = value
variable += more
@end group
@end example

@noindent
est en gros équivalent à@tie{}:

@example
@group
temp = value
variable = $(temp) more
@end group
@end example

@noindent
excepté bien sûr qu'il ne définit jamais une variable appelée
@code{temp}. L'importance de ceci vient quand l'ancienne valeur de la
variable contient des références de variables. Prenez cet exemple
commun@tie{}:

@example
CFLAGS = $(includes) -O
@dots{}
CFLAGS += -pg # enable profiling
@end example

@noindent
La première ligne définit la variable @code{CFLAGS} avec une référence à
une autre variable, @code{includes}.  (@code{CFLAGS} est utilisée par
les règles for la compilation C; @pxref{Catalogue des règles, ,Catalogue
des règles prédéfinies}.@tie{})

Utiliser @samp{=} pour la définition fait de @code{CFLAGS} une variable
développée récursivement, ce qui signifie que @w{@samp{$(includes) -O}}
n'est @emph{pas} développé quand @code{make} exécute la définition de
@code{CFLAGS}.  Donc, @code{includes} n'a pas besoin d'être encore
définie pour que sa valeur prenne effet.  Elle a juste besoin d'être
définie avant qu'il soit fait référence à @code{CFLAGS}.  Si nous
essayons d'ajouter à la valeur de @code{CFLAGS} sans utiliser @samp{+=},
vous pourriez le faire comme cela@tie{}:

@example
CFLAGS := $(CFLAGS) -pg # enable profiling
@end example

@noindent
Cela se rapproche, mais ce n'est pas exactement ce que nous
voulons. Utiliser @samp{:=} redéfinit @code{CFLAGS} comme un variable
développée de manière unique@tie{}; ce qui signifie que @code{make}
développera le texte @w{@samp{$(CFLAGS) -pg}} avant de définir la
variable.  Si @code{includes} n'est pas encore définie, nous obtenons
@w{@samp{ -O -pg}}, et une définition de @code{includes} faite plus tard
n'aura aucun effet.  Réciproquement, en utilisant @samp{+=} nous
définissons @code{CFLAGS} sur la valeur @emph{non développée} de
@w{@samp{$(includes) -O -pg}}.  Donc nous préservons la référence à
@code{includes}, de telle façon que cette variable soit définie plus
tard, une référence comme @samp{$(CFLAGS)} utilise toujours cette valeur.


@node Directive de forçage, Variables sur plusieurs lignes, Rajouter du texte à une variable, Utiliser les variables
@section La directive @code{override}
@findex override
@cindex forcer avec  @code{override}
@cindex variables, forcer leur valeur
Si une variable a été définie avec argument de commande (@pxref{Forcer,
,Forcer les variables}), alors les assignements ordinaires dans le
makefile sont ignorés.  Si vous voulez définir une variable dans le
makefile même si elle a été définie en argument de commande, vous pouvez
utiliser une directive @code{override}, qui est une ligne qui ressemble
à ceci@tie{}:@refill

@example
override @var{variable} = @var{value}
@end example

@noindent
ou

@example
override @var{variable} := @var{value}
@end example

Pour ajouter plus de texte à une variable définie en ligne de commande,
utilisez@tie{}:

@example
override @var{variable} += @var{more text}
@end example

@noindent
@xref{Rajouter du texte à une variable, ,Ajouter plus de texte aux variables}.

Les assignements de variables marquées avec l'option @code{override} ont
une plus haute priorité que les autres assignements, excepté un autre
@code{override}.  Les assignements supplémentaires ou ce qui qui arrive
à cette variable et ne sont pas marqué par @code{override} seront ignorés.

La directive @code{override} n'a pas été inventée pour escalader une
compétition entre les makefiles est les arguments en ligne de commande.
Elle a été inventée pour que vous puissiez modifier et faire des ajouts
aux valeur que l'utilisateur spécifie avec les arguments en ligne de
commande.

Par exemple, supposez que vous vouliez toujours avoir l'option @samp{-g}
quand vous exécutez le compilateur C, mais que vous vouliez permettre à
l'utilisateur de spécifier les autres options avec un argument en ligne
de commande, comme d'habitude. Vous pourriez utiliser cette directive
@code{override}@tie{}:

@example
override CFLAGS += -g
@end example

Vous pourriez aussi utiliser les directives @code{override} et @code{define}.
Ceci est fait comme vous pourries l'espérer@tie{}:

@example
override define foo =
bar
endef
@end example

@noindent
@iftex
Voir la section suivante pour plus d'information sur @code{define}.
@end iftex
@ifnottex
@xref{Variables sur plusieurs lignes, ,Defining Multi-Line Variables}.
@end ifnottex

@node Variables sur plusieurs lignes, Directive indéfinie, Directive de forçage, Utiliser les variables
@section Définir une variable sur plusieurs lignes
@findex define
@findex endef
@cindex définition d'une variable sur plusieurs lignes
@cindex variables, multi-ligne
@cindex définition verbatim d'une variable
@cindex définir des variables verbatim
@cindex variables, definition verbatim

Une autre façon de définir les valeurs d'une variable est d'utiliser la
directive @code{define}.  Cette directive a une syntaxe inhabituelle,
qui permet aux caractères de nouvelle ligne d'être inclus dans la
valeur, ce qui est pratique pour définir à la fois les séquences
d'instructions (@pxref{Les séquences enregistrées, ,Définir des
séquences enregistrées d'instructions}), et aussi pour les sections de
syntaxe makefile qui s'utilisent avec la fonction @code{eval}
(@pxref{Fonction Eval}).@refill

La directive @code{define} est suivie sur la même ligne par le nom de la
variable qui est défini par un opérateur (optionel) d'assignement et
rien de plus. La valeur à donner à la variable vient sur les lignes qui
suivent.  La fin de la valeur est marquée par une ligne qui contient
juste le mot @code{endef}.

À part cette différence de syntaxe, @code{define} fonctionne jsute comme
tout autre définition de variable. Le nom de la variable peut contenir
des fonctions ou des références de variables, qui sont développées quand
la directive est lue pour trouver le nom réel à utiliser pour cette
variable.

La dernier caractère de nouvelle ligne avant @code{endef} n'est pas
inclus dans la valeur@tie{}; si vous voulez que votre valeur contienne un
retour de ligne final, vous devez inclure une ligne blanche. Par exemple
pour définir une variable qui contient un caractère de nouvelle ligne,
vous devez utiliser @emph{deux} lignes vides, et non une seule@tie{}:

@example
define newline


endef
@end example

Si vous préférez, vous pouvez omettre l'opérateur d'assignement de
variable.  S'il est omis, @code{make} présume qu'il s'agit de @samp{=}
et crée une variable développée récursivement (@pxref{Deux catégories de
variables, ,Les deux catégories de variables}).  Quand vous utilisez un
opérateur @samp{+=}, la valeur est ajoutée à la valeur précédente comme
pour toute autre opération de concaténation@tie{}: avec un seul espace
séparant les anciennes valeurs des nouvelles.

Vous pouvez imbriquer les directives @code{define}@tie{}: @code{make}
gardera la trace des directives imbriquées et reportera une erreur si
elle ne sont pas refermées proprement avec @code{endef}.  Notez que les
lignes commençant avec un caractère de préfixe d'instruction sont
considérées comme faisant partie de l'instruction, donc toute chaîne
@code{define} ou @code{endef} apparaissant sur une telle ligne ne seront
pas considérées comme des directives @code{make}.

@example
define two-lines
echo foo
echo $(bar)
endef
@end example

@need 800
Quand il est utilisé dans une instruction, l'exemple précédant est
fonctionnellement équivalent à ceci@tie{}:

@example
two-lines = echo foo; echo $(bar)
@end example

@noindent
car deux commandes séparées par un point virgule se comportent comme
deux commandes shell indépendantes. Cependant, notez qu'utiliser deux
lignes séparées signifie que @code{make} invoquera le shell deux fois,
en exécutant des sous-shell indépendants pour chacune des lignes.
@xref{Exécution, ,Exécution d'une instruction}.

Si vous voulez que les définitions de variables faites avec
@code{define} aient la préséance sur les définitions de variables faites
en ligne de commande, vous pouvez utiliser la directive @code{override}
avec @code{define}@tie{}:

@example
override define two-lines =
foo
$(bar)
endef
@end example

@noindent
@xref{Directive de forçage, ,The @code{override} Directive}.

@node Directive indéfinie, Variables d'environnement, Variables sur plusieurs lignes, Utiliser les variables
@section Variables indéfinie
@findex indéfinie
@cindex variable indéfinie

Si vous voulez effacer une variable, définir sa valeur à la chaîne vide
est généralement suffisant. Développer une telle variable donnera la
même résultat (une chaîne vide), qu'elle ait été définie ou
non. Cependant, si vous utilisez les fonctions @code{flavor}
(@pxref{La fonction Flavor}) et @code{origin} (@pxref{La fonction
origin}), il y a une différence entre une variable qui n'a jamais été
définie et une variable avec une valeur de chaîne vide. Dans ces
situations vous pourriez vouloir utiliser la directive @code{undefine}
pour faire apparaitre la variable comme si elle n'avait jamais été
définie. Par exemple@tie{}:

@example
foo := foo
bar = bar

undefine foo
undefine bar

$(info $(origin foo))
$(info $(flavor bar))
@end example

Cet exemple renverra ``undefined'' pour les deux variables.

Si vous voulez rendre indéfinie une variable définie en ligne de
commande, vous pouvez utiliser la directive @code{override} avec
@code{undefine}, de manière similaire avec ce qui est fait avec les
définitions de variables@tie{}:

@example
override undefine CFLAGS
@end example

@node Variables d'environnement, Variables spécifiques à la cible, Directive indéfinie, Utiliser les variables
@section Variables venant de l'environnement

@cindex variables, environnement
@cindex environnement
Les variables dans @code{make} peuvent venir de l'environnement dans
lequel @code{make} est exécuté.  Chaque variable d'environnement que
@code{make} voit quand il démarre est transformée en une variable
@code{make} avec la même nom et la même valeur.  Cependant, un
assignement explicite dans le makefile, ou avec un argument de commande,
remplace celle venant de l'environnement.  (Si l'option @samp{-e} est
spécifiée, alors les valeurs des variables venant de l'environnement
remplacent les assignements faits dans le makefile.  @xref{Résumé des
options, ,Résumé des options}. Mais ceci n'est pas une pratique
recommandée.)

Dans en définissant la variable @code{CFLAGS} dans votre environnement,
vous pouvez faire que toutes les compilations C de la plupart des
makefiles utilisent les options de compilation que vous préférez.  Ceci
est sûr pour les variables avec des significations standards ou
conventionnelles, car vous savez qu'aucun makefile ne les utilisera pour
d'autres choses.  (Notez que ce n'est pas complètement fiable@tie{};
certains makefiles définisse @code{CFLAGS} explicitement et donc ne sont
pas affectés par les valeurs données par l'environnement.)

Quand @code{make} exécute une instruction, les variables définies dans
le makefile sont placées dans l'environnement de chaque shell. Ceci vous
permet de passer les valeurs aux invocation de sous-@code{make}
(@pxref{Récursion, ,Utilisation récursive de @code{make}}).  Par défaut,
seules les variables qui viennent de l'environnement ou de la ligne de
commande sont passées aux invocations récursives.  Vous pouvez utiliser
la directive @code{export} pour passer les autres variables.  @xref{La
récursion et les variables, , Communiquer les variables à des
sous-@code{make}}, pour plus de détails.

Les autres utilisation des variables venant de l'environnement ne sont
pas recommandées.  Il n'est pas avisé pour les makefiles que leur
fonctionnement dépendent des variables d'environnements définies en
dehors de leur contrôle, car cela pourrait faire que différents
utilisateurs aient différents résultats pour le même makefile.  Ceci va
à l'encontre de l'objectif complet de la plupart des makefiles.

@cindex SHELL, importer de l'environnement
Ce genres de problèmes peut arriver spécialement avec la variable
@code{SHELL}, qui est normalement présente dans l'environnement pour
spécifier le choix de l'utilisateur pour le shell interactif. Il n'est
pas du tout souhaitable que ce choix affecte @code{make}@tie{}; donc,
@code{make} gère la variable d'environnement @code{SHELL} d'une façon
particulière@tie{}; voir @ref{Choisir le Shell}.@refill

@node Variables spécifiques à la cible, Variables spécifiques au modèle, Variables d'environnement, Utiliser les variables
@section Valeur des variables spécifiques à la cible
@cindex variables spécifiques à la cible
@cindex variables, spécifiques à la cible

Les valeurs des variables dans @code{make} sont normalement
globales@tie{}; ce qui signifie qu'elles ne dépendent pas de la façon
dont elles sont évaluées (sauf si elles sont remises à zéro, bien sûr).
Une exception est cependant les variables automatiques (@pxref{Les variables automatiques}).

Les autres exceptions sont @dfn{les valeurs des variables spécifiques à
la cible}. Cette fonctionalité permet de définir différentes valeurs
pour une même variable, en se basant sur la cible que @code{make} est en
train de construire. Comme les variables automatiques, ces valeurs ne
sont disponibles que dans le contexte d'une instruction pour une cible
(et dans les autres assignements spécifiques aux cibles).

Vous définissez une valeur de variable spécifique à la cible comme ceci@tie{}:

@example
@var{target} @dots{} : @var{assignment-de-variable}
@end example

Les assignements de variables spécifiques à une cible peuvent être
préfixés avec n'importe lequel des mots clef spéciaux @code{export},
@code{override}, ou @code{private}@tie{}; ceci applique les comportement
habituels à ces instances de variables seulement.

Les valeurs de @var{cibles} multiples créent individuellement des
valeurs spécifiques à la cible pour chaque membre de la liste des cibles.

L'@var{assignment-de-variable} peut être chacune des formes
d'assignements qui existe@tie{}; récursif (@samp{=}), unique avec
(@samp{:=} ou @samp{::=}), ajoutant (@samp{+=}), ou encore conditionnel
(@samp{?=}).  Toutes les variables qui apparaissent dans un
@var{assignment-de-variable} sont évaluées dans le contexte de la
cible@tie{}: donc, toute variable définie précédemment et spécifique à la
cible sera effective.  Notez que cette variable est en fait distinct
d'une valeur ``globale'' de variable@tie{}: les deux variables n'ont pas
à être de la même catégorie (récursif vs.@: unique).

Les variables spécifiques à la cible ont la même priorité que n'importe
quelle autre variable du makefile. Les variables obtenues sur la ligne
de commandes (et de l'environnement si l'option @samp{-e} est active)
auront la préséance.  Spécifier la directive @code{override} permettra
aux valeurs des variables spécifiques à la cible d'être préférées.

Il y a une autre fonctionalité spéciale des variables spécifiques à la cible@tie{}:
quand vous définissez une variable spécifique à la cible, la valeur de
cette variable est aussi active pour tous les pré-requis de cette cible
et leur propres pré-requis etc.@:
(sauf si ces pré-requis remplacent cette variable avec leur propre
valeur de variable spécifique à la cible).  Donc, par exemple, des
instructions comme celles-ci@tie{}:

@example
prog : CFLAGS = -g
prog : prog.o foo.o bar.o
@end example

@noindent
définiront @code{CFLAGS} à @samp{-g} dans les instructions pour
@file{prog}, mais elles définiront aussi @code{CFLAGS} à @samp{-g} dans
les instructions qui créent @file{prog.o}, @file{foo.o} et @file{bar.o}
et toutes les instructions qui créent leur pré-requis.

Soyez conscient qu'un pré-requis donné ne sera compilé qu'une fois au
plus par invocation de make. Supposons que le même fichier soit le
pré-requis de plusieurs cibles, et que chacune de ces cibles demande une
valeur différente pour la même variable spécifique à la cible, alors
la première cible qui sera compilée provoquera la compilation du
pré-requis et tous les pré-requis hériteront de la valeur déterminée
pour la première cible. La variable ignorera les valeurs qu'elles
auraient dû avoir avec les autres cibles.


@node Variables spécifiques au modèle, Supprimer l'héritage, Variables spécifiques à la cible, Utiliser les variables
@section Valeurs de variables spécifiques aux modèles
@cindex variables spécifiques au modèle
@cindex variables, spécifique au modèle

En plus des valeurs de variables spécifique aux cibles (@pxref{Variables
spécifiques à la cible, ,Valeur des variables spécifiques aux cibles}), GNU
@code{make} supporte les valeurs spécifiques au modèle. Dans cette forme,
la variable est définie pour toute cible qui correspond au modèle spécifié.

Vous défnissez une variable spécifique à un modèle de cette façon@tie{}:

@example
@var{modèle} @dots{} : @var{assignment-de-variable}
@end example
où @var{modèle} est un modèle utilisant @samp{%}. Comme pour les valeur
des variables spécifiques au cible, les valeurs de @var{modèles}
multiples créent des valeur pour chaque modèle individuellement.
L'@var{assignment-de-variable} peut être n'importe quelle forme valable
d'assignement de variable. Toute définition de variable en ligne de
commande aura la priorité, sauf si la directive @code{override} est
spécifiée.

Par exemple:

@example
%.o : CFLAGS = -O
@end example

@noindent
assignera la valeur @samp{-O} à @code{CFLAGS} pour toutes les cibles
vérifiant le modèle @code{%.o}.

Si une cible vérifie plus d'un modèle, les variables spécifiques aux
modèles dont les radicaux sont les plus longs, seront interprétés les
premiers. Il en résulte que les variables les spécifiques ont la
préséance sur les variables plus générales, par exemple@tie{}:

@example
%.o: %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@@

lib/%.o: CFLAGS := -fPIC -g
%.o: CFLAGS := -g

all: foo.o lib/bar.o
@end example

Dans cet exemple, la première définition de la variable @code{CFLAGS}
sera utilisée pour mettre à jour @file{lib/bar.o} même si la seconde
définition s'applique aussi à cette cible. Les variables spécifique aux
modèles qui donnent la même longueur de radical sont considérées dans
leur ordre d'apparition dans le makefile.

Les variables spécifiques aux modèles sont recherchées après les
variables spécifiques aux cibles qui seraient définies explicitement
pour cette cible et avant les variables spécifiques aux cibles définies
pour la cible parent.

@node Supprimer l'héritage, Variables spéciales, Variables spécifiques au modèle, Utiliser les variables
@section Supprimer l'héritage
@findex private
@cindex suppressing inheritance
@cindex inheritance, suppressing

As described in previous sections, @code{make} variables are inherited by
prerequisites.  This capability allows you to modify the behavior of a
prerequisite based on which targets caused it to be rebuilt.  For example,
you might set a target-specific variable on a @code{debug} target, then
running @samp{make debug} will cause that variable to be inherited by all
prerequisites of @code{debug}, while just running @samp{make all} (for
example) would not have that assignment.

Sometimes, however, you may not want a variable to be inherited.  For these
situations, @code{make} provides the @code{private} modifier.  Although this
modifier can be used with any variable assignment, it makes the most sense
with target- and pattern-specific variables.  Any variable marked
@code{private} will be visible to its local target but will not be inherited
by prerequisites of that target.  A global variable marked @code{private}
will be visible in the global scope but will not be inherited by any target,
and hence will not be visible in any recipe.

As an example, consider this makefile:
@example
EXTRA_CFLAGS =

prog: private EXTRA_CFLAGS = -L/usr/local/lib
prog: a.o b.o
@end example

Due to the @code{private} modifier, @code{a.o} and @code{b.o} will not
inherit the @code{EXTRA_CFLAGS} variable assignment from the @code{prog}
target.

@node Variables spéciales, , Supprimer l'héritage, Utiliser les variables
@comment  node-name,  next,  previous,  up
@section Autre variables spéciales
@cindex makefiles, et les variables spéciales
@cindex variables spéciales

GNU @code{make} supporte quelques variables qui ont des propriétés particulières.

@table @code

@vindex MAKEFILE_LIST @r{(liste des makefiles analysés)}
@cindex makefiles, et la variable @code{MAKEFILE_LIST}
@cindex inclure (variable @code{MAKEFILE_LIST})
@item MAKEFILE_LIST
Contient le nom de chaque makefile, qui est analysé par @code{make},
dans l'ordre dans lequel il est analysé. Le nom est ajouté juste avant
que @code{make} ne commence l'analyse du makefile.  Donc, si la première
chose que fait un makefile est d'examiner le dernier mot de cette
variable, ce sera le nom du makefile courant. Une fois que le makefile
courant a utilisé @code{include}, cependant, le dernier mot sera le
makefile qui vient d'être inclus.

Si un makefile nommé @code{Makefile} a ce contenu@tie{}:

@example
@group
name1 := $(lastword $(MAKEFILE_LIST))

include inc.mk

name2 := $(lastword $(MAKEFILE_LIST))

all:
        @@echo name1 = $(name1)
        @@echo name2 = $(name2)
@end group
@end example

@noindent
alors vous pourriez vous attendre à voir ce résultat@tie{}:

@example
@group
name1 = Makefile
name2 = inc.mk
@end group
@end example

@vindex .DEFAULT_GOAL @r{(définir l'objectif par défaut)}
@item .DEFAULT_GOAL
Définit l'objectif par défaut à utiliser si aucune cible n'a été définie
sur la ligne de commande (@pxref{Objectifs, , Arguments pour spécifier
les objectifs}).  La variable @code{.DEFAULT_GOAL} vous permet de
connaitre l'objectif par défaut courant, de recommencer l'algorithme de
sélection de l'objectif par défaut en effaçant sa valeur ou de définir
explicitement l'objectif par défaut.  L'exemple qui suit illustre ces cas@tie{}:

@example
@group
# Query the default goal.
ifeq ($(.DEFAULT_GOAL),)
  $(warning no default goal is set)
endif

.PHONY: foo
foo: ; @@echo $@@

$(warning default goal is $(.DEFAULT_GOAL))

# Reset the default goal.
.DEFAULT_GOAL :=

.PHONY: bar
bar: ; @@echo $@@

$(warning default goal is $(.DEFAULT_GOAL))

# Set our own.
.DEFAULT_GOAL := foo
@end group
@end example

Le makefile renvoie@tie{}:

@example
@group
no default goal is set
default goal is foo
default goal is bar
foo
@end group
@end example

Notez qu'assigner plus d'un nom de cible à @code{.DEFAULT_GOAL} n'est
pas valable et lèvera une erreur.

@vindex MAKE_RESTARTS @r{(nombre de fois que @code{make} a redémarré)}
@item MAKE_RESTARTS
Cette variable est définie seulment si une instance de @code{make} a
redémarré (@pxref{Reconstruire les Makefiles, ,Comme les Makefiles sont
refabriqués})@tie{}: il contiendra le nombre de fois que cette instance
a redémarrée. Notez que ce n'est pas la même chose que les récursions
(qui sont comptées par la variable @code{MAKELEVEL}).  Vous ne devriez
ni définir, modifier ou exporter cette variable.

@vindex MAKE_TERMOUT @r{(savoir si stdout est un terminal)}
@vindex MAKE_TERMERR @r{(savoir si stderr est un terminal)}
@item MAKE_TERMOUT
@itemx MAKE_TERMERR
Quand @code{make} démarre, il vérifie si stdout et stderr reverront leur
sortie sur un terminal.  Si c'est le cas, les variable
@code{MAKE_TERMOUT} et @code{MAKE_TERMERR} seront définies,
respectivement sur le nom du terminal (ou à la valeur @code{true}, si
le nom du terminal ne peut pas être déterminé).  Si elles sont définies,
ces variables seront marquée pour être exportées. Ces variables ne
seront pas modifiées par @code{make} et elles ne seront pas modifiées si
elles sont déjà définies.

Ces valeurs peuvent être utilisées (particulièrement avec la
synchronisation de sortie (@pxref{Sortie parallèle, ,Sortie durant une
exécution en parallèle}) pour déterminer si @code{make} est lui même en
train d'écrire sur un terminal@tie{}; par exemmple, elles peuvent être
testées, pour décider de forcer des commandes d'instructions pour
générer par message colorisés.

Si vous invoquez un sous-@code{make} et redirigez son stdout ou stderr,
il est de votre responsabilité de redéfinir ou de ne pas exporter aussi
ces variables, si votre makefiles compte sur elles.

@vindex .RECIPEPREFIX @r{(change le caractère de préfixe des instructions)}
@item .RECIPEPREFIX
Le premier caractère de la valeur de cette variable est utilisé comme le
caractère que make comprendra comme le caractère débutant les lignes
d'instructions. Si la variable est vide (comme elle l'est par défaut),
ce caractère est le caractère de tabulation standard. Par exemple, voici
un makefile valable@tie{}:

@example
@group
.RECIPEPREFIX = >
all:
> @@echo Hello, world
@end group
@end example

La valeur de @code{.RECIPEPREFIX} peut être changée plusieurs
fois@tie{}; une fois qu'elle est définie, elle reste effective pour
toutes les règles jusqu'à ce qu'elle soit de nouveau modifiée.

@vindex .VARIABLES @r{(list of variables)}
@item .VARIABLES
Développe une liste de tous les @emph{noms} des variables globales
définies jusqu'à présent. Ceci inclut les variables qui ont des valeurs
vides, comme les variables prédéfinies (@pxref{Les variables
implicites, ,Variables utilisées pour les règles implicites}),
mais cela n'inclut pas les variables qui sont définies sur dans un
contexte spécifique à une cible. Notez que toute valeur que vous
pourriez assigner à cette variable sera ignorée@tie{}; elle retournera
toujours sa valeurs spécifiques.

@c @vindex .TARGETS @r{(list of targets)}
@c @item .TARGETS
@c The second special variable is @code{.TARGETS}.  When expanded, the
@c value consists of a list of all targets defined in all makefiles read
@c up until that point.  Note it's not enough for a file to be simply
@c mentioned in the makefile to be listed in this variable, even if it
@c would match an implicit rule and become an ``implicit target''.  The
@c file must appear as a target, on the left-hand side of a ``:'', to be
@c considered a target for the purposes of this variable.

@vindex .FEATURES @r{(liste des fonctionalités supportées)}
@item .FEATURES
Developpe en une liste des fonctionalités particulières supportées par
cette version de @code{make}. Les valeurs possibles incluent, mais ne
sont pas limitées à@tie{}:

@table @samp

@item archives
Supporte les fichiers @code{ar} (archivés) utilisant la syntaxe
particulière des noms de fichiers. @xref{Les fichiers archivés,
,Utiliser @code{make} pour mettre à jour des fichier archivés.}.

@item check-symlink
Supporte l'option @code{-L} (@code{--check-symlink-times}).
@xref{Résumé des options, ,Résumé des options}.

@item else-if
Supporte les expressions conditionnelles non imbriquées ``else if''.  @xref{Syntaxe conditionnelle,
,Syntaxe conditionnelle}.

@item jobserver
Supporte les compilations avancées en ``serveurs de tâches''.  @xref{Parallèle, ,Exécution
parallèle}.

@item oneshell
Supporte la cible spéciale @code{.ONESHELL}.  @xref{Un shell unique,
,Utiliser un shell unique}.

@item order-only
Supporte les pré-requis d'ordonnancement seul.  @xref{Les types de
pré-requis, ,Les types de pré-requis}.

@item second-expansion
Supporte les développement secondaire des listes de pré-requis.

@item shortest-stem
Utilise la méthode du ``radical le plus court'' pour choisir quel modèle
va être utilisé parmis plusieurs options possibles.
@xref{Correspondance de modèle, ,Comment les modèles trouvent des correspondances}.

@item target-specific
Supporte les assigements de variables spécifique aux cibles et
spécifiques aux modèle. @xref{Variables spécifiques à la cible, ,Target-specific Variable Values}.

@item undefine
Supporte la directive @code{undefine} directive.  @xref{Directive indéfinie}.

@item guile
Possède le langage GNU Guile comme un langage d'extension d'expression
intégrées.  @xref{Intégration de Guile, ,Intégration de GNU Guile}.

@item load
Supporte les objets chargés dynamiquement pour créer des extensions personnalisées.
@xref{Charger des objets dynamiquement, ,Charger des objets dynamiques}.
@end table

@vindex .INCLUDE_DIRS @r{(list of include directories)}
@item .INCLUDE_DIRS
Expands to a list of directories that @code{make} searches for included
makefiles (@pxref{Inclure d'autres makefiles, , Including Other Makefiles}).

@vindex .EXTRA_PREREQS @r{(prerequisites not added to automatic variables)}
@item .EXTRA_PREREQS
Each word in this variable is a new prerequisite which is added to targets
for which it is set.  These prerequisites differ from normal prerequisites
in that they do not appear in any of the automatic variables
(@pxref{Les variables automatiques}).  This allows prerequisites to be defined
which do not impact the recipe.

Consider a rule to link a program:

@example
myprog: myprog.o file1.o file2.o
       $(CC) $(CFLAGS) $(LDFLAGS) -o $@@ $^ $(LDLIBS)
@end example

Now suppose you want to enhance this makefile to ensure that updates to the
compiler cause the program to be re-linked.  You can add the compiler as a
prerequisite, but you must ensure that it's not passed as an argument to
link command.  You'll need something like this:

@example
myprog: myprog.o file1.o file2.o $(CC)
       $(CC) $(CFLAGS) $(LDFLAGS) -o $@@ $(filter-out $(CC),$^) $(LDLIBS)
@end example

Then consider having multiple extra prerequisites: they would all have to be
filtered out.  Using @code{.EXTRA_PREREQS} and target-specific variables
provides a simpler solution:

@example
myprog: myprog.o file1.o file2.o
       $(CC) $(CFLAGS) $(LDFLAGS) -o $@@ $^ $(LDLIBS)
myprog: .EXTRA_PREREQS = $(CC)
@end example

This feature can also be useful if you want to add prerequisites to a
makefile you cannot easily modify: you can create a new file such as
@file{extra.mk}:

@example
myprog: .EXTRA_PREREQS = $(CC)
@end example

then invoke @code{make -f extra.mk -f Makefile}.

Setting @code{.EXTRA_PREREQS} globally will cause those prerequisites to be
added to all targets (which did not themselves override it with a
target-specific value).  Note @code{make} is smart enough not to add a
prerequisite listed in @code{.EXTRA_PREREQS} as a prerequisite to itself.

@end table

@node Les parties conditionnelles, Les fonctions, Utiliser les variables, Top
@chapter Parties conditionnelles d'un Makefile

@cindex partie conditionelle
Une directive @dfn{conditional} fait qu'une partie du makefile est
suivie ou ignorée selon des valeurs de variables. Ces directives peuvent
comparer la valeur d'une variable avec une autre ou la valeur d'une
variable avec une chaîne constante.  Ces directives contrôlent ce que
@code{make} ``voit'' réellement dans le makefile, donc elle @emph{ne
peuvent pas} être utilisées pour contrôler les instructions au moment de
l'exécution.@refill

@node Exemple d'expression conditionnelle, Syntaxe conditionnelle, Les parties conditionnelles, Les parties conditionnelles
@section Example d'une partie conditionnelle

L'exemple suivant d'une directive @dfn{conditional} dit à @code{make}
d'utiliser un ensemble de bibliothèques si la variable @code{CC} est
@samp{gcc} et un autre ensemble de bibliothèque dans le cas contraire.
Ceci fonctionne en contrôlant laquelle des deux lignes d'instructions
sera utilisée pour la règle. Le résultat est que @samp{CC=gcc} comme
argument de @code{make} ne change pas seulement en fonction du
compilateur qui est utilisé, mais aussi des bibliothèques qui sont
liées.

@example
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif
@end example

Cette définition de partie conditionnelle utilise trois
directives@tie{}: une directive @code{ifeq}, une directive @code{else}
et une directive @code{endif}.

La directive @code{ifeq} démarre la partie conditionnelle et spécifie la
condition. Elle contient deux arguments, séparés par une virgule et
entourrés par des parenthèses. La substitution de variable est réalisée
sur les deux arguments et ensuite ils sont comparés. Les lignes du
makefile suivant @code{ifeq} sont suivies si les deux arguments
correspondent@tie{}; sinon elles sont ignorées.

La directive @code{else} fait que les lignes suivantes sont suivies si
la directive conditionnelle précédante a échouée. Dans l'exemple du
dessus, cela signifie que la seconde alternative est utilisée dès que la
première ne l'est pas.  Cette directive @code{else} est optionnelle.

La directive @code{endif} termine la partie conditionnelle. Toute partie
conditionnelle doit terminer par une directive @code{endif}. Le texte
qui suit n'est plus conditionnel.

Comme cet exemple le montre, les parties conditionelles fonctionnent au
niveau textuel@tie{}: les lignes de la partie conditionnelle sont
traitées comme une partie du makefile, ou ignorée, selon la
condition. Ceci explique pourquoi de plus grandes unités syntaxiques du
makefile, comme les règles, peuvent dépasser le début ou la fin d'une
partie conditionnelle.

Quand la variable @code{CC} a la valeur @samp{gcc}, l'exemple ci-dessus
a cet effet@tie{}:

@example
foo: $(objects)
        $(CC) -o foo $(objects) $(libs_for_gcc)
@end example

@noindent
Quand la variable @code{CC} a une autre valeur, l'effet est celui-ci@tie{}:

@example
foo: $(objects)
        $(CC) -o foo $(objects) $(normal_libs)
@end example

Une autre façon d'obtenir un résultat équivalent et de conditionner un
assignement de variable et d'ensuite utiliser la variable sans plus de
condition@tie{}:

@example
libs_for_gcc = -lgnu
normal_libs =

ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif

foo: $(objects)
        $(CC) -o foo $(objects) $(libs)
@end example

@node Syntaxe conditionnelle, Option indicatrice de test, Exemple d'expression conditionnelle, Les parties conditionnelles
@section Syntaxe des expresions conditionnelles
@findex ifdef
@findex ifeq
@findex ifndef
@findex ifneq
@findex else
@findex endif

La syntaxe d'une expression conditionnelle simple sans @code{else} est
la suivante@tie{}:

@example
@var{directive-conditionnelle}
@var{texte-si-vrai}
endif
@end example

@noindent
La partie @var{texte-si-vrai} peut être n'importe quelles lignes de
texte, considérées comme une partie du makefile si la condition est
vraie.  Si la condition est fausse, aucun texte n'est alors utilisé.

La syntaxe d'un expression conditionnelle complexe est la suivante@tie{}:

@example
@var{directive-conditionnelle}
@var{texte-si-vrai}
else
@var{texte-si-faux}
endif
@end example

ou@tie{}::

@example
@var{premère-directive-conditionnelle}
@var{texte-si-la-première-est-vraie}
else @var{seconde-directive-conditionnelle}
@var{texte-si-la-seconde-est-vraie}
else
@var{texte-si-la-première-et-la-seconde-sont-fausses}
endif
@end example

@noindent
Il peut y avoir autant de clause ``@code{else}
@var{directive-conditionnelle}'' que nécessaire.  Une fois qu'une
condition donnée est vraie, @var{texte-si-vrai} est utilisé et aucune
autre clause ne l'est@tie{}; si aucune condition n'est vraie, alors
@var{texte-si-faux} est utilisé.  Les @var{texte-si-vrai} et
@var{texte-si-faux} peuvent avoir autant de lignes qu'on veut.

La syntaxe de @var{directive-conditionnelle} est la même que cette
directive soit simple ou complexe@tie{}; après un @code{else} ou non.
Il y a quatre directives différentes qui testent les différentes
conditions. Voici une table qui les donne@tie{}:

@table @code
@item ifeq (@var{arg1}, @var{arg2})
@itemx ifeq '@var{arg1}' '@var{arg2}'
@itemx ifeq "@var{arg1}" "@var{arg2}"
@itemx ifeq "@var{arg1}" '@var{arg2}'
@itemx ifeq '@var{arg1}' "@var{arg2}"
Développe toutes les références de variables dans @var{arg1} et
@var{arg2} et les compare.  Si elles sont identiques, le @var{texte-si-vrai} est effectif@tie{};
sinon, le @var{texte-si-faux}, s'il y en a un, est effectif.

Souvent vous voulez tester si une variable a une valeur non nulle.
Quand la valeur résulte d'un développement complexe de variables et de
fonctions, les développement que vous considéreriez vides peuvent en
réalité contenir des espaces blancs et donc ne pas être vus comme vides.
Cependant, vous pouvez utiliser la fonction @code{strip}
(@pxref{Fonctions de texte}) pour éviter d'interpréter les espaces
blancs comme des valeurs non vides. Par exemple:

@example
@group
ifeq ($(strip $(foo)),)
@var{texte-si-vide}
endif
@end group
@end example

@noindent
évaluera @var{texte-si-vide} même si l'expansion de @code{$(foo)}
contient des espaces blancs.

@item ifneq (@var{arg1}, @var{arg2})
@itemx ifneq '@var{arg1}' '@var{arg2}'
@itemx ifneq "@var{arg1}" "@var{arg2}"
@itemx ifneq "@var{arg1}" '@var{arg2}'
@itemx ifneq '@var{arg1}' "@var{arg2}"
Développe toutes les références de variables dans @var{arg1} et
@var{arg2} et les compare.  Si elles sont différentes, le @var{texte-si-vrai} est effectif@tie{};
sinon, le @var{texte-si-faux}, s'il y en a un, est effectif.

@item ifdef @var{name-de-variable}
La forme @code{ifdef} prend le @emph{nom} d'une variable comme son argument,
et non la référence à une variable.  Si la valeur de cette variable a
une valeur non vide, le @var{texte-si-vrai} is effectif@tie{}; sinon, le
@var{texte-si-faux}, s'il y en a un, est effectif.  Les variables qui
n'ont jamais été définie ont une valeur vide. Le texte
@var{nom-de-variable} est développé, donc ce peut être une variable ou
une function qui se se développe en un nom de variable.
Par exemple:

@example
bar = true
foo = bar
ifdef $(foo)
frobozz = yes
endif
@end example

La référence de variable @code{$(foo)} est développée, ce qui donne
@code{bar}, qui est considéré être le nom d'une variable.  La variable
@code{bar} n'est pas développée, mais sa valeur est examinée pour
déterminer si elle est non vide.

Notez que @code{ifdef} teste seulement si une variable a une valeur.  Il
ne développe pas la variable pour vérifier si cette valeur est non
vide. En consequence, les tests utilisant @code{ifdef} retournent vrai
pour toutes les définitions excepté celle comme @code{foo =}.  Pour
tester les valeurs non vides, utilisez @w{@code{ifeq ($(foo),)}}.
Par exemple,

@example
bar =
foo = $(bar)
ifdef foo
frobozz = yes
else
frobozz = no
endif
@end example

@noindent
définie @samp{frobozz} à @samp{yes}, alors que@tie{}:

@example
foo =
ifdef foo
frobozz = yes
else
frobozz = no
endif
@end example

@noindent
définie @samp{frobozz} à @samp{no}.

@item ifndef @var{variable-name}
If the variable @var{variable-name} has an empty value, the
@var{text-if-true} is effective; otherwise, the @var{text-if-false}, if any,
is effective.  The rules for expansion and testing of @var{variable-name}
are identical to the @code{ifdef} directive.
@end table

Les espaces supplémentaires sont permis et ignorés au début d'une
directive conditionnelle, mais les tabulations ne sont pas permises. (Si
une ligne commence par une tabulation, elle sera considérée comme
faisant partie d'une instruction pour une règle.@tie{}) À part cela, les
espaces supplémentaires et les tabulations peuvent être insérés sans
avoir d'effet nulle part excepté à l'intérieur du nom de la directive ou
dans un argument. Un commentaire débuttant par @samp{#} peut être mis
en fin de ligne.

Les deux autres directives qui jouent un rôle dans les expressions
conditionnelles sont @code{else} et @code{endif}.  Chacune de ces
directives est écrite en un seul mot, sans argument. Les espaces
supplémentaires ne sont pas permis et ignorés en début de ligne, et les
espaces et tabulation en fin de ligne.  Un commentaire débuttant par
@samp{#} peut être mis en fin de ligne.

Les directives conditionnelles déterminent quelles lignes du makefile
vont être utilisées par @code{make}.  Si la condition est vraie,
@code{make} lit les lignes de @var{texte-si-vrai} comme une partie
intégrante du makefile@tie{}; si la condition est fause, @code{make}
ignore ces lignes complètement.  Ceci suit les unités syntaxiques du
makefile, comme les règles, qui peuvent être coupées en toute sécurité
par le début ou la fin d'une expression conditionnelle.@refill

@code{make} évalue les expressions conditionnelles quand il lit un
makefile. En consequence, vous ne pouvez pas utiliser des variables
automatiques dans les tests des expressions conditionnelles, car elles
ne sont définies que quand les instructions sont exécutées
(@pxref{Les variables automatiques}).

Pour empêcher des confusions intolérables, il n'est pas permis de
commencer une expression conditionnelle dans un makefile pour la
terminer dans un autre. Cependant, vous pouvez écrire une directive
@code{include} à l'intérieur d'une expression conditionnelle, à la
condition que vous n'essayiez pas de terminer l'expression
conditionnelle dans le fichier inclus.


@node Option indicatrice de test, , Syntaxe conditionnelle, Les parties conditionnelles
@section Partie conditionelles testant une option

Vous pouvez écrire une partie conditionnelle qui teste une option
indicatrice de @code{make} comme @samp{-t} en utilisant la variable
@code{MAKEFLAGS} avec la fonction @code{findstring} (@pxref{Fonctions de
texte, , Fonctions pour les substitutions de chaînes et leur analyse}).
Ceci est utile quand la commande @code{touch} ne suffit pas pour faire
apparaitre un fichier comme mis à jour.

La fonction @code{findstring} détermine si une chaîne peut être une
sous-chaîne d'une autre. Si vous voulez tester l'option @samp{-t}, utilisez
@samp{t} comme la première chaîne et la valeur de @code{MAKEFLAGS} comme
l'autre.

Par exemple, voici comment s'arranger pour utiliser @samp{ranlib -t}
pour finir de marquer une archive comme mise à jour@tie{}:

@example
archive.a: @dots{}
ifneq (,$(findstring t,$(MAKEFLAGS)))
        +touch archive.a
        +ranlib -t archive.a
else
        ranlib archive.a
endif
@end example

@noindent
Le préfixe @samp{+} marque ces lignes d'instructions comme
``recursives'' de telle façon qu'elles seront exécutées malgré
l'utilisation de l'option @samp{-t}.  @xref{Récursion,
,Utilisation récursive de @code{make}}.

@node Les fonctions, Exécuter make, Les parties conditionnelles, Top
@chapter Fonctions pour transformer du texte
@cindex Fonctions

Les @dfn{fonctions} permettent de traiter du texte dans le fichier
makefile pour définir les fichiers sur lesquels opérer ou les commandes
à utiliser dans les instructions. Vous utilisez une fonction dans
@dfn{appel de fonction}, dans lequel vous donnez le nom de la fonction
et du texte (les @dfn{arguments}) sur le lequel la fonction va
opérer. Les résultats de l'exécution de la fonction sont substitués dans
le makefile au point d'appel de la fonction, juste comme un variable
pourrait être substituée.

@node Syntaxe des fonctions, Fonctions de texte, Les fonctions, Les fonctions
@section Syntaxe d'un appel de fonction
@cindex @code{$}, dans un appel de fonction
@cindex le signe dollar (@code{$}), dans un appel de fonction
@cindex les arguments des fonctions
@cindex fonctions, syntaxe

Un appel de fonction ressemble au référencement d'une variable. Il peut
apparaître d'importe où où une référence de variable peut être et il se
développe en utilisant les mêmes règles que pour les références de
variables. Un appel de fonction pour ressembler à ceci@tie{}:

@example
$(@var{function} @var{arguments})
@end example

@noindent
ou à ceci :

@example
$@{@var{function} @var{arguments}@}
@end example

Ici @var{function} est un nom de fonction@tie{}; le nom d'une liste
courte de noms qui font partis de @code{make}.  Vous pouvez aussi
principalement créer vos propres fonctions en utilisant la fonction
prédéfinie @code{call}.

@var{arguments} sont les arguments de la fonction.  Ils sont séparés du
nom de la fonction par un ou plusieurs espaces ou caractères de
tabulation et s'il y a plus d'un argument, ils sont séparés par des
virgules. Ces espaces blancs et virgules ne font pas partie de la valeur
de l'argument. Les délimiteurs que vous utilisez pour entourer l'appel
de fonction, que ce soit avec des parenthèses ou des accolades, peuvent
apparaître dans un argument que sous forme de paires@tie{}; les autres
types de délimiteurs peuvent apparaître seuls. Si les arguments
contiennent eux-mêmes d'autres appels de fonctions ou références de
variables, il est plus sage d'utiliser le même genre de délimiteurs pour
toutes les références@tie{}; écrivez @w{@samp{$(subst a,b,$(x))}} et pas
@w{@samp{$(subst a,b,$@{x@})}}.  Ce sera plus clair et aussi parcequ'un
seul type de délimiteur est considéré pour rechercher la fin d'une
référence.

La texte écrit pour chaque argument est executé par substitution de variables
et appels de fonctions pour produire la valeur de l'argument, qui est le
texte sur lequel la fonction va agir. La substitution est faite dans
l'ordre où les arguments apparaissent.

Les virgules et les parenthèse ou accolades sans correspondance ne
peuvent pas rester dans le texte d'un argument tel que@tie{}; les
espaces blancs en début du texte du premier argument ne peuvent pas non
plus rester ainsi dans l'argument. Ces caractères peuvet être mis dans
la valeur de l'argument en utilisant des substitutions de
variables. D'abord vous définisser les variables @code{comma} et @code{space}
dont les valeurs sont des virgules et espaces isolés, ensuite vous les
substituez aux variables dans lesquelles ces caractères sont voulus,
comme ceci@tie{}:

@example
@group
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
# @r{bar is now `a,b,c'.}
@end group
@end example

@noindent
Ici la fonction @code{subst} remplace chaque espace par une virgule dans
la variable @code{foo} en faisant la subtitution sur résultat.


@node Fonctions de texte, Les fonctions de noms de fichier, Syntaxe des fonctions, Les fonctions
@section Fonctions pour les subtitutions de chaînes et analyses
@cindex fonction, pour les textes

Voici quelques fonctions qui opèrent sur les chaînes@tie{}:

@table @code
@item $(subst @var{from},@var{to},@var{text})
@findex subst
Réalise un remplacement des chaînes sur le texte @var{text}@tie{};
chaque occurence de @var{from} est remplacée par @var{to}. Le résultat
est substitué pour un appel de fonction. Par exemple,

@example
$(subst ee,EE,feet on the street)
@end example

donnera la valeur @samp{fEEt on the strEEt}.

@item $(patsubst @var{pattern},@var{replacement},@var{text})
@findex patsubst
Trouve des mots séparés par des espaces dans le @var{text} qui
correspondent au modèle @var{pattern} et les remplace avec
@var{replacement}. Ici le modèle @var{pattern} peut contenir des
@samp{%}, qui vont agir comme des caractères génériques, pour correspondre
à n'importe quel nombre de caractères à l'intérieur d'un mot. Si
@var{replacement} contient aussi un @samp{%}, la @samp{%} est remplacé
par le texte qui correspond ) @samp{%} dans le modèle
@var{pattern}. Seul le premier @samp{%} dans le modèle @var{pattern} et
dans @var{replacement} est traité de cette façon@tie{}; tous les
@samp{%} qui pourraient suivre sont laissés inchangés.@refill

@cindex @code{%}, échappement dans @code{patsubst}
@cindex @code{%}, quoting with @code{\} (backslash)
@cindex @code{\} (backslash), to quote @code{%}
@cindex backslash (@code{\}), to quote @code{%}
@cindex échapper @code{%}, dans @code{patsubst}
Les caractères @samp{%} dans l'invocation des fonctions @code{patsubst}
peuvent être échappés avec des barres obliques inversées (@samp{\}). Les
barres obliques inversées qui sinon échapperaient les caractères
@samp{%} peuvent être échappées avec encore plus de barres obliques. Les
barres obliques inversées qui échappent les caractères @samp{%} ou
d'autres barres obliques sont enlevées du modèle avant qu'il soit
comparé à des noms de fichiers ou qu'il ait eu une subtitution de
radical. Les barres obliques inversées qui ne risquent pas d'échapper des
caractères @samp{%} ne sont pas inquiétées. Par exemple le modèle
@file{the\%weird\\%pattern\\} a le motif @samp{the%weird} qui précède le
caractère @samp{%} opérationnel et le motif @samp{pattern\\} qui
suit. Les barres inversées obliques finales sont laissées sans
substitution car elle ne peuvent pas échapper aucun caractère
@samp{%}.@refill

Les espaces blancs entre les mots sont repliés en un seul caractère
espace@tie{}; ce qui retire les espaces qui trainent en début et en fin
de chaîne.

Par exemple,

@example
$(patsubst %.c,%.o,x.c.c bar.c)
@end example

@noindent
donne la valeur @samp{x.c.o bar.o}.

Les substitutions de références (@pxref{Références de substitution, ,Substitution
References}) sont le moyen le plus simple pour obtenir l'effet de la
fonction
@code{patsubst}@tie{}:

@example
$(@var{var}:@var{pattern}=@var{replacement})
@end example

@noindent
is equivalent to

@example
$(patsubst @var{pattern},@var{replacement},$(@var{var}))
@end example

La deuxième abbréviation simplifie l'une des utilisations les plus communes
de
@code{patsubst}@tie{}: remplacer la suffixe à la fin de noms de fichiers.

@example
$(@var{var}:@var{suffix}=@var{replacement})
@end example

@noindent
est équivalent à

@example
$(patsubst %@var{suffix},%@var{replacement},$(@var{var}))
@end example

@noindent
Par exemple, vous pourriez avoir une liste de fichiers objet@tie{}:

@example
objects = foo.o bar.o baz.o
@end example

@noindent
Pour obtenir la liste des fichiers source correspondant, vous écrivez
simplement@tie{}:

@example
$(objects:.o=.c)
@end example

@noindent
à la place de la forme général@tie{}:

@example
$(patsubst %.o,%.c,$(objects))
@end example

@item $(strip @var{string})
@cindex enlever les espaces blancs
@cindex espace blanc, enlever
@cindex espace, enlèvement
@findex enlèvement
Enlève les espaces blancs en début et en fin d'une chaîne @var{string}
et remplace chaque séquence d'un ou plusieurs caractère espace blanc par
un seul espace. Donc @samp{$(strip a b c )} donne @w{@samp{a b c}}.

La fonction @code{strip} peut être très utile en conjonction avec des
expressions conditionnelles. Quand on compare quelque chose avec des
chaînes vide @samp{} en utilisant @code{ifeq} ou @code{ifneq}, on veut
le plus souvent qu'une chaîne de seulement un espace blancs soit reconnu
(@pxref{Les parties conditionnelles}).

Donc, le moyen suivant pourrait ne pas donner les résultats attendus@tie{}:

@example
.PHONY: all
ifneq   "$(needs_made)" ""
all: $(needs_made)
else
all:;@@echo 'Nothing to make!'
endif
@end example

@noindent
Remplacer une référence de variable @w{@samp{$(needs_made)}} avec l'appel de
fonction @w{@samp{$(strip $(needs_made))}} dans la directive @code{ifneq} la
rendrait plus robuste.@refill

@item $(findstring @var{find},@var{in})
@findex findstring
@cindex chercher dans les chaînes
@cindex trouver des chaînes
@cindex chaînes, chercher
Cherche une occurence de @var{find} dans @var{in}. Si le recherche
aboutit, la valeur est @var{find}@tie{}; sinon, la valeur est vide. Vous
pouvez utiliser cette fonction dans une expression conditionnelle pour
tester la présence de sous-chaînes spécifiques dans une chaîne
donnée. Donc par exemple,

@example
$(findstring a,a b c)
$(findstring a,b c)
@end example

@noindent
produit respectivement les valeurs @samp{a} et @samp{} (la chaîne
vide). @xref{Option indicatrice de test}, pour une application pratique de
@code{findstring}.@refill

@need 750
@findex filter
@cindex filtrer des mots
@cindex mots, filtrer
@item $(filter @var{pattern}@dots{},@var{text})
Retourne tous les mots séparés par des espaces blancs dans le @var{text} qui
@emph{correspondent} aux modèles @var{pattern}, enlevant chaque mots qui
@emph{ne correspondent pas}. Les modèles sont écrits en utilisant @samp{%},
juste comme le modèle utilisé dans fonction @code{patsubst} vu plus haut.@refill

La fonction @code{filter} peut être utilisée pour distinguer différents
types d'éléments dans une liste contenue dans une variable (comme par
exempple pour des noms de fichiers). Par exemple@tie{}:

@example
sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
        cc $(filter %.c %.s,$(sources)) -o foo
@end example

@noindent
dit que @file{foo} dépend de @file{foo.c}, @file{bar.c}, @file{baz.s} et
@file{ugh.h} mais seulement les fichiers @file{foo.c}, @file{bar.c} et
@file{baz.s} devraient être spécifiés dans la commande du compilateur.@refill


@item $(filter-out @var{pattern}@dots{},@var{text})
@findex filtrer en enlever
@cindex filtrer et enlever des mots
@cindex mots, filtrer et enlever
Retourne tous les mots séparés par des espaces blancs dans @var{text}
qui @emph{ne correspondent pas} aux modèles de mots @var{pattern},
enlevant les mots les mots qui @emph{correspondent} à l'un ou plusieurs.
C'est l'exact opposé de la fonction @code{filter}.@refill

Par exemple, si on a@tie{}:

@example
@group
objects=main1.o foo.o main2.o bar.o
mains=main1.o main2.o
@end group
@end example

@noindent
l'instruction suivante génère une liste contenant tous les fichiers
objets qui ne sont pas dans @samp{mains}@tie{}:

@example
$(filter-out $(mains),$(objects))
@end example

@need 1500
@findex sort
@cindex ordonner des words (ndt. sorting)
@item $(sort @var{list})
Ordonne les mots de @var{list} dans l'ordre lexical, en enlevant les
mots dupliqués. La sortie est une liste de mots séparés par un seul
espace. Donc,

@example
$(sort foo bar lose)
@end example

@noindent
retourne la valeur @samp{bar foo lose}.

@cindex enlever les mots dupliqués
@cindex mots dupliqués, enlever
@cindex mots, enlever les duplica
Incidemment, comme @code{sort} enlège les mots dupliqués, vous pouvez
l'utiliser pour cet utsage, même si vous n'avez pas besoin de classer
les mots.

@item $(word @var{n},@var{text})
@findex word
@cindex mot (word), selection
@cindex selectionner un mot
Retourne le @var{n}ième mot de @var{text}.  Les valeurs autorisées de @var{n}
commence à 1.  Si @var{n} est plus grand que le nombre de mots dans @var{text},
la valeur est vide.  Par exemple,

@example
$(word 2, foo bar baz)
@end example

@noindent
retourne @samp{bar}.

@item $(wordlist @var{s},@var{e},@var{text})
@findex wordlist
@cindex words, selecting lists of
@cindex selectionner une liste de mots
Retourne la liste des mots de @var{text} en commençant au mot numéro
@var{s} et en finissant au mot numéro @var{e} (inclusivement).  Les
valeurs autorisées de @var{s} démarrent à 1@tie{}; @var{e} peut démarrer
depuis 0.  Si @var{s} est plus grand que le nombre de mots présents dans
@var{text}, la valeur est vide.  Si @var{e} est plus grand que le nombre
de mots dans @var{text}, les mots sont retournés jusqu'à la fin de
@var{text}.  Si @var{s} est plus grand que @var{e}, rient n'est retourné.
Par exemple,

@example
$(wordlist 2, 3, foo bar baz)
@end example

@noindent
returns @samp{bar baz}.

@item $(words @var{text})
@findex words
@cindex mots, trouver le nombre
Retourne le nombre de mots dans @var{text}.  Donc la dernier mot de
@var{text} est @w{@code{$(word $(words @var{text}),@var{text})}}.@refill

@item $(firstword @var{names}@dots{})
@findex firstword
@cindex mots, extraire le premier
L'argument @var{names} est considéré comme une série de noms, séparés
par des espaces blancs. La valeur retournée est celle du premier nom de
la série. Les mots suivants sont ignorés.

Par exemple,

@example
$(firstword foo bar)
@end example

@noindent
produit la résultat @samp{foo}.  Bien que @code{$(firstword @var{text})} soit
la même chose que  @code{$(word 1,@var{text})}, la fonction
@code{firstword} a été retenue pour sa simplicité.@refill


@item $(lastword @var{names}@dots{})
@findex lastword
@cindex mots, extraire le dernier
L'argument @var{names} est considéré comme une série de noms, séparés
par des espaces blancs. La valeur retournée est celle du dernier nom
dans la série.

Par exemple,

@example
$(lastword foo bar)
@end example

@noindent
produit le résultat @samp{bar}.  Bien que @code{$(lastword @var{text})}
soit la même chose que @code{$(word $(words @var{text}),@var{text})}, la
fonction @code{lastword} a été ajoutée pour sa simplicité et ses
meilleures performances.@refill
@end table

Voici un exemple réaliste d'utilisation de @code{subst} et @code{patsubst}.
Supposez qu'un makefile utilise la variable @code{VPATH} pour spécifier
une liste de répertoire que @code{make} doit examiner pour rechercher
des fichiers pré-requis (@pxref{Recherche générale, , @code{VPATH}
Chemin de recherche pour tous les pré-requis}). Cet exemple montre
comment dire au compilateur C de chercher les fichiers d'en-têtes dans
la même liste de répertoires.@refill

La valeur de @code{VPATH} est une liste de répertoires séparés par des
double points, comme @samp{src:../headers}. D'abord la fonction @code{subst}
est utilisée pour changer les double points en espaces@tie{}:

@example
$(subst :, ,$(VPATH))
@end example

@noindent
Ceci donne @samp{src ../headers}.  Ensuite @code{patsubst} est utilisée
pour transformer chaque nom de répertoire en une option @samp{-I}.
Ceci peut être ajouté à la valeur de la variable @code{CFLAGS}, qui est
passée automatiquement au compilateur C comme ceci@tie{}:

@example
override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
@end example

@noindent
L'effet est d'ajouter le texte @samp{-Isrc -I../headers} à la valeur
définie précédemment de @code{CFLAGS}.  La directive @code{override} est
utilisée pour que la nouvelle valeur soit assignée même si la valeur
précédente de @code{CFLAGS} était spécifiée par un argument de commande
(@pxref{Directive de forçage, , Le directive @code{override}}).


@node Les fonctions de noms de fichier, Fonctions conditionnelles, Fonctions de texte, Les fonctions
@section Les fonctions de noms de fichiers
@cindex fonctions, pour les noms de fichiers
@cindex fonctions pour les noms de fichiers

Plusieur fonctions dont le développement est prédéfini, permettent de
traiter spécifiquement à part les noms de fichiers ou les listes de noms
de fichiers.

Chacune des fonctions qui suivent réalise une transformation spécifique
sur un nom de fichier. L'argument de la fonction est considéré comme une
série de noms de fichiers, séparés par des espaces. (les espaces en
début et en fin de liste sont ignorés.@tie{}) Chaque nom de fichier dans
la série est transformé de la même façon et les résultats sont
concaténés avec un seul caractère espace entre eux.

@table @code
@item $(dir @var{names}@dots{})
@findex dir
@cindex partie nom du répertoire
@cindex nom du fichier, partie nom du répertoire
Extracts the directory-part of each file name in @var{names}.  The
directory-part of the file name is everything up through (and including) the
last slash in it.  If the file name contains no slash, the directory part is
the string @samp{./}.  For example,

@example
$(dir src/foo.c hacks)
@end example

@noindent
produces the result @samp{src/ ./}.

@item $(notdir @var{names}@dots{})
@findex notdir
@cindex nom de fichier, partie qui n'est pas le nom du répertoire
@cindex partie qui n'est pas le nom du répertoire
Extrait tout sauf la partie nom de répertoire de chaque nom de fichier
dans @var{names}.  Si le nom de fichier ne contient aucune barre
oblique, il est laissé inchangé. Sinon, tout jusqu'à la dernière barre
oblique est enlevé.

Un nom de fichier qui finit par une barre oblique devient la chaîne vide.
Ce n'est pas très heureux, car cela veut dire que le résultat n'aura pas
toujours le même nombre de noms de fichier séparés par des espaces
blancs comme en avait l'argument, mais aucune autre alternative valable
n'a été trouvée.

Par exemple,

@example
$(notdir src/foo.c hacks)
@end example

@noindent
produit le résultat @samp{foo.c hacks}.

@item $(suffix @var{names}@dots{})
@findex suffix
@cindex suffixe, fonction pour le trouver
@cindex suffixe du nom du fichier
Extrait le suffixe de chaque nom de fichier dans @var{names}.  Si le
nom de fichier contient un point, le suffixe est tout ce qui démarre
après le dernier point. Sinon le suffixe est une chaîne vide. Ceci veut
souvent dire que le résultat sera vide quand la liste @var{names} ne
l'est pas et si @var{names} contient plusieurs nom de fichiers, le
résultat pourrait contenir moins de noms.

Par exemple,

@example
$(suffix src/foo.c src-1.0/bar.c hacks)
@end example

@noindent
produit le résultat @samp{.c .c}.

@item $(basename @var{names}@dots{})
@findex basename
@cindex base du nom de fichier
@cindex nom de fichier, base du nom
Extrait tout excepté le suffixe pour chaque nom de fichiers dans
@var{names}.  Si le nom de fichier contient un point, la base du nom est
tout jusqu'au dernier point (le  point étant exclus). Les points dans
un répertoire sont ignorés. S'il n'y a pas de point, la base du nom du
fichier est la nom dans son entier. Par exxemple,

@example
$(basename src/foo.c src-1.0/bar hacks)
@end example

@noindent
produit le résultat @samp{src/foo src-1.0/bar hacks}.

@c plural convention with dots (be consistent)
@item $(addsuffix @var{suffix},@var{names}@dots{})
@findex addsuffix
@cindex suffixe, ajouter
@cindex suffixe du nom de fichier, ajouter
L'argument @var{names} est considéré comme un série de noms séparés par
des espaces blancs@tie{}; @var{suffix} est utilisé comme une unité.  La
valeur de @var{suffix} est ajoutée à la fin de chaque nom de fichier
pris individuellement et ces noms de fichiers allongés sont concaténés
avec des espaces blancs entre eux. Par exemple,

@example
$(addsuffix .c,foo bar)
@end example

@noindent
produit le résultat @samp{foo.c bar.c}.

@item $(addprefix @var{prefix},@var{names}@dots{})
@findex addprefix
@cindex préfixe, ajouter
@cindex préfixe de nom de fichier, ajouter
L'argument @var{names} est considéré comme un série de noms séparés par
des espaces blancs@tie{}; @var{prefix} est utilisé comme une unité.  La
valeur de @var{prefix} est ajoutée devant chaque nom de fichier pris
individuellement et ces noms de fichiers allongés sont concaténés avec
des espaces blancs entre eux. Par exemple,

@example
$(addprefix src/,foo bar)
@end example

@noindent
produit le résultat @samp{src/foo src/bar}.

@item $(join @var{list1},@var{list2})
@findex join
@cindex joindre des listes de mots
@cindex mots, joindre des listes
Concatène les deux arguments, mot à mot@tie{}: les deux premiers mots
(un pour chaque argument) concaténés forment le premier mot du résultat,
les deux second mots forment le second mot du résultat, et ainsi de
suite.  Donc le @var{n}ième mot du mot vient du @var{n}ième mot de
chaque argument.  Si l'un des arguments a plus de mots que l'autre, les
mots en plus sont copiés inchangés dans le résultat.

Par exemple, @samp{$(join a b,.c .o)} donne @samp{a.c b.o}.

Les espaces entre les mots dans les listes ne sont pas préservés@tie{};
ils sont remplacés à chaque fois par un espace blanc unique.

Cette fonction peut fusionner les résultats des foncitons @code{dir} et
@code{notdir} pour produire la liste originale des fichers qui ont été
donnés à ces deux fonctions.@refill

@item $(wildcard @var{pattern})
@findex wildcard
@cindex caractère générique, fonction
L'argument @var{pattern} est un modèle de nom de fichier, contenant
typiquement des caractères génériques (comme dans un modèle de nom de
fichier pour le shell).  Le résultat de @code{wildcard} est une liste de
noms de fichier existant et correspondant à ce modèle, séparés par des
espaces @xref{Les caractères génériques, ,Utiliser les caractères
générique dans les noms de fichiers}.

@item $(realpath @var{names}@dots{})
@findex realpath
@cindex realpath
@cindex file name, realpath of
Pour chaque nom de fichier dans @var{names} retourne la nom canonique en
adresse absolue.  Un nom canonique ne contient aucuns composants
@code{.} ou @code{..}, ni aucune répétition de séparateur de noms de
répertoires (@code{/}) ni de liens symboliques.  En cas d'échec, la
chaîne vide est retournée.  Consultez la documentation de
@code{realpath(3)} pour une liste de tout les cas possibles d'échec.

@item $(abspath @var{names}@dots{})
@findex abspath
@cindex nom de chemin absolu (ndt. abspath)
@cindex nom de fichier, nom de chemin absolu
Pour chaque nom de fichier dans @var{names} retourne le nom de chemin
absolu qui ne contient pas de composants @code{.} ou @code{..}, ni
aucune répétition de séparateur de noms de répertoires (@code{/}).
Notez qu'à la différence de la fonction @code{realpath}, la fonction
@code{abspath} ne résout pas les liens symboliques et ne requiert pas
les noms de fichiers fassent référence à un fichier ou un répertoire
existant.  Utilisez la fonction @code{wildcard} pour faire un test
d'existance.
@end table

@node Fonctions conditionnelles, La fonction Foreach, Les fonctions de noms de fichier, Les fonctions
@section Fonctions conditionnelles
@findex if
@cindex développement conditionnel
Il existe trois fonctions donnant des développements conditionnels. Une
caractéristique essentielle de ces fonctions est que tous leurs arguments
ne sont pas développés tout de suite. Seuls les arguments qui ont besoin
de l'être le sont.

@table @code
@item $(if @var{condition},@var{partie-then}[,@var{partie-else}])
@findex if
La fonction @code{if} supporte les développements conditionnels dans un
contexte de fonction (à la différence des expressions conditionnelles des
Makefile de GNU @code{make}, comme @code{ifeq}
(@pxref{Syntaxe conditionnelle, ,Syntaxe des expressions conditionnelles})).

La premier argument, @var{condition}, est d'abord débarassé de tous ses
espaces blancs au début et à la fin, ensuite il est développé.  Si le
résultat est une chaîne non vide, alors la condition est considérée
comme vraie. Si le résultat est une chaîne vide, la condition est
considérée comme fausse.

Si la condition est vraie, alors le second argument, @var{partie-then},
est évaluée and elle est utilisée comme le résultat de la fonction
@code{if} toute entière.

Si la condition est fausse, alors le troisième argument,
@var{partie-else} est évalué et devient le résultat de la fonction
@code{if}.  S'il n'y a pas de troisième argument, la fonction @code{if}
ne fait que retourner une chaîne vide.

Notez que seules l'une des parties est évaluée, soit la partie
@var{partie-then}, soit la partie @var{partie-else}, mais jamais les
deux à la fois.  Donc, chacune peut contenir des effets de bord (comme
des appels de fonction @code{shell} etc.)

@item $(or @var{condition1}[,@var{condition2}[,@var{condition3}@dots{}]])
@findex or
La fonction @code{or} est une opération OR à ``court-circuit''.  Chaque
argument est développé dans l'ordre.  Si un argument est développé en un
chaîne non vide, l'exécution s'arrête et le résultat du développement
est cette chaîne. Si après que tous les arguments aient été développés,
tous sont faux (c'est à dire des chaînes vide), alors le résultat du
développment est la chaîne vide.

@item $(and @var{condition1}[,@var{condition2}[,@var{condition3}@dots{}]])
@findex and
La condition @code{and} est une opération AND à ``court-circuit''. Chaque
argument est développé dans l'ordre. Si un argument est développé en une
chaîne vide, l'exécution s'arrête et le résultat du développement est la
chaîne vide. Si tous les arguments se développent en des chaînes non
vides, alors le résultat du développement est le dernier argument.

@end table


@node La fonction Foreach, La fonction File, Fonctions conditionnelles, Les fonctions
@section La fonction @code{foreach}
@findex foreach
@cindex mots, itérer

La fonction @code{foreach} est très différente des autres. Elle permet à
une partie de texte d'être ré-utilisée, chaque fois en lui faisant subir
une substitution de texte différente.  Elle ressemble à la commande
@code{for} dans le shell @code{sh} et à la commande @code{foreach} dans
le C-shell @code{csh}.

La syntaxe de la fonction @code{foreach} est@tie{}:

@example
$(foreach @var{var},@var{liste},@var{texte})
@end example

@noindent
Les deux premiers arguments, @var{var} et @var{liste} dont développés en
tout premiers@tie{}; notez que le dernier argument, @var{texte}, lui,
n'est @strong{pas} développé en même temps. Pour chaque mot de la
@var{liste} développée, la variable nommée par @var{var} se définit sur
ce mot et @var{texte} est développé.  On présume que @var{texte}
contient des références à cette variable, de telle manière que son
développement soit différent à chaque fois.

Le résultat est que le @var{texte} est développé autant de fois qu'il y a
de mots séparés par des espaces blancs dans la @var{liste}.  Les
développements multiples de @var{texte} sont concaténés, avec des espaces
entre eux pour donner le résultat de @code{foreach}.

Cet exemple simple définit la variable @samp{files} sur la liste de tous
les fichiers des répertoires donnés dans la liste @samp{dirs}:

@example
dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
@end example

Ici @var{texte} est @samp{$(wildcard $(dir)/*)}.  La première itération
trouve la valeur @samp{a} pour @code{dir} et elle produit donc le même
résultat qu'aurait donné @samp{$(wildcard a/*)}@tie{}; la seconde
itération produit le résultat qu'aurait donné @samp{$(wildcard b/*)}@tie{};
et la troisième le résultat de @samp{$(wildcard c/*)}.

Cet exemple a la même résultat (excepté pour la définition de
@samp{dirs}) que l'exemple suivant@tie{}:

@example
files := $(wildcard a/* b/* c/* d/*)
@end example

Quand @var{texte} est compliqué, vous pouvez améliorer la lisibilité en
lui donnant un nom avec une variable supplémentaire@tie{}:

@example
find_files = $(wildcard $(dir)/*)
dirs := a b c d
files := $(foreach dir,$(dirs),$(find_files))
@end example

@noindent
Ici nous avons utilisé la variable @code{find_files} de cette
façon. Nous utilisons l'assignation @samp{=} pour définir une variable
développée récursivement, de telle manière que sa valeur contienne un
appel de fonction effectif, qui se re-développe sous le control de
@code{foreach}@tie{}; a variable dévoloppé de manière unique ne le
ferait pas, car @code{wildcard} serait appelé seulement une seule fois
au moment de la définition de @code{find_files}.

La fonction @code{foreach} n'a aucun effet permanent sur la variable
@var{var}@tie{}; sa valeur et sa catégorie après l'appel de la fonction
@code{foreach} reste le même qu'avant l'appel.  Les autres valeurs qui
sont prises de la @var{liste} sont effectives seulement temporairement,
durant l'exécution de @code{foreach}.  La variable @var{var} est une
variable développée de manière unique pendant l'exécution de
@code{foreach}.  Si @var{var} était défini avant l'appel de la fonction
@code{foreach} , elle sera indéfinie après l'appel.
@xref{Deux catégories de variables, ,Les deux versions des variables}.@refill

Vous devez faire attention quand vous utilisez des expressions complexes
de variables qui résultent en des noms de variable, car beaucoup de choses
étranges sont des noms de variables valables, mais probablement pas ce à
quoi vous vous attendez. Par exemple,

@smallexample
files := $(foreach Esta-escrito-en-espanol!,b c ch,$(find_files))
@end smallexample

@noindent
peut être utile si la valeur de @code{find_files} référence la variable
dont le nom est @samp{Esta-escrito-en-espanol!} (es un nombre bastante largo,
no?), mais il doit plutôt s'agir d'une erreur.


@node La fonction File, La fonction Call, La fonction Foreach, Les fonctions
@section La fonction @code{file}
@findex file
@cindex écrire sur une fichier
@cindex fichier, écrire sur
@cindex lire un fichier
@cindex fichier, lire

La fonction @code{file} permet à un makefile d'écrire ou de lire un
fichier. Deux modes d'écriture sont permis@tie{}: remplacer là ou le
texte est écrit au début du fichier et tout contenu est alors
perdu, et ajouter, où le texte est écrite à la fin du fichier,
ce qui préserve le contenu existant.  Dans les deux cas, le fichier est
crée s'il n'existe pas. C'est une erreur fatale si le fichier ne peut
pas être ouvert pour l'écriture ou si l'opération d'écriture échoue. La
fonction @code{file} se développe en une chaîne vide quand elle écrit
dans un fichier.

Quand on lit dans un fichier, la fonction @code{file} se développe dans
le contenu du fichier lu tel que (ndt. verbatim), excepté que la le
caractère final de nouvelle ligne (s'il y en a un) sera retiré.  Essayer
de lire un fichier non existant se développe en une chaîne vide.

La syntaxe de la fonction @code{file} est@tie{}:

@example
$(file @var{op} @var{nomfichier}[,@var{texte}])
@end example

Quand la fonction @code{file} est évaluée tous ses arguments sont
d'abord développés, le fichier indiqué par @var{nomfichier} est alors
développé dans le mode décrit par @var{op}.

L'opérateur @var{op} peut être @code{>} pour indiquer que le contenu du
fichier va être remplacé par le nouveau contenu, @code{>>} pour indiquer
qu'on ajouter au contenu actuel du fichier, ou @code{<} pour indiquer
que le contenu du fichier va être lu.  L'argument @var{nomfichier}
spécifie le fichier dans lequel écrire ou à lire. Il peut y avoir
optionnellement des espaces blancs entre l'opérateur et le nom de
fichier.

Quand on lit des fichiers, c'est une erreur de donner la valeur
@var{texte}.

Quand on écrit des fichiers, l'argument @var{texte} est ce qui va être écrit dans
le fichier. Si @var{text} ne se termine pas déjà par un caractère de
nouvelle ligne, ce caractère y sera ajouté (même si @var{text} est la
chaîne vide).  Si l'argument @var{texte} n'est pas donné du tout, rien
ne sera écrit.

Par exemple, la fonction @code{file} est utile si votre système de
compilation est une limite sur la taille des ligne de commande et vos
instructions exécutent une commande qui accepte aussi des arguments
venant d'un fichier. Plusieurs commandes utilisent la convention qu'un
argument préfixé avec un @code{@@} spécifie un fichier contenant plus
d'arguments.  Vous pouvez alors écrire vos instructions de cette
façon@tie{}:

@example
@group
program: $(OBJECTS)
        $(file >$@@.in,$^)
        $(CMD) $(CMDFLAGS) @@$@@.in
        @@rm $@@.in
@end group
@end example

Si la commande demande que chaque argument soit sur une ligne séparée du
fichier d'entrée, vous pourriez écrire une recette comme celle-ci@tie{}:

@example
@group
program: $(OBJECTS)
        $(file >$@@.in) $(foreach O,$^,$(file >>$@@.in,$O))
        $(CMD) $(CMDFLAGS) @@$@@.in
        @@rm $@@.in
@end group
@end example

@node La fonction Call, Fonction Value, La fonction File, Les fonctions
@section La fonction @code{call}
@findex call
@cindex fonctions, définie par l'utilisateur
@cindex fonctions définies par l'utilisateur

La fonction @code{call} est unique en ce qu'elle peut être utilisée pour
créer de nouvelles fonctions paramétrées. Vous pouvez une expression
complexe comme la valeur d'une variable, ensuite l'utilisation de
@code{call} la développera avec différentes valeurs.

La syntaxe de la fonction @code{call} est@tie{}:

@example
$(call @var{variable},@var{param},@var{param},@dots{})
@end example

Quand @code{make} développe cette fonction, elle assigne chaque
@var{param} à une variable temporaire @code{$(1)}, @code{$(2)}, etc.  La
variable @code{$(0)} contiendra @var{variable}.  Il n'y a pas de nombre
maximum de paramètres arguments.  Il n'y a pas non plus de minimum, mais
cela ne fait pas de sense d'utiliser @code{call} sans paramètre.

Ensuite la @var{variable} est développée comme une variable @code{make}
dans le context de ces assignements temporaires.  Donc, toute référence
à @code{$(1)} dans la valeur de @var{variable} se résoudra sur le
premier @var{param} à l'invocation de @code{call}.

Notez que la @var{variable} est le @emph{nom} de la variable, non une
@emph{référence} à cette variable.  C'est pourquoi, vous ne devriez pas
utiliser de @samp{$} ou de parenthèses normalement en l'écrivant.  (Vous
pouvez, cependant, utiliser une référence de variable dans le nom si
vous voulez que ce nom ne soit pas une constante.)

Si la @var{variable} est le nom d'une fonction prédéfinie, les
fonctions prédéfinies sont toujours exécutées (même si une variable
@code{make} avec ce nom existe aussi).

La fonction @code{call} développe les arguments @var{param} avant
de les assigner à des variables temporaires. Ceci veut dire que les
valeurs de @var{variable} contenant des références à des fonctions
prédéfinies et qui ont des règles de développement particulières
pourrait ne pas donner ce que vous attendiez.

Quelques exemples pourront éclaircir le sujet.

Cette macro renverse simplement ses arguments:

@smallexample
reverse = $(2) $(1)

foo = $(call reverse,a,b)
@end smallexample

@noindent
Ici  @var{foo} contiendra @samp{b a}.

L'exemple qui suit est une plus intéressant@tie{}: il définit une macro
pour rechercher la première instance d'un programme dans le
@code{PATH}@tie{}:

@smallexample
pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

LS := $(call pathsearch,ls)
@end smallexample

@noindent
Maintenant la variable LS contient @code{/bin/ls} ou similaire.

La fonction @code{call} peut être imbriquée. Chaque invocation récursive
obtiendra ses propres variables locales pour @code{$(1)}, etc.@: ceci
masque les valeurs du plus haut niveau @code{call}.  Par exemple, voici
une implementation d'un fonction @dfn{map}@tie{}:

@smallexample
map = $(foreach a,$(2),$(call $(1),$(a)))
@end smallexample

Maintenant vous pouvez @var{map}per une fonction qui normalement ne
prend qu'un seul argument, comme @code{origin}, pour qu'elle accepte des
valeurs multiplese en une seule étape@tie{}:

@smallexample
o = $(call map,origin,o map MAKE)
@end smallexample

et finir avec @var{o} contenant quelque chose comme @samp{file file default}.

Au final, une mise en garde@tie{}: faite attention quand vous ajoutez
des espaces blancs aux arguments de @code{call}.  Comme avec les autres
fonctions, tout espace blanc contenu dans le second arguments et les
suivants est conservé@tie{}; ce qui peut donner des effets étranges.  Il
est généralement plus sûr d'enlever les espaces blancs en surplus en
début et en fin de chaîne quand on les donne comme paramètre à
@code{call}.

@node Fonction Value, Fonction Eval, La fonction Call, Les fonctions
@comment  node-name,  next,  previous,  up
@section La fonction @code{value}
@findex valeur
@cindex variables, valeur non développée

La fonction @code{value} vous donne une façon d'utiliser la valeur d'une
variable @emph{sans avoir} à la développer. Notez cependant que ceci ne
défait pas les développements qui peuvent avoir déjà eu lieu@tie{}; par
exemple si vous créez une variable développée de manière unique, sa
valeur sera développée pendant sa définition@tie{}; dans ce cas, la
fonction @code{value} retournera le même résultat qu'utiliser la
variable directement.

La syntaxe de la fonction @code{value} est@tie{}:

@example
$(value @var{variable})
@end example

Notez que @var{variable} est le @emph{nom} de la variable et non une
@emph{référence} à cette variable.  C'est pourquoi vous ne devriez pas
utiliser normalement un @samp{$} ou des parenthèses quand vous
l'écrivez.  (Vous pouvez cependant utiliser une référence de variable 
dans le nom, si vous voulez que le nom ne soit pas une constante.)

Le résultat de cette fonction est une chaîne contenant la valeur de la
@var{variable} sans qu'il y ait eu de développement. Par exemple, dans
ce makefile:

@example
@group
FOO = $PATH

all:
        @@echo $(FOO)
        @@echo $(value FOO)
@end group
@end example

@noindent
La première ligne renvoyée serait @code{ATH}, car ``$P'' serait
développé comme une variable @code{make}, alors que la deuxième ligne
retournée serait la valeur courante de votre variable d'environnement
@code{$PATH}, car la fonction @code{value} évite le développement.

La fonction @code{value} est utilisée le plus souvent avec la fonction @code{eval} (@pxref{Fonction Eval}).

@node Fonction Eval, La fonction origin, Fonction Value, Les fonctions
@comment  node-name,  next,  previous,  up
@section La fonction @code{eval}
@findex eval
@cindex evaluating makefile syntax
@cindex makefile syntax, evaluating

La fonction @code{eval} est très spéciale@tie{}: elle vous permet de
définir de nouvelles constructions de makefile, qui ne sont pas des
constantes@tie{}; qui sont le resultat de l'évaluation d'autres
variables et de fonctions.  L'argument de la fonction @code{eval}
est développé, et les résultats de ce développement sont analysés comme
une syntaxe de makefile.  Les résultats développés peuvent définir de
nouvelles variables @code{make}, des cibles, des règles implicites ou
explicites, etc.

Le résultat de la fonction @code{eval} est toujours une chaîne
vide@tie{}; donc, il peut être placé virtuellement partout dans le
makefile sans causer d'erreur de syntaxe.

Il est important de réaliser que l'argument de @code{eval} est développé
@emph{deux fois}@tie{}; d'abord par la fonction @code{eval}, ensuite les
résultats de ce développement sont développés de nouveau quand ils sont
analysés comme une syntaxe de makefile. Ceci signifie que vous pouvez
avoir à faire un second niveau d'échappement pour les caractères ``$''
en utilisant @code{eval}.  La fonction @code{value} (@pxref{Fonction
Value}) est parfois utile dans ces situations, pour circonvenir les
développements non souhaités.

Voici un exemple qui montre comment @code{eval} peut être utilisé@tie{};
cet exemple combine un certain nombre de concepts et d'autres fonctions.
Bien qu'il puisse paraitre excessivement compliqué d'utiliser
@code{eval} dans cet exemple, plutôt que d'écrire simplement les règles,
considérez deux choses@tie{}: premièremet, la définition d'un modèle (dans
@code{PROGRAM_template}) pourrait avoir besoin d'être beaucoup plus
complexe qu'ici@tie{}; deuxièmement, vous pourriez mettre la partie
complexe et ``générique'' de cet exemple dans un autre makefile, puis
l'inclure dans tous les makefiles individuels.  Maintenant vos makefiles
individuels deviennent simple et direct.

@example
@group
PROGRAMS    = server client

server_OBJS = server.o server_priv.o server_access.o
server_LIBS = priv protocol

client_OBJS = client.o client_api.o client_mem.o
client_LIBS = protocol

# Everything after this is generic

.PHONY: all
all: $(PROGRAMS)

define PROGRAM_template =
 $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
 ALL_OBJS   += $$($(1)_OBJS)
 endef

$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))

$(PROGRAMS):
        $(LINK.o) $^ $(LDLIBS) -o $@@

clean:
        rm -f $(ALL_OBJS) $(PROGRAMS)
@end group
@end example

@node La fonction origin, La fonction Flavor, Fonction Eval, Les fonctions
@section La fonction @code{origin}
@findex origin
@cindex variables, origine
@cindex origines des variables

La fonction @code{origin} est différente de la plupart des autres
fonctions par le fait qu'elle n'opère pas sur les valeurs des
variables@tie{}; elle nous donne une information @emph{sur}
une variable. Elle donne spécifiquement d'où vient la variable.

La syntaxe de la fonction @code{origin} est@tie{}:

@example
$(origin @var{variable})
@end example

Notez que @var{variable} est le @emph{nom} de la variable sur laquelle
on enquête et non un @emph{référence} à cette variable.  C'est pourquoi,
vous ne devriez pas utiliser de @samp{$} ou parenthèses dedans en
l'écrivant.  (Vous pouvez, cependant, utiliser une référence de variable
dans le nom si vous voulez que le nom ne soit pas une constante.)

Le résultat de cette fonction est une chaîne qui dit comment la 
@var{variable} a été définie@tie{}:

@table @samp
@item undefined

si la @var{variable} n'a jamais été définie.

@item default

si la @var{variable} a une définition par défaut, comme cela est usuel
avec @code{CC} et les programmes équivalents.  @xref{Les variables
implicites, ,Variables utilisées par les règles implicites}.  Notez que
si vous redéfinissez une variable par défaut, la fonction @code{origin}
retournera l'origine de la dernière définition.

@item environment

si la @var{variable} a été héritée de l'environnement donné à @code{make}.

@item environment override

si @var{variable} a été héritée de l'environnement donné à @code{make},
et qu'elle remplace une définition pour la @var{variable} faite dans le
makefile comme résultat de l'option @w{@samp{-e}} (@pxref{Résumé des
options, ,Résumé des options}).@refill

@item file

si la @var{variable} a été définie dans un makefile.

@item command line

si la @var{variable} a été définie sur la ligne de commande.

@item override

si la @var{variable} a été définie avec une directive @code{override}
dans un makefile (@pxref{Directive de forçage, ,La directive
@code{override}}).

@item automatic

si la @var{variable} est une variable automatique définie par
l'exécution d'une instruction pour chaque règle (@pxref{Les variables
automatiques}).
@end table

Cette information est basiquement utile (autre que pour votre curiosité)
pour déterminer si vous voulez croire en la valeur d'une variable. Par
exemple, supposez que vous ayez un makefile @file{foo}, qui inclut un
autre makefile @file{bar}. Vous voulez qu'une variable @code{bletch}
soit définie dans @file{bar} si vous exécutez la commande @w{@samp{make
-f bar}}, même si l'environnement contient une définition de
@code{bletch}. Cependant, si @file{foo} définit @code{bletch} avant
d'inclure @file{bar}, vous ne voulez pas remplacer cette définition.
Ceci peut être fait en utilisant une directive @code{override} dans
@file{foo}, donnant cette définition de préséance sur la dernière définition
dans @file{bar}@tie{}; hélas, la directive @code{override} remplacerait
aussi toute définition faite en ligne de commande. Donc, @file{bar}
pourrait inclure@tie{}:@refill

@example
@group
ifdef bletch
ifeq "$(origin bletch)" "environment"
bletch = barf, gag, etc.
endif
endif
@end group
@end example

@noindent
Si @code{bletch} a été définie par l'environnement, ceci la redéfinira.

Si vous voulez remplacer la définition précédante de @code{bletch} si
elle vient de l'environnement, même avec l'option @samp{-e}, vous
pourriez écrire à la place@tie{}:

@example
@group
ifneq "$(findstring environment,$(origin bletch))" ""
bletch = barf, gag, etc.
endif
@end group
@end example

Ici la redéfinition s'effectue si @samp{$(origin bletch)} retourne
@samp{environment} ou @samp{environment override}.  @xref{Fonctions de
texte, , Fonctions pour effectuer des substitutions dans les chaînes et
les analyser}.

@node La fonction Flavor, Les fonctions de contrôle de Make, La fonction origin, Les fonctions
@section La fonction @code{flavor}
@findex flavor
@cindex variables, catégorie (``flavor'')
@cindex catégorie (``flavor'') de variable

La fonction @code{flavor}, comme la fonction @code{origin} n'opère pas
sur les valeurs des variables, mais dit plutôt quelque chose @emph{sur}
la variable.  Elle donne spécifiquement la catégorie (ndt. ``flavor'')
d'une variable (@pxref{Deux catégories de variables, ,Les deux versions des variables}).

La syntaxe de la fonction @code{flavor} est@tie{}:

@example
$(flavor @var{variable})
@end example

Notez que @var{variable} est le @emph{nom} de la variable sur laquelle
on enqête, et non la @emph{réference} à cette variable.  Donc vous ne
devriez pas utiliser normalement un @samp{$} ou des parenthèses en
l'écrivant.  (Vous pouvez, cependant, utiliser une référence de variable
dans le nom, si vous voulez que le nom ne soit pas une constante.)

Les résultat de cette fonction est une chaîne qui identifie la catégorie
de la variable @var{variable}:

@table @samp
@item undefined

si la @var{variable} la variable n'a jamais été définie.

@item recursive

si la @var{variable} est développée récursivement.

@item simple

so la @var{variable} est développée de manière unique.

@end table

@node Les fonctions de contrôle de Make, La fonction shell, La fonction Flavor, Les fonctions
@section Fonctions de contrôle de Make
@cindex fonctions, pour contrôler make
@cindex contrôler make

Ces fonctions contrôlent comment @code{make} est exécuté. Généralement,
elles sont utilisées pour donner de l'information aux utilisateurs du
makefile ou pour arrêter @code{make} si un certain type d'erreur
d'environnement sont détecté.

@table @code
@item $(error @var{texte}@dots{})
@findex error
@cindex erreur, arrêter sur
@cindex arrêter make
Génère une erreur fatale avec le message @var{texte}. Notez que l'erreur
est générée à chaque fois que cette fonction est évaluée. Donc, si vous
la mettez dans une règle ou sur la partie droite d'une assignation
récursive de variable, elle ne sera pas exécutée ensuite. Le @var{texte}
sera développé avant que l'erreur ne soit générée.

Par exemple,

@example
ifdef ERROR1
$(error error is $(ERROR1))
endif
@end example

@noindent
génèrera une erreur fatale pendant la lecture du makefile si la variable
@code{make} @code{ERROR1} est définie.  Ou,

@example
ERR = $(error found an error!)

.PHONY: err
err: ; $(ERR)
@end example

@noindent
génèrera une erreur fatale quand @code{make} est exécuté, si la cible
@code{err} est invoquée.

@item $(warning @var{texte}@dots{})
@findex warning
@cindex avertissement (warnings), renvoyer
@cindex renvoyer des avertissements pour l'utilisateur
Cette fonction agit comme la fonction @code{error} vue plus haut, sauf
que  @code{make} ne s'interrompt pas. À la place, @var{texte} est
développé et le résultat est renvoyé, mais l'exécution du makefile continue.

La résultat du développement de cette fonction est la chaîne vide.

@item $(info @var{text}@dots{})
@findex info
@cindex renvoyer des messages
Cette fonction ne fait rien de plus que renvoyer son ou ses arguments
(développés) sur la sortie standard. Le nom du makefile ou le numéro de
ligne sont ajoutés. Le résultat du développement de cette fonction est
une chaîne vide. 
@end table

@node La fonction shell, La fonction Guile, Les fonctions de contrôle de Make, Les fonctions
@section La fonction @code{shell}
@findex shell
@cindex développement de commande
@cindex guillemet penchéebackquotes
@cindex commande shell, fonction pour

La fonction @code{shell} est différente de toutes les autres fonctions à
part la fonction @code{wildcard} (@pxref{La fonction Wildcard, ,La fonction
@code{wildcard}}) par le fait qu'elle communique avec le monde à
l'extérieur de @code{make}.

La fonction @code{shell} effectue la même fonction que les guillemets
penchées (@samp{`}) le font dans la plupart des shells@tie{}: elle
@dfn{développe des commandes}.  Ceci signifie qu'elle prend comme
argument une commande shell et évalue le retour de cette commande. La
seule transformation que @code{make} effectue sur le résultat est de
convertir chaque caractère de nouvelle ligne (ou la paire retour-chariot
/ nouvelle-ligne) en un seul caractère espace.  S'il y a en début ou en
fin de chaîne des espaces, des (retours chariot et des) nouvelles
lignes, ils seront simplement enlevés.@refill

L'exécution d'une commande appelée par la fonction @code{shell} est
réalisé quand de le développement de la fonction est effectué
(@pxref{Lire les Makefiles, ,Comment @code{make} lit un Makefile}).
Comme cette fonction implique le déploiement d'un nouveau shell, vous
devriez considérer attentivement les implications en terme de
performance d'utiliser cette fonction @code{shell} à l'intérieur de
variable développées récursivement vs.@: les variables développées de
manière unique (@pxref{Deux catégories de variables, ,Les deux
catégories de variables}).

@vindex .SHELLSTATUS
Après la fonction @code{shell} ou qu'un opérateur d'assignement
@samp{!=} ait été utilisé, son status de sortie est placé dans la
variable @code{.SHELLSTATUS}.

Voici quelques exemple d'utilisation de la fonction @code{shell}@tie{}:

@example
contents := $(shell cat foo)
@end example

@noindent
définie @code{contents} comme le contenu du fichier @file{foo}, avec un espace
(plutôt qu'une nouvelle ligne) séparant chaque ligne.

@example
files := $(shell echo *.c)
@end example

@noindent
définit @code{files} comme le développement de @samp{*.c}.  Sauf si
@code{make} a utilisé un shell très étrange, ceci a le même résultat que
@w{@samp{$(wildcard *.c)}} (tant qu'au moins un fichier @samp{.c}
existe).@refill


@node La fonction Guile, , La fonction shell, Les fonctions
@section La fonction @code{guile}
@findex guile
@cindex Guile

Si GNU @code{make} a été compilé avec un support de GNU Guile comme un
language d'extension intégré, alors la fonction @code{guile} sera
disponible. La fonction @code{guile} prend un argument, qui est d'abord
développé par @code{make} de la manière habituelle, puis est passé à
l'évaluateur GNU Guile. Le résultat de cette évaluation est converti en
une chaîne et est utilisé comme le développement de la fonction
@code{guile} dans le makefile.  Voir @ref{Intégration de Guile,
,Intégration de GNU Guile} pour plus de détail sur l'écriture
d'extensions à @code{make} en Guile.

Vous pouvez déterminer si le support de GNU Guile est disponible en
vérifiant si mot @var{guile} est présent dans la variable
@code{.FEATURES}.

@node Exécuter make, Les règles implicites, Les fonctions, Top
@chapter Comment exécuter @code{make}

Un makefile, qui dit comment recompiler un programme peut être utilisé
de plus d'une façon. L'utilisation la plus simple est de recompiler tous
les fichiers qui ne sont plus à jour. Normalement, les makefiles sont
écrits de telle façon que vous n'ayez qu'à exécuter @code{make} sans
arguments et ils font alors juste cela.

Mais vous pourriez vouloir mettre à jour seulement certains des
fichiers@tie{}; vous pourriez vouloir utiliser un autre compilateur ou
d'autres options de compilation@tie{}; vous pourriez vouloir juste
retrouver quels sont les fichiers, qui ne sont plus à jour sans les
modifier.

En donnant des arguments quand vous exécutez @code{make}, vous pouvez
faire toutes ces choses et bien d'autres encore.

@cindex status de sortie de make
Le status de sortie de @code{make} est toujours l'une des trois valeurs@tie{}:
@table @code
@item 0
Le status de sortie est zéro si @code{make} a fonctionné sans erreur.
@item 2
Le status de sortie est deux si @code{make} a rencontré une ou plusieurs
erreurs. Il renvoiera les messages décrivant ces erreurs.
@item 1
Le status de sortie est un si vous utilisez l'option @samp{-q} et que @code{make}
détermine que certaines cibles ne sont pas déjà à jour.  @xref{À la place
d'une exécution, À la place d'exécuter les instructions}.
@end table

@node Les arguments d'un Makefile, Objectifs, Exécuter make, Exécuter make
@section Arguments pour spécifier le Makefile
@cindex @code{--file}
@cindex @code{--makefile}
@cindex @code{-f}

La façon de spécifier le nom du makefile est avec l'option @samp{-f} ou
@samp{--file} (@samp{--makefile} marche aussi).  Par exemple, @samp{-f
altmake} dit d'utiliser le fichier @file{altmake} comme makefile.

Si fous utilisez l'option @samp{-f} plusieurs fois et faites suivre
chaque @samp{-f} par un argument, tous les fichiers spécifiés sont
utilisés conjointement comme makefiles.

Si vous n'utilisez par l'option @samp{-f} ou @samp{--file}, le
comportement par défaut est d'utiliser @file{GNUmakefile},
@file{makefile}, et @file{Makefile}, dans cet ordre et d'utiliser le
premier de ces trois qui existe ou peut être fabriqué (@pxref{Les Makefiles,
,Écrire des Makefiles}).@refill


@node Objectifs, À la place d'une exécution, Les arguments d'un Makefile, Exécuter make
@section Arguments pour spécifier les objectifs
@cindex objectif, comment le spécifier

Les @dfn{objectifs} sont les cibles que @code{make} doit essayer de
mettre à jour ultimement. Les autres cibles sont aussi mises à jour, si
elles apparaissent comme pré-requis de l'objectif ou pré-requis d'un
pré-requis de l'objectif et ainsi de suite.

Par défault l'objectif de la première cible est le makefile (sans
compter les cibles qui commencent par un point).  c'est pourquoi, les
makefiles sont normalement écrits de telle manière que la première cible
soit la compilation du programme dans son entier ou les programmes
qu'ils décrivent.  Si la première règle d'un makefile a plusieurs
cibles, seule la première cible dans le règle devient l'objectif par
défaut et non la liste complète. Vous pouvez gérer la sélection de
l'objectif par défaut depuis votre makefile en utilisant la variable
@code{.DEFAULT_GOAL} (@pxref{Variables spéciales, , Autres variables
spéciales}).

Vous pouvez aussi spécifier un objectif différent ou des objectif avec
des arguments entrés en ligne de commande pour @code{make}.  Utilisez le
nom de l'objectif comme un argument.  Si vous spécifiez plusieurs
objectifs, @code{make} exécutera chacun d'entre eux, chacun à leur tour
et dans l'ordre où vous les avez nommés.

Toute cible dans le makefile peut être spécifiée comme un objectif
(excepté si elle démarre avec @samp{-} ou contient un @samp{=}, dans ce
case, elle sera analysée respectivement comme une option ou comme une
défintion de variable). Même des cibles non présentes dans le makefile
peuvent être spécifiée, si @code{make} peut retrouver les règles
implicites qui disent comme les fabriquer.

@vindex MAKECMDGOALS
@code{Make} définira la variable spéciale @code{MAKECMDGOALS} dans la
liste des objectifs que vous spécifiez sur la ligne de commande.  Si
aucun objectif n'a été donné sur la ligne de commande, cette variable
est vide. Notez que cette variable ne devrait être utilisée que dans des
circonstances particulières.

Un exemple d'usage approprié est d'éviter d'inclure des fichiers
@file{.d} pour la règle de nettoyage @code{clean} (@pxref{Pré-requis
automatiques}), de telle façon que @code{make} ne les crééra pas pour
simplement les enlever directement après de nouveau@tie{}:@refill

@example
@group
sources = foo.c bar.c

ifneq ($(MAKECMDGOALS),clean)
include $(sources:.c=.d)
endif
@end group
@end example

L'une des utilisations de la spécification d'un objectif est pour le cas
ou vous vouliez compiler uniquement une partie du programme ou seulement
un parmis plusieurs programmes. Spécifiez comme un objectif, chaque
fichier que vous voulez refaire. Par exemple, considérez un répertoire
contenant plusieurs programmes, avec un makefile qui commence comme
ceci@tie{}:

@example
.PHONY: all
all: size nm ld ar as
@end example

Si vous êtes en train de travailler sur le programme @code{size}, vous
pourriez vouloir écrire @w{@samp{make size}} de telle façon que seuls
les fichiers de ce programme soit recompilés.

Une autre utilisation de la spécification d'un objectif est de compiler
les fichiers qui ne le sont pas normalement. Par exemple, il peut y
avoir un fichier pour les sorties de mises au point ou une version du
programme, qui est compilée spécialement pour les tests, qui a une règle
dans le makefile mais qui n'est le pré-requis d'aucun objectif par défaut.

Une autre utilisation de la spécification d'un objectif est d'exécuter
l'instruction associée à une cible fictive (@pxref{Les cibles fictives}) ou
les cibles vides (@pxref{Les cibles vides, ,Les fichiers cibles vide pour
enregistrer l'occurence d'un évènement}).  Beaucoup de makefiles
contiennent une cible fictive nommée @file{clean}, qui efface tout
excepté les fichiers source.  Naturellement, ceci n'est fait que si vous
le demandez explicitement avec @w{@samp{make clean}}.  Ci-dessous une
liste de cibles fictives typique et de noms de cibles vides.  @xref{Cibles
standards}, pour une liste détaillée de tous les noms de cibles
standards, que les paquets de logiciels GNU utilisent.

@table @file
@item all
@cindex @code{all} @r{(Cibles standards)}
Fait que toutes les cibles de plus haut niveau connaissent le makefile.

@item clean
@cindex @code{clean} @r{(standard target)}
Efface tous les fichier, qui sont normalement créés en exécutant
@code{make}.

@item mostlyclean
@cindex @code{mostlyclean} @r{(standard target)}
Comme @samp{clean}, mais peut se retenir d'effacer quelques fichiers que
le gens ne veulent habituellement pas recompiler. Par exemple, la cible
@samp{mostlyclean} de GCC n'efface pas @file{libgcc.a},
car les recompiler est rarement nécessaire et que ceci prend beaucoup de
temps.

@item distclean
@cindex @code{distclean} @r{(standard target)}
@itemx realclean
@cindex @code{realclean} @r{(standard target)}
@itemx clobber
@cindex @code{clobber} @r{(standard target)}
Chacune de ces cibles peut être définies pour effacer @emph{plus de}
fichiers que @samp{clean} le fait.  Par exemple, ceci effacerait les
fichiers de configuration ou les liens qui sont normalement créés en
préparation des compilations, même si le makefile lui-même ne peut pas
créer ces fichiers.

@item install
@cindex @code{install} @r{(standard target)}
Copie le fichier exécutable dans un répertoire où les utilisateurs ont
l'habitude d'aller chercher les commandes@tie{}; copie tout fichier
auxiliaire que l'exécutable utilise dans des répertoires où il ira les
chercher.

@item print
@cindex @code{print} @r{(standard target)}
Retourne la liste des fichiers source qui ont changé.

@item tar
@cindex @code{tar} @r{(standard target)}
Crée un fichier tar des fichiers source.

@item shar
@cindex @code{shar} @r{(standard target)}
Crée une archive shell (un fichier shar) des fichiers source.

@item dist
@cindex @code{dist} @r{(standard target)}
Crée un fichier de distribution des fichiers source.  Ce peut être un
fichier tar tar ou un fichier shar ou une version compressée de l'un
d'entre eux ou de même de plusieurs d'entre eux.

@item TAGS
@cindex @code{TAGS} @r{(standard target)}
Mets à jour la tables des choix (ndt. ``tags'') pour ce programme.

@item check
@cindex @code{check} @r{(standard target)}
@itemx test
@cindex @code{test} @r{(standard target)}
Réalise des auto-tests sur le programme que ce makefile construit.
@end table


@node À la place d'une exécution, Éviter de recompiler, Objectifs, Exécuter make
@section À la place d'exécuter une instruction
@cindex execution, instead of
@cindex recipes, instead of executing

Le makefile explique à @code{make} comment dire si une cible est à jour,
et comment mettre à jour chacune des cibles.  Mais la mise à jour des
cibles n'est pas toujours ce que vous voulez faire.  Certaines options
définissent d'autres types d'activités pour @code{make}.

@comment Extra blank lines make it print better.
@table @samp
@item -n
@itemx --just-print
@itemx --dry-run
@itemx --recon
@cindex @code{--just-print}
@cindex @code{--dry-run}
@cindex @code{--recon}
@cindex @code{-n}

``No-op''.  Ces options demandent à @code{make} de retourner les
instructions, qui sont nécessaires pour mettre la cible à jour, mais ne
les exécutent pas réellement. Notez que certaines instructions sont tout
de même exécutées, même avec l'une de ces options (@pxref{La variable
MAKE, ,Comment fonctionne une variable @code{MAKE}}).  Toute instruction
nécessaire pour mettre à jour des makefiles inclus sera aussi toujours
exécutées (@pxref{Reconstruire les Makefiles, ,Comme les Makefiles sont
reconstruits}).

@item -t
@itemx --touch
@cindex @code{--touch}
@cindex touching files
@cindex target, touching
@cindex @code{-t}

``Touch''.  Marque les cibles comme étant à jour sans les changer
réellement. En d'autres termes, @code{make} prétend mettre à jour les
cibles, mais il ne change pas réellement leur contenu@tie{}; il ne ne
modifie que la date de modification.

@item -q
@itemx --question
@cindex @code{--question}
@cindex @code{-q}
@cindex mode question

``Question''.  Vérifie silencieusement si les cibles sont à jour, mais
n'exécute pas les instructions@tie{}; le code de retour montre si des
mises à jour sont réellement nécessaires ou non.

@item -W @var{file}
@itemx --what-if=@var{file}
@itemx --assume-new=@var{file}
@itemx --new-file=@var{file}
@cindex @code{--what-if}
@cindex @code{-W}
@cindex @code{--assume-new}
@cindex @code{--new-file}
@cindex what if
@cindex fichiers, assumés neufs

``What if''.  Chaque option @samp{-W} est suivie par un nom de
fichier. Les dates de modification des fichiers donnés sont enregistrés
par @code{make} comme étant la date actuelle, même si la date réelle de
modification reste la même.  Vous pouvez utilisez les options @samp{-W}
avec l'option @samp{-n} pour voir ce qui se passerait si vous modifiez
certains fichiers spécifiques.@refill
@end table

Avec l'option @samp{-n}, @code{make} retourne l'instruction qu'il aurait
normalement exécuté, mais la plupart du temps ne l'exécute pas.

Avec l'option @samp{-t}, @code{make} ignore les instructions des règles
et utilise (effectivement) la commande @code{touch} pour chaque cible
qui a besoin d'être refaire.  La commande @code{touch} est aussi
retournée, à moins que l'option @samp{-s} ou @code{.SILENT} soient
utilisés.  Pour être rapide, @code{make} n'invoque pas réellement le
programme @code{touch}.  Il réalise le travail directement.

Avec l'option @samp{-q}, @code{make} ne retourne rien et n'exécute
aucune instruction, mais le status retourné est zéro si et seulement si 
les cibles à considérer sont déjà à jour.  Si le status retourné est un,
alors quelques mises à jour sont nécessaires.  Si @code{make} rencontre
une erreur, le status de sortie est deux, de telle façon que vous
puissiez distinguer une erreur d'une cible qui est obsolète.

C'est une erreur d'utiliser plus d'une de ces trois options dans une
même invocation de @code{make}.

@cindex +, et exécution d'instruction
Les options @samp{-n}, @samp{-t} et @samp{-q} n'affectent pas les lignes
de commandes, qui débutent par des caractères @samp{+} ou qui
contiennent les chaînes @samp{$(MAKE)} ou @samp{$@{MAKE@}}.  Notez que
seules les lignes qui contiennent le caractère @samp{+} ou les chaînes
@samp{$(MAKE)} ou @samp{$@{MAKE@}} sont exécutées sans tenir compte de
ces options. Les autres lignes de la même règle ne sont pas pas
exécutée, sauf si elles débutent aussi par @samp{+} ou contiennent
@samp{$(MAKE)} ou @samp{$@{MAKE@}} (@xref{La variable MAKE, ,Comment
fonctionne la variable @code{MAKE}}.)

@cindex Les cibles fictives et les instructions d'exécution
L'option @samp{-t} empêche les cibles fictives (@pxref{Les cibles
fictives}) d'être mises à jour, à moins qu'il y ait des lignes
d'instructions commençant par @samp{+} ou contenant @samp{$(MAKE)} ou
@samp{$@{MAKE@}}.

L'option @samp{-W} apporte deux fonctionalités@tie{}:

@itemize @bullet
@item
Si vous utilisez les options @samp{-n} ou @samp{-q}, vous pouvez voir ce
que @code{make} ferait, si vous aviez à modifier les fichiers.

@item
Sans les options @samp{-n} ou @samp{-q}, quand @code{make} est
effectivement en train d'exécuter les instructions, l'option @samp{-W}
peut indiquer à @code{make} d'agir comme ci certains fichiers avaient
été modifiés, sans exécuter réellement les instructions nécessaires pour
mettre à jour ces fichiers.@refill
@end itemize

Notez que ces les options @samp{-p} et @samp{-v} vous permettent
d'obtenir d'autres informations sur @code{make} ou sur les makefiles
utilisés (@pxref{Résumé des options, ,Résumé des options}).@refill


@node Éviter de recompiler, Forcer, À la place d'une exécution, Exécuter make
@section Éviter de recompiler certains fichiers
@cindex @code{-o}
@cindex @code{--old-file}
@cindex @code{--assume-old}
@cindex fichiers, présumé obsolète
@cindex fichiers, éviter la recompilation
@cindex recompilation, éviter

Parfois, vous pouvez avoir changé un fichier source, mais vous ne
voulez pas recompiler tous les fichiers qui dépendent de lui. Par
exemple, supposez que vous ajoutiez une macro ou une déclaration à un
fichier d'en-têtes, dont beaucoup de fichiers dépendent. Étant
conservatif, @code{make} assume que tout changement dans le fichier
d'en-têtes requiert la recompilation de tous les fichiers qui en
dépendent. Mais vous savez qu'ils n'ont pas besoin d'être recompilés et
vous ne voudriez pas perdre de temps à attendre qu'ils recompilent.

Si vous avez anticipé le problème avant de changer le fichier d'en-tête,
vous pouvez utiliser l'option @samp{-t}. Cette option dit à @code{make}
de ne pas exécuter les instructions présentes dans les règles, mais
plutôt de marquer les cibles comme à jour en changeant leur date de
dernière modification.  Vous suiveriez cette procédure@tie{}:

@enumerate
@item
Utilisez la commande @samp{make} pour recompiler les fichiers sources,
qui ont réellement besoin d'une recompilation, en vous assurant ainsi
que les fichiers objets sont à jour avant de commencer.

@item
Effectuer les changements dans les fichiers d'en-tête.

@item
Utilisez la commande @samp{make -t} pour marquer tous les fichier objets
comme à jour. Ainsi la prochaine fois que vous exécuterez @code{make},
les changements dans les fichiers d'en-têtes ne causeront pas de
recompilation.
@end enumerate

Si vous aves déjà modifié le fichier d'en-tête à un moment ou certains
fichiers ont besoin d'une recompilation, il est alors trop tard pour
faire ceci.  À la place, vous pouvez utiliser l'option @w{@samp{-o
@var{file}}} qui marque un fichier spécifié comme s'il était ``ancien''
(@pxref{Résumé des options, ,Résumé des options}).  Ceci veut dire que
ce fichier ne sera pas refait lui même et rien se sera refait pour son
compte. Suivez cette procédure@tie{}:

@enumerate
@item
Recompilez les fichiers sources qui ont besoin de recompilation pour des
raisons indépendantes de ce fichier d'en-tête particulier, avec
@samp{make -o @var{headerfile}}.  Si plusieurs fichiers d'en-têtes sont
impliqués, utilisez plusieurs options @samp{-o} pour chaque fichier d'en-tête
séparemment.

@item
Marquez chaque fichier objet comme à jour en utilisant @samp{make -t}.
@end enumerate


@node Forcer, Tester, Éviter de recompiler, Exécuter make
@section Remplacer la valeur des variables
@cindex remplacer la valeur des variables avec des arguments
@cindex variables, remplacer avec les arguments
@cindex les variables en ligne de commande
@cindex variables, ligne de commande

Un argument qui contient @samp{=} spécifie la valeur d'une
variable@tie{}: @samp{@var{v}=@var{x}} définie la valeur de la variable
@var{v} à @var{x}.  Si vous spécifiez une valeur de cette façon, tous
les assignements ordinaires de cette même variable faites dans le
makefile sont ignorées@tie{}; on dit qu'elles ont été @dfn{surchargées}
par l'argument donné en ligne de commande.

La façon la plus commune d'utiliser cette fonctionalité est de passer
des options supplémentaires au compilateur. Par exemple, dans un
makefile écrit convenablement, la variable @code{CFLAGS} est incluse
dans chaque règle qui exécute le compilateur C, donc un fichier
@file{foo.c} serait compilé par quelque chose du genre@tie{}:

@example
cc -c $(CFLAGS) foo.c
@end example

Donc, quelque soit la valeur que vous avez définie pour @code{CFLAGS},
elle s'appliquera à chacune des compilations qui s'effectuera. Le makefile
spécifie probablement la valeur usuelle pour @code{CFLAGS}, comme
ceci@tie{}:

@example
CFLAGS=-g
@end example

Chaque fois que vous exécutez @code{make}, vous pouvez surcharger cette
valeur si vous le voulez. Par exemple, si vous dites @samp{make
CFLAGS='-g -O'}, chaque compilation C sera faite avec @samp{cc -c -g
-O}. (Ceci illustre aussi comment vous pouvez utiliser les guillemets
simples dans un shell pour enchâsser des espaces et d'autres caractères
génériques dans la valeur d'une variable quand vous la surchargez.)

La variable @code{CFLAGS} est seulement l'une des nombreuses variables
standards qui existent juste pour que vous puissiez les modifier de
cette façon.  @xref{Les variables implicites, , Les variables utilisées
par les règles implicites}, pour une liste complète.

Vous pouvez aussi programmer le makefile pour rechercher d'autres
variables de votre cru, en donnant ensuite la possibilité à
l'utilisateur de contrôler d'autres aspects du fonctionnement du
makefile en modififant ces variables.

Quand vous surchargez une variable avec un argument en ligne de
commande, vous pouvez définir soit une variable développée récursivement
soir une variable développée de manière unique.  Les exemples montrés
ci-dessus utilise une variable développée récursivement@tie{}; pour une
variable développée de manière unique, écrivez @samp{:=} ou @samp{::=} à
la place de @samp{=}.  Mais, sauf si vous voulz inclure une référence de
variable ou un appel de fonction dans la @emph{valeur} que vous
spécifiez, la catégorie de variable utilisée ne fait aucune différence.

Il n'y a qu'une seule façon pour le makefile de modifier une variable
que vous avez surchargée. C'est en utilisant la directive
@code{override}, qui est une ligne qui ressemble à cela@tie{}:
@samp{override} @var{variable} = @var{value} (@pxref{Directive de
forçage, ,La directive de forçage}).


@node Tester, Résumé des options, Forcer, Exécuter make
@section Tester la compilation d'un programme
@cindex tester une compilation
@cindex compilation, tester

Normalement, quand une erreur intervient pendant l'exécution d'une
commande shell, @code{make} abandonne immédidatement en retournant un
status non nul. Aucun autre instruction n'est exécutée pour aucune cible.
L'erreur implique que l'objectif ne peut pas être atteint et @code{make}
le rapporte dès qu'il le sait.

Quand vous compilez un programme que vous venez de changer, ce n'est pas
ce que vous voulez. À la place, pour préfériez que @code{make} essaye de
compiler tout fichier qui peut l'être, pour montrer combien le plus
possible d'erreurs de compilation.

@cindex @code{-k}
@cindex @code{--keep-going}
Dans ces occasions, vous devrize utilise les options @samp{-k} ou
@samp{--keep-going}.  Ceci dit à @code{make} de continuer à considérer
les autres pré-requis des cibles en attente, en les recompilant si
nécessaire, avant d'abandonner et de retourner un status non nul. Par
exemple, après une erreur de compilation d'un fichier objet, @samp{make
-k} continuera de compiler les fichiers objet même si il sait déjà que
l'édition de liens sera impossible.  En plus de continuer après l'erreur
donnée sur les commandes shell, @samp{make -k} continuera aussi
longtemps que possible après avoir découvert qu'il ne sait pas comment
faire un fichier cible ou pré-requis. Ceci causera un message d'erreur,
mais sans @samp{-k}, ce seraut une erreur fatale (@pxref{Résumé des
options, ,Résumé des options}).@refill

Le comportement usuel de @code{make} suppose que votre intention est
d'obtenir une mise à jour de l'objectif@tie{}; une fois que @code{make} a
appris que c'était impossible, il peut aussi très bien reporter l'erreur
immédiatement.  L'option @samp{-k} dit que l'intention réelle est de
tester autant que possible les changements qui ont été faits dans le
programme, peut être pour trouver plusieurs problèmes indépendants, de
telle façon que vous puissiez les corriger tous avant la prochaine
tentative de compilation.  C'est pourquoi la commande Emacs @kbd{M-x
compile} passe par défaut l'option @samp{-k}.


@node Résumé des options, , Tester, Exécuter make
@section Résumé des options
@cindex options
@cindex flags (ndt. options)
@cindex switches (ndr. options)

Voici une de toutes les options que @code{make} comprend@tie{}:

@table @samp
@item -b
@cindex @code{-b}
@itemx -m
@cindex @code{-m}
Ces options sont ignorées et n'existent que pour la compatibilité avec
les autres version de @code{make}.

@item -B
@cindex @code{-B}
@itemx --always-make
@cindex @code{--always-make}
Considère toutes les cibles obsolètes. GNU @code{make} considère les
cibles et leur pré-requis en utilisant des algorithmes normaux@tie{};
néanmoins, toutes les cibles considérées ainsi sont toujours refaites
sans tenir compte du status de leur pré-requis. Pour éviter les
récursions infinies, si @code{MAKE_RESTARTS} (@pxref{Variables
spéciales, , Autres Variables spèciales}) est défini sur un nombre plus
grand que 0, cette option est désactivée quand il s'agit de refaire des 
makefiles (@pxref{Reconstruire les Makefiles, ,Comment les Makefiles
sont-ils reconstruits}).

@item -C @var{dir}
@cindex @code{-C}
@itemx --directory=@var{dir}
@cindex @code{--directory}
Passe sur le répertoire @var{dir} avant de lire les makefiles. Si des
plusieurs options @samp{-C} sont spécifiées, chacune est interprétée
relativement à la précédente@tie{}: @samp{-C / -C etc} est équivalent à
@samp{-C /etc}.  Cette option est typiquement utilisé avec les
invocations récursives de @code{make} (@pxref{Récursion, ,Utilisation
récursive de @code{make}}).

@item -d
@cindex @code{-d}
@c Extra blank line here makes the table look better.

Retourne des informations additionnelles sur la mise au point.  Les
informations de mise au point disent quels fichiers sont considérés pour
être refabriqué, quels sont les dates de fichiers qui sont comparées et
quels sont les résultats, quels sont les fichiers qui ont besoin d'être
refabriqués, quelles règles implicites sont considérées et lesquelles
sont appliquées ---@tie{}tout ce qu'il est intéressant de savoir sur
commment @code{make} décide quoi faire.  L'option @code{-d} est
équivalent à l'option @samp{--debug=a} (voir plus bas).

@item --debug[=@var{options}]
@cindex @code{--debug}
@c Extra blank line here makes the table look better.

Retourne des informations de mise au point en plus du traitement
normal. Les différents niveaux et les différents types de retours
peuvent être choisis. Sans arguments, retourne le niveau ``basique'' de
mise au point. Les arguments possibles sont ci-dessous@tie{}; seulement
le premier caractère est considéré et les valeur doivent être séparées
par des virgule ou des espaces.

@table @code
@item a (@i{all})
Tous (ndt. all) les types de retour pour mise au point sont
activés. Ceci est équivalent à utiliser l'option @samp{-d}.

@item b (@i{basic})
Les informations de mise au point basiques retournent chaque cible qui a
ét trouvée comme obsolète et si la compilation a été couronnée de succès
ou non.

@item v (@i{verbose})
Un niveau au dessus du niveau @samp{basic} précédant@tie{}; ce niveau
inclut les messages sur quels makefiles ont été analysés, quels
pré-requis n'ont pas eu besoin d'être recompilés, etc.  Cette option
active aussi les messages de l'option @samp{basic}.

@item i (@i{implicit})
Retourne les messages décrivant les règles implicites recherchées par
chaque cibles. Cette option active aussi les message de l'option
@samp{basic}.

@item j (@i{jobs})
Retourne les messages donnant le détails des invocations de
sous-commandes spécifiques.

@item m (@i{makefile})
Par défaut, les messages ci-dessus ne sont pas activés quand les
makesfiles essaient d'être reconstruits.  Cette option active les
messages pendant la refabrication des makefiles aussi.  Notez que
l'option @samp{all} n'active pas cette option. Cette option active aussi
les message de l'option @samp{basic}.

@item n (@i{none})
Désactive tous les paramètres de mises au point actuellement activés. Si
des options additionnelles sont recontrées après, elles prendront
néanmoins effet.
@end table

@item -e
@cindex @code{-e}
@itemx --environment-overrides
@cindex @code{--environment-overrides}
Donne les variables prises dans l'environnement en priorité sur les
variables du makefiles.  @xref{Variables d'environnement, ,Variables venant de
l'environnement}.

@item -E @var{string}
@cindex @code{-E}
@item --eval=@var{chaîne}
@cindex @code{--eval}
@c Extra blank line here makes the table look better.

Évalue @var{chaîne} comme une syntaxe pour makefile.  C'est une version
en ligne de commande de la fonction @code{eval} (@pxref{Fonction
Eval}). Cette évaluation est faite après que les règles et variables par
défaut aient été définies, mais avant qu'aucun makefile ne soit lu.

@item -f @var{fichier}
@cindex @code{-f}
@itemx --file=@var{fichier}
@cindex @code{--file}
@itemx --makefile=@var{fichier}
@cindex @code{--makefile}
Les le fichier nommé @var{file} comme un makefile.  @xref{Les Makefiles,
,Écrire les Makefiles}.

@item -h
@cindex @code{-h}
@itemx --help
@cindex @code{--help}
@c Extra blank line here makes the table look better.

Vous rappèle les options que @code{make} comprend et sort.

@item -i
@cindex @code{-i}
@itemx --ignore-errors
@cindex @code{--ignore-errors}
Ignore toutes les erreurs dans les instructions exécutées pour
refabriquer les fichiers.  @xref{Erreurs dans les instructions, ,Erreurs dans les instructions}.

@item -I @var{dir}
@cindex @code{-I}
@itemx --include-dir=@var{dir}
@cindex @code{--include-dir}
Spécifie un répertoire @var{dir} dans lequel rechercher les makefiles
inclus. @xref{Inclure d'autres makefiles, ,Inclure d'autres Makefiles}.
Si plusieurs options @samp{-I} sont utilisées pour spécifier plusieurs répertoires,
les répertoires sont examinés dans l'ordre où ils ont été spécifiés.

@item -j [@var{jobs}]
@cindex @code{-j}
@itemx --jobs[=@var{jobs}]
@cindex @code{--jobs}
Spécifie le nombre d'instructions (tâches, ndt. ``jobs'') à exécuter
simultanément.  Sans argument, @code{make} exécute autant d'instructions
simultanée que possible.  S'il y a plus d'une option @samp{-j}, la
dernière est celle qui est effective.  @xref{Parallèle, ,Exécution
parallèle}, pour plus d'information sur comment les intructions sont
exécutées.  Notez que cette option est ignorée sur MS-DOS.

@item -k
@cindex @code{-k}
@itemx --keep-going
@cindex @code{--keep-going}
Continue autant que possible après une erreur. Tant que la cible qui a
provoqué l'erreur et celles dont elle dépends ne peut pas être refaite,
les autres pré-requis de ces cibles peuvent être exécutés pareillement.
@xref{Tester, ,Tester la compilation d'un programme}.

@item -l [@var{load}]
@cindex @code{-l}
@itemx --load-average[=@var{load}]
@cindex @code{--load-average}
@itemx --max-load[=@var{load}]
@cindex @code{--max-load}
Spécifie qu'aucune nouvelle instruction ne devrait être démarrée s'il y
a d'autres instruction en exécution et que la moyenne de chargement est
au moins @var{load} (un chiffre du type flottant). Sans argument, enlève
une limitation de charge précédente.  @xref{Parallèle, ,Exécution
parallèle}.

@item -L
@cindex @code{-L}
@itemx --check-symlink-times
@cindex @code{--check-symlink-times}
Sur les systèmes qui supportent les liens symboliques, cette options
fait que @code{make} considère les dates de tous les liens symboliques en plus
des dates des fichiers référencés par ces liens. Quanc cette option est
fournie, la date la plus récente entre les fichiers et les liens
symboliques est prise comme date de dernière modification pour le
fichier cible.

@item -n
@cindex @code{-n}
@itemx --just-print
@cindex @code{--just-print}
@itemx --dry-run
@cindex @code{--dry-run}
@itemx --recon
@cindex @code{--recon}
@c Extra blank line here makes the table look better.

Retourne l'instruction qui serait exécutée mais ne l'exécute pas
(excepté dans certains circonstances).  @xref{À la place d'une
exécution, ,À la place d'exécuter des instructions}.

@item -o @var{file}
@cindex @code{-o}
@itemx --old-file=@var{file}
@cindex @code{--old-file}
@itemx --assume-old=@var{file}
@cindex @code{--assume-old}
Ne refabrique pas le fichier @var{file} même s'il est plus ancien que
ses pré-requis et ne refabrique rien sur la base de changements dans
@var{file}.  Ce fichier est essentiellement traité comme très ancien et
ses règles sont ignorées.  @xref{Éviter de recompiler, ,Éviter de
recompiler certains fichiers}.@refill

@item -O[@var{type}]
@cindex @code{-O}
@itemx --output-sync[=@var{type}]
@cindex @code{--output-sync}
@cindex sorties en retour durant les exécutions parallèles
@cindex exécutions parallèles, sorties en retour
S'assure que les sorties complètes pour chacune des recettes sera
retournée en une séquence ininterrompue. Cette option est seulement
utile en utilisant l'option @code{--jobs} pour exécuter des instructions
simultanément (@pxref{Parallèle, ,Exécution parallèle}).  Sans cette
option, la sortie sera montrée comme générées par les
instructions.@refill

Sans type ou avec la type @samp{target}, la sortie d'une instruction
complète pour chaque cible est groupée ensemble. Avec le type
@samp{line}, la sortie de chaque ligne de recette est groupée
ensemble. Avec le type @samp{recurse}, la sortie d'une séquence entière
de récursion est groupée ensemble.  Avec le type @samp{none}, aucune
sortie n'est synchronisée.  @xref{Sortie parallèle, ,Sortie durant
l'exécution en parallèle}.

@item -p
@cindex @code{-p}
@itemx --print-data-base
@cindex @code{--print-data-base}
@cindex base de données des règles de @code{make}
@cindex règles et variables pré-définies, renvoyer la liste
Renvoie la base de données (les règles et les valeurs des variables) qui
résulte de la lecture des makefiles@tie{}; ensuite exécute comme
d'habiture ou comme spécifié.  Ceci renvoie aussi les informations de
version donnée par l'option @samp{-v} (voir plus bas).  Pour imprimer la
base de données sans essayer de recompiler les fichiers, utilisez
@w{@samp{make -qp}}.  Pour imprimer la base de données des règles et
variables prédéfinies, utilisez @w{@samp{make -p -f /dev/null}}. La
sortie de la base de donnée contient l'information du nom de fichier et
du numéro de ligne pour les instructions et les définitions de
variables, ce qui peut être un outil pratique de mise au point dans un
environnement complexe.

@item -q
@cindex @code{-q}
@itemx --question
@cindex @code{--question}
``Mode question''. N'exécute aucune instruction ni ne retourne
rien@tie{}; retourne juste un status qui est zéro si les cibles
spécifiées sont déjà à jour, un si aucune a besoin d'être remises à jour
et deux si une erreur a été rencontrée. @xref{À la place d'une
exécution, ,À la place d'exécuter les instructions}.@refill

@item -r
@cindex @code{-r}
@itemx --no-builtin-rules
@cindex @code{--no-builtin-rules}
Èlimine l'utilisation des règles implicite prédéfinies (@pxref{Les
règles implicites, ,utiliser les règles implicites}). Vous pouvez
toujours définir vos propres modèles de règles (@pxref{Modèle de règles,
,Définir et redéfinir les modèles de règles}).  L'option @samp{-r}
efface aussi les listes par défaut de suffixes pour les règles de
suffixes (@pxref{Règle des suffixes, ,Ancienne règle des suffixes}).
Mais vous pouvez toujours définir vos propres suffixes avec une règle
pour @code{.SUFFIXES} et définir ainsi vos propres règles de suffixes.
Notez que seules les @emph{règles} sont affactées par l'option
@code{-r}@tie{}; les variables par défaut restent effective (@pxref{Les
variables implicites, ,Variables utilisées par les règles implicites});
voir l'option @samp{-R} ci-dessous.

@item -R
@cindex @code{-R}
@itemx --no-builtin-variables
@cindex @code{--no-builtin-variables}
Élimine l'utilisation des variables prédéfinies spécifiques aux
instructions (@pxref{Les variables implicites, ,Variables utilisées les
règles implicites}). Bien sûr, vous pouvez définir vos propres
variables. L'option @samp{-R} active aussi automatiquement l'option
@samp{-r} (voir ci-dessus), car cela n'a pas de sens d'avoir des règles
implicites sans définitions des variables qu'elles utilisent.

@item -s
@cindex @code{-s}
@itemx --silent
@cindex @code{--silent}
@itemx --quiet
@cindex @code{--quiet}
@c Extra blank line here makes the table look better.

Opère silencieusment@tie{}; ne renvoie pas les instruction qui sont
exécutées.  @xref{Donner un retour, ,Donner un retour sur les
instructions}.

@item -S
@cindex @code{-S}
@itemx --no-keep-going
@cindex @code{--no-keep-going}
@itemx --stop
@cindex @code{--stop}
@c Extra blank line here makes the table look better.

Annule les effets des options @samp{-k}.  Ce n'est n'est jamais
nécessaire excepté dans un @code{make} récursif où @samp{-k} peut être
hérité du niveau supérieur de @code{make} à travers @code{MAKEFLAGS}
(@pxref{Récursion, ,Utilisation récursive de @code{make}}) ou is vous
avez défini @samp{-k} dans @code{MAKEFLAGS} dans votre
environnement.@refill

@item -t
@cindex @code{-t}
@itemx --touch
@cindex @code{--touch}
@c Extra blank line here makes the table look better.

Marque les fichiers comme à jour sans les changer réellement au lieu
d'excuter leurs instructions. Ceci est utilisé pour prétendre que les
instructions ont été effectuées de façon à tromper les futures
invocations de @code{make}.  @xref{À la place d'une exécution, ,À la
place d'exécuter les instructions}.

@item --trace
@cindex @code{--trace}
Montre les informations de traçage pour l'exécution de
@code{make}. Retourne l'instruction complète à exécuter, même pour les
instruction qui sont normalement silencieuses (suite à l'utilisation de
@code{.SILENT} ou @samp{@@}).  Retourne aussi le nom du makefile et le
numéro de ligne sur laquelle l'instruction est définie et l'information
sur la raison pour laquelle la cible est re-compilée.

@item -v
@cindex @code{-v}
@itemx --version
@cindex @code{--version}
Retourne la version du programme @code{make} et son droit d'auteur
(ndt. copyright), une liste des auteurs et un avertissement qu'il n'y
aucune garantie@tie{}; puis quitte.

@item -w
@cindex @code{-w}
@itemx --print-directory
@cindex @code{--print-directory}
Retourne un message contenant le répertoire de travail à la fois avant
et après exécution du makefile.  Ce peut être utile pour tracer les
erreurs d'un réseau complexe de commandes @code{make} recursives.  @xref{Récursion,
,Utilisation récursive de make}.  (En pratique, vous aurez rarement
besoin de spécifier cette option car @samp{make} le fait pour
vous@tie{}; voir @ref{-w Option, ,L'option @samp{--print-directory}}.)

@item --no-print-directory
@cindex @code{--no-print-directory}
Désactive le retour sur le répertoire de travail sous l'option
@code{-w}.  Cette option est utile quand @code{-w} est activée
automatiquement, mais que vous ne voulez pas voir les messages
supplémentaires.  @xref{-w Option, ,L'option @samp{--print-directory}}.

@item -W @var{file}
@cindex @code{-W}
@itemx --what-if=@var{file}
@cindex @code{--what-if}
@itemx --new-file=@var{file}
@cindex @code{--new-file}
@itemx --assume-new=@var{file}
@cindex @code{--assume-new}
Fait comme si la cible @var{file} avait été juste modifiée. Quand elle
est utilisée avec l'option @samp{-n}, elle montre ce qui se serait
passée si vous deviez modifier ce fichier. Sans @samp{-n}, c'est presque
la même chose qu'une commande @code{touch} sur le fichier donné avant
d'exécuter @code{make}, excepté que la date de modification est modifiée
seulement pour @code{make}.  @xref{À la place d'une exécution, ,À la
place d'exécuter une instruction}.

@item --warn-undefined-variables
@cindex @code{--warn-undefined-variables}
@cindex variables, alerte pour les indéfinis
@cindex variables non définie, message d'alerte
Emet un message d'alerte dès que @code{make} voit une référence à une
variable non définie. Ceci peut être utile quand vous essayez de mettre
au point des makefiles, qui utilisent les variables de manière complexe.
@end table

@node Les règles implicites, Les fichiers archivés, Exécuter make, Top
@chapter Utiliser les règles implicites
@cindex règle implicite
@cindex règle, implicite

Certaines façons de refaire des fichiers cibles sont utilisées très
souvent. Par exemple, la façon courante de faire un fichier objet à
partir de fichier source C est d'utiliser le compilateur C @code{cc}.

Les @dfn{règles implicites} disent à @code{make} comment utiliser des
techniques habituelles, de telle façon que vous n'ayez pas à les
spécifier dans le détail quand vous voulez les utiliser. Il exist par
exemple une règle implicite pour la compilation de fichiers C. Les noms
de fichiers déterminent quelle règle implicite doit être utilisée. Par
exemple, la compilation C prend typiquement des fichiers @file{.c} pour
fabriquer des fichiers @file{.o}. Quand il voit cette combinaisons de
terminaisons de noms de fichiers, @code{make} applique la règle
implicite d'une compilation C. @refill

Les règles implicites peuvent s'enchainer séquentiellement@tie{}; par
exemple, @code{make} recompile un fichier @file{.o} depuis un fichier
@file{.y} en passant par un fichier @file{.c}.
@iftex
@xref{Règles chainées, ,Enchaînement de règles implicites}.
@end iftex

Les règles intégrées implicites utilisent plusieurs variables dans leurs
instruction, de telle façon qu'en changeant la valeur de ces variables,
vous pouvez modifier la façon dont la règle implicite fonctionne. Par
exemple, la variable @code{CFLAGS} contrôle les options données au
compilateur C dans la règle implicite des compilations en C.
@iftex
@xref{Variables implicites, ,Les variables utilisées par les règles implicites}.
@end iftex

Vous pouvez définir vos propres règles implicites en écrivant vos
@dfn{modèle de règles}.
@iftex
@xref{Modèle de règles, ,Defining and Redefining Pattern Rules}.
@end iftex

Les @dfn{règles de suffixes} sont une façon plus limitée de définir des
règles implicites. Les modèles de règles (ndt. pattern rules) sont
généralement plus claires, mais les règles de suffixes sont néanmoins
conservées pour des raisons de compatibilité.
@iftex
@xref{Règle des suffixes, ,Ancienne règle des suffixes}.
@end iftex


@node Utiliser les règles implicites, Catalogue des règles, Les règles implicites, Les règles implicites
@section Utiliser les règles implicites
@cindex règle implicite, comment utiliser
@cindex règle, implicite, comment utiliser

Pour permettre à @code{make} de trouver les règles habituelles pour
mettre à jour un fichier cible, tout ce que vous avez à faire est de
vous retenir de spécifier ces instructions par vous-même. Soit on écrit une
règle sans instruction, soit on n'écrit pas de règle du tout. Dans ce cas,
@code{make} recherchera quelle règle implicite utiliser basé sur le type
de fichier source qu'il existe ou qui peuvent être construit.

Par exemple, supposons que notre makefile ressemble à ceci@tie{}:

@example
foo : foo.o bar.o
        cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
@end example

@noindent
Parceque vous mentionnez le fichier @file{foo.o} mais ne donnez pas de
règle pour le construire, @code{make} recherchera automtiquement une
règle implicite qui lui dira comment le mettre à jour, qu'un fichier
@file{foo.o} existe ou non réellement sur le répertoire.

Si une règle implicite est trouvée, elle peut donner une instruction et
en même temps un ou plusieurs pré-requis (les fichiers sources). Vous
pourriez vouloir écrite une règle pour @file{foo.o} sans instruction si
vous voulez spécifier des pré-requis additionels, comme un fichier
d'en-têtes, qu'une règle implicite ne peut pas fournir.

Chaque règle implicite a un modèle de cible et des modèles de
pré-requis. Il peut y avoir beaucoup de règles implicites avec le même
modèle de cible. Par exemple, il y a de nombreuses règles pour compiler
des fichies @file{.o} @tie{}: une, pour le compiler à partir d'un
fichier @samp{.c} avec le compilateur C@tie{}; une autre, à partir d'un
fichier @samp{.p} avec un compilateur Pascal@tie{}; etc. La règle qui
s'appliquera effectivement sera celle dont les prérequis existent ou
peuvent être construits. Donc, si vous avez un fichier @file{foo.c},
@code{make} lancera un compilateur C@tie{}; sinon, si vous avez un
fichier @file{foo.p}, il lancera le compilateur Pascal et ainsi de
suite.

Bien sûr quand vous écrivez un makefile, vous savez quelle règle
implicite vous voulez que @code{make} utilise et vous savez qu'il va la
choisir parceque vous savez quels sont les fichiers pré-requis possibles
qui sont supposés exister.  @xref{Catalogue des règles, ,Catalogue des règles
prédéfinies}, pour un catalogue de toutes les règles prédéfinies déjà
intégrées.

Plus haut nous disions qu'une règle implicite s'applique si les
pré-requis ``existent ou peuvent être construits''. Un fichier ``peut
être constuit'' s'il est mentioné explicitement dans le makefile comme
une cible ou un pré-requis, ou si une règle implicite peut trouver
récursivement comment le construire. Quand un pré-requis implicite est
le résultat d'une autre règle implicite, nous parlons alors d'un
@dfn{enchainement}. @xref{Enchaînement de règles implicites, ,Chains of Règles
implicites}.

En général, @code{make} recherche un règle implicite pour chaque cible,
et pour pour chaque règle à double double points, qui n'a pas
d'instruction.  Un fichier qui n'est mentionné que comme un
pré-requis est considéré comme une cible dont l'instruction ne spécifie
rien, donc il est passé au crible de la recherche de règle implicite.
@xref{Recherche de règles implicites, ,Algorithme de recheche de règle
implicite}, pour plus de détails sur la façon dont est faite cette recheche.

Notez que les pré-requis explicites n'influencent pas la recherche de
règle implicite. Par exemple, considérez cette règle explicites@tie{}:

@example
foo.o: foo.p
@end example

@noindent
Le pré-requis sur @file{foo.p} ne signifie pas nécessairement que @code{make}
va recompiler @file{foo.o} suivant la règle implicite pour faire un
fichier objet, un fichier @file{.o}, depuis un fichier source en Pascal,
un fichier @file{.p}.  Par exemple, si @file{foo.c} existe aussi, la
règle implicite pour compiler un fichier objet à partir d'un fichier
source en C sera utilisée à la place, car elle apparait avant la règle en
Pascal dans la liste des règles implicites pré-définies (@pxref{Catalogue des
règles, , Catalogue des règles prédéfinies}).

Si vous ne voulez pas qu'un règle implicite soit utilisée pour une cible
qui n'a pas d'instruction, vous pouvez donner à cette cible une
instruction vide en écrivant un point virgule (@pxref{Instructions
vides, ,Defining Instructions vides}).


@node Catalogue des règles, Les variables implicites, Utiliser les règles implicites, Les règles implicites
@section Catalogue des règles prédéfinies
@cindex règles implicites, prédéfinies
@cindex règle, implicites, prédéfinies

Voici une catalogue de règles implicites prédéfinies, qui sont toujours
disponibles exepté si le makefile les a explicitement surchargées ou
annylées.  @xref{règles d'annulation, ,Annule les règles implicites},
pour plus d'information sur l'annulation ou la surcharge des règles
implicites.  Les options @samp{-r} ou @samp{--no-builtin-rules} annulent
les règles prédéfinies.

Ce manuel ne documente que les règles par défaut disponibles dans les
systèmes d'exploitation basés sur POSIX. Les autres systèmes
d'exploitation, comme VMS, Windows, OS/2, etc. peut avoir définis
d'autres règles par défaut. Pour voir la liste complète des règles par
défaut et des variables disponibles sur votre version de GNU @code{make},
exécutez @samp{make -p} dans un répertoire sans makefile.

Quelques unes de ces règles ne seront pas toujours définies, même si
l'option @samp{-r} n'a pas été donnée. Beaucoup de ces règles implicites
prédéfinies sont implémentées dans @code{make} comme des règles de
suffixes, donc celle qui sera définie dépendra de la @dfn{liste des
suffixes} (la liste des pré-requis de la cible spéciale
@code{.SUFFIXES}).  La liste par défaut des suffixes est@tie{}:
@code{.out}, @code{.a}, @code{.ln}, @code{.o}, @code{.c}, @code{.cc},
@code{.C}, @code{.cpp}, @code{.p}, @code{.f}, @code{.F}, @code{.m},
@code{.r}, @code{.y}, @code{.l}, @code{.ym}, @code{.lm}, @code{.s},
@code{.S}, @code{.mod}, @code{.sym}, @code{.def}, @code{.h},
@code{.info}, @code{.dvi}, @code{.tex}, @code{.texinfo}, @code{.texi},
@code{.txinfo}, @code{.w}, @code{.ch} @code{.web}, @code{.sh},
@code{.elc}, @code{.el}.  Toutes les règles implicites décrites
ci-dessous et dont les pré-requis ont l'un de ces suffixes sont en
réalité des règles de suffixes. Si vous modifiez la liste des suffixes,
les seules règles de suffixes prédéfinies qui seront effectives seront
celles nommées par un ou deux de ces suffixes, qui sont sur la liste que
vous avez spécifiée@tie{}; les règles dont les suffixes ne sont pas dans
cette liste sont désactivées.  @xref{Règle des suffixes, ,Ancienne règle
des suffixes}, pour plus de détails sur les règles de suffixes.

@table @asis
@item Compiler des programmes C
@cindex C, règle pour compiler
@pindex cc
@pindex gcc
@pindex .o
@pindex .c
@file{@var{n}.o} est construit automatiquement à partir de
@file{@var{n}.c}, qui est une règle de la forme @samp{$(CC) $(CPPFLAGS)
$(CFLAGS) -c}.@refill

@item Compiler des programmes C++
@cindex C++, règle de compilation
@pindex g++
@pindex .cc
@pindex .cpp
@pindex .C
@file{@var{n}.o} est constuit automatiquement à partir de @file{@var{n}.cc},
@file{@var{n}.cpp}, ou @file{@var{n}.C} avec une instruction de la forme
@samp{$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c}.  Nous vous encourageaons le
suffixe @samp{.cc} pour les sources en C++ à la place de @samp{.C}.@refill

@item Compiler les programmes en Pascal
@cindex Pascal, règle de compilation
@pindex pc
@pindex .p
@file{@var{n}.o} est construit automatiquement à partir de
@file{@var{n}.p} avec l'instruction @samp{$(PC) $(PFLAGS) -c}.@refill

@item Compiler les programmes Fortran et Ratfor
@cindex Fortran, règle de compilation
@cindex Ratfor, règle de compilation
@pindex f77
@pindex .f
@pindex .r
@pindex .F
@file{@var{n}.o} est fabriqué automatiquement à partir de @file{@var{n}.r},
@file{@var{n}.F} ou @file{@var{n}.f} en exécutant un compilateur
Fortran.  L'instruction précise à utiliser est la suivante@tie{}:@refill

@table @samp
@item .f
@samp{$(FC) $(FFLAGS) -c}.
@item .F
@samp{$(FC) $(FFLAGS) $(CPPFLAGS) -c}.
@item .r
@samp{$(FC) $(FFLAGS) $(RFLAGS) -c}.
@end table

@item Prétraiter des programmes Fortran ou Ratfor
@file{@var{n}.f} est fabriqué automatiquement à partir de
@file{@var{n}.r} ou de @file{@var{n}.F}.  Cette règle exécute seulement
le processus de pré-traitement qui convertit un programme Ratfor ou un
programme Fortran préprocessable en un programme Fortran strict.  La
règle précise utilisée est la suivante:@refill

@table @samp
@item .F
@samp{$(FC) $(CPPFLAGS) $(FFLAGS) -F}.
@item .r
@samp{$(FC) $(FFLAGS) $(RFLAGS) -F}.
@end table

@item Compiler des programmes Modula-2
@cindex Modula-2, règle de compilation
@pindex m2c
@pindex .sym
@pindex .def
@pindex .mod
@file{@var{n}.sym} est fabriqué automatiquement à partir de @file{@var{n}.def} avec une
règle de la forme @samp{$(M2C) $(M2FLAGS) $(DEFFLAGS)}.
@file{@var{n}.o} est fabriqué à partir de @file{@var{n}.mod}; la forme
est@tie{}: @w{@samp{$(M2C) $(M2FLAGS) $(MODFLAGS)}}.@refill

@need 1200
@item Assembler et pré-traiter un programme en assembleur
@cindex assembleur, règle de compilation
@pindex as
@pindex .s
@file{@var{n}.o} est fabriqué automatiquement à partir de
@file{@var{n}.s} en exécutant l'assembleur, @code{as}. La règle précise est @samp{$(AS) $(ASFLAGS)}.@refill

@pindex .S
@file{@var{n}.s} est fabriqué automatiquement à partir de
@file{@var{n}.S} en exécutant le processus de pré-traitement C,
@code{cpp}. La règle précise est @w{@samp{$(CPP) $(CPPFLAGS)}}.

@item Lier un fichier objet seul
@cindex lier, règle prédéfinie
@pindex ld
@pindex .o
@file{@var{n}} est fabriqué automatiquement à partir de @file{@var{n}.o}
en excutant l'éditeur de liens (habituellement appelé @code{ld}) à
travers le compilateur C.  Les règle précise utilisée est @w{@samp{$(CC)
$(LDFLAGS) @var{n}.o $(LOADLIBES) $(LDLIBS)}}.

Cette règle fait fonctionne pour un programme simple avec seulement un
fichier source.  Elle fonctionnera aussi s'il y a plusieurs fichiers
objets (on présume venant de plusieurs autres fichiers sources), l'un
d'entre eux ayant le nom du fichier executable.  Ainsi,

@example
x: y.o z.o
@end example

@noindent
quand @file{x.c}, @file{y.c} et @file{z.c} existent tous exécutera@tie{}:

@example
@group
cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
@end group
@end example

@noindent
Dans les cas plus compliqués, comme dans celui où il n'y a pas de
fichier objet dans le nom dérive du nom du fichier exécutable, vous
devrez écrire la règle explicitement pour faire l'édition de liens.

Chaque type de fichier, qui est compilé automatiquement en un fichier
objet @samp{.o} object, sera automatiquement lié en utilisant le
compilateur (@samp{$(CC)}, @samp{$(FC)} ou @samp{$(PC)}; le compilateur
C @samp{$(CC)} est utilisé pour assembler les fichiers @samp{.s}) sans
l'option @samp{-c}.  Ceci peut être fait en utilisant les fichiers
objets @samp{.o} comme intermédiaires, mais il est plus rapide de faire
la compilation et l'édition de lien en une seule étape, donc c'est ainsi
que c'est fait.@refill

@item Yacc pour les programmes C
@pindex yacc
@cindex Yacc, règle de compilation
@pindex .y
@file{@var{n}.c} est fabriqué automatiquement à partir de
@file{@var{n}.y} en exécutant Yacc avec une règle @samp{$(YACC) $(YFLAGS)}.

@item Lex pour les programmes C
@pindex lex
@cindex Lex, règle de compilation
@pindex .l
@file{@var{n}.c} est fabriqué automatiquement à partir de
@file{@var{n}.l} en exécutant Lex.  La règle effective est @samp{$(LEX) $(LFLAGS)}.

@item Lex pour les programmes Ratfor
@file{@var{n}.r} est fabriqué automatiquement à partir de @file{@var{n}.l} en
exécutant Lex.  La règle effective est @samp{$(LEX) $(LFLAGS)}.

La convention d'utiliser le même suffixe @samp{.l} pour tous les
fichiers Lex, qu'ils produisent du code C ou Ratfor rend impossible la
détermination automatique par @code{make} du langage que vous utilisez
dans ce cas particulier.  Si @code{make} est invité pour refaire un
fichier objet à partir d'un fichier @samp{.l}, il doit deviner quel
compilateur utiliser. Il fera l'hypothèse que c'est un compilateur C,
car c'est le cas le plus courant. Si vous utilisez Ratfor, assurez vous
que @code{make} le sera en mentionant @file{@var{n}.r} dans le makefile.
Ou, si vous utilisez exclusivement Ratfor, sans fichiers C, enlevez
@samp{.c} de la liste des règles de suffixes implicite avec@tie{}:@refill

@example
@group
.SUFFIXES:
.SUFFIXEgS: .o .r .f .l @dots{}
@end group
@end example

@item Compiler des bibliothèques Lint à partir de programmes C, Yacc, ou Lex
@pindex lint
@cindex @code{lint}, règle de compilation
@pindex .ln
@file{@var{n}.ln} est fabriqué à partir de @file{@var{n}.c} en exécutant
@code{lint}.  La règle précise est @w{@samp{$(LINT) $(LINTFLAGS)
$(CPPFLAGS) -i}}. La même règle est utilisée sur le code C pour produire
à partir de @file{@var{n}.y} ou @file{@var{n}.l}.@refill

@item @TeX{} et Web
@cindex @TeX{}, règle de compilation
@cindex Web, règle de compilation
@pindex tex
@pindex cweave
@pindex weave
@pindex tangle
@pindex ctangle
@pindex .dvi
@pindex .tex
@pindex .web
@pindex .w
@pindex .ch
@file{@var{n}.dvi} est fabriqué à partir de @file{@var{n}.tex} avec le
règle @samp{$(TEX)}.  @file{@var{n}.tex} est fait à parir de
@file{@var{n}.web} avec @samp{$(WEAVE)}, ou à partir de @file{@var{n}.w}
(et de @file{@var{n}.ch} s'il existe ou peut être fabriqué) avec
@samp{$(CWEAVE)}. @file{@var{n}.p} est fabriqué à partir de
@file{@var{n}.web} avec @samp{$(TANGLE)} et @file{@var{n}.c} est
fabriqué à partir de @file{@var{n}.w} (et de @file{@var{n}.ch} s'il
existe ou peut être fabriqué) avec @samp{$(CTANGLE)}.@refill

@item Texinfo et Info
@cindex Texinfo, règle pour formatter
@cindex Info, règle de formatage
@pindex texi2dvi
@pindex makeinfo
@pindex .texinfo
@pindex .info
@pindex .texi
@pindex .txinfo
@file{@var{n}.dvi} est fabriqué à partir de @file{@var{n}.texinfo},
@file{@var{n}.texi}, ou @file{@var{n}.txinfo}, avec la règle
@w{@samp{$(TEXI2DVI) $(TEXI2DVI_FLAGS)}}.  @file{@var{n}.info} est
fabriqué à partir de @file{@var{n}.texinfo}, @file{@var{n}.texi}, ou
@file{@var{n}.txinfo}, avec la règle @w{@samp{$(MAKEINFO) $(MAKEINFO_FLAGS)}}.

@item RCS
@cindex RCS, règle pour extraire de
@pindex co
@pindex ,v @r{(RCS extension de fichier)}
Tout fichier @file{@var{n}} est extrait, si nécessaire, d'un fichier RCS
nommée @file{@var{n},v} ou @file{RCS/@var{n},v}. La règle précise est
@w{@samp{$(CO) $(COFLAGS)}}.  @file{@var{n}} ne sera pas extrait d'un
RCS s'il existe déjà, même sir le fichier RCS est plus neuf. Les règles
pour RCS sont des règles terminales (@pxref{Régles pour correspondre à tout,
,les modèles de règles pour correspondre à tout}), donc les fichiers RCS
ne peuvent pas être généré à partir d'une autre source@tie{}; il doivent
réellement exister.@refill

@item SCCS
@cindex SCCS, règle pour extraire de
@pindex get
@pindex s. @r{(SCCS file prefix)}
Tout fichier @file{@var{n}} est extrait si nécessaire d'un fichier SCCS
nommé @file{s.@var{n}} ou @file{SCCS/s.@var{n}}. La règle précise
utilisée est @w{@samp{$(GET) $(GFLAGS)}}.  Les règles pour SCCS sont des
règles terminales (@pxref{Régles pour correspondre à tout, ,Les modèles
de règles pour correspondre à tout}), donc les fichiers SCCS ne peuvent
pas être générés à partir d'une autre source@tie{}; ils doivent
réellement exister.@refill

@pindex .sh
Pour le bénéfice de SCCS, un fichier @file{@var{n}} est copié à partir de
@file{@var{n}.sh} et rendu exécutable (pour tout le monde).  Ceci est
pour les scripts shell, qui sont vérifiés dans SCCS.  Comme RCS préserve
les permissions d'exécution d'un fichier, vous n'avez pas besoin
d'utiliser cette fonctionalité avec RCS.@refill

Nous recommendant d'éviter d'utiliser SCCS.  RCS est largement tenu pour
supérieur, et il est aussi libre. En choisissant des logiciels libres à
la place de logiciels propriétaires (ou inférieurs), vous supportez le
mouvement pour le logiciel libre.
@end table

Le plus souvent, vous ne voudrez changer que les variables listées dans
la table données ci-dessus, comme documenté dans la prochaine section.

Cependant, les règles implicites prédéfinies utilisent en fait des
variables comme @code{COMPILE.c}, @code{LINK.p}, et @code{PREPROCESS.S},
dont les valeurs contiennent les règles listées ci-dessus.

@code{make} suit la convention, qu'une rège pour compiler un fichier
source @file{.@var{x}} utilise la variable @code{COMPILE.@var{x}}.
De la même manière, la règle pour produire un exécutable à partir du
fichier @file{.@var{x}} utilise @code{LINK.@var{x}}; et la règle pour le
pré-traitement d'un fichier @file{.@var{x}} utilise @code{PREPROCESS.@var{x}}.

@vindex OUTPUT_OPTION
Chaque règle, qui produit un fichier objet, utilise la variable
@code{OUTPUT_OPTION}.  @code{make} définit cette variable soit pour
contenir @samp{-o $@@}, soit pour être vide, selon l'option donnée au
moment de la compilation.  Vous aurez besoin de l'option @samp{-o} pour
vous assurer que la sortie va dans le bon fichier quand le fichier
sources est dans un autre répertoire, comme quand vous utilisez
@code{VPATH} (@pxref{Rechercher dans les répertoires}).  Cependant, les
compilateurs de certains systèmes n'accepetent pas l'option @samp{-o}
pour les fichiers objets. Si vous êtes sur un tel système et que vous
utilisez @code{VPATH}, certaines compilations pourraient mettre leur
résultat à une mauvaise place. Une façon possible de contourner la
difficulté est de donner à @code{OUTPUT_OPTION} la valeur @w{@samp{; mv
$*.o $@@}}.


@node Les variables implicites, Enchaînement de règles implicites, Catalogue des règles, Les règles implicites
@section Les variables utilisées par les règles implicites
@cindex options pour les compilateurs

Les instructions des règles implicites pré-intégrées utilisent certaines
variables prédéfinies avec beaucoup de liberté. Vous pouvez changer la
valeur de ces variables dans le makefile, ou avec des arguments en ligne de
commande pour @code{make}, ou encore avec l'environnement pour modifier
le fonctionnement de ces règles implicites sans avoir à les redéfinir
elles-mêmes. Vous pouvez annuler toutes les variables utilisées par les
règles implicites avec l'option @samp{-R} ou @samp{--no-builtin-variables}.

Par exemple, l'instruction utilisée pour compiler un fichier source C
dit en réalité @samp{$(CC) -c $(CFLAGS) $(CPPFLAGS)}.  Les valeurs par
défaut de ces variables utilisées sont @samp{cc} et la chaîne vide, ce
qui donne la commande @samp{cc -c}. En redéfinissant @samp{CC} comme
@samp{ncc}, vous utiliseriez @samp{ncc} pour toutes les compilations C
réalisée par cette règle implicite. En redéfinissant @samp{CFLAGS} comme
@samp{-g}, vous passeriez l'option @samp{-g} à chaque
compilation. @emph{Toutes} les règles implicites, qui effectuent des
compilations C utilisent @samp{$(CC)} pour obtenir le nom du programme
de compilation et @emph{toutes} incluent @samp{$(CFLAGS)} parmi les
argument qu'elles donnent au compilateur.@refill

Les variables utilisées dans les règles implicites tombent dans deux
classes: celles qui sont des noms de programmes (comme @code{CC}) et
celles qui contiennent des arguments pour ces programmes (comme
@code{CFLAGS}).  (Le ``nom du programme'' peut aussi contenir quelques
arguments de commande, mais il doit commencer par un véritable nom de
programme exécutable.)  Si une valeur de variable contient plus d'un
argument, séparez les par des espaces.

Les tables qui suivent décrivent quelques unes des variables prédéfinies
les plus couramment utilisées. Cette n'est pas exhaustive, et les
valeurs par défaut montrées ici pourraient ne pas être celles que
@code{make} sélectionnera dans votre environnement.  Pour obtenir la
liste complète des variables prédéfinies pour votre instance de GNU
@code{make}, vous pouvez exécuter @samp{make -p} dans un répertoire sans
makefiles.

Voici la table de quelques unes des variables utilisées le plus
couramment dans les règles implicites prédéfinies pour les les noms de
programmes@tie{}:

@table @code
@item AR
@vindex AR
Programme de maintenance des archives@tie{}; par défaut @samp{ar}.
@pindex ar

@item AS
@vindex AS
Programme pour compiler les fichiers assembleur@tie{}; par défaut @samp{as}.
@pindex as

@item CC
@vindex CC
Programme pour compiler les programmes C; par défaut @samp{cc}.
@pindex cc

@item CXX
@vindex CXX
Programme pour compiler les programmes C++; par défault @samp{g++}.
@pindex g++

@item CPP
@vindex CPP
Programme pour exécuter le pré-processeur C, en donnant les résultats
sur la sortie standard@tie{}; par défaut @samp{$(CC) -E}.

@item FC
@vindex FC
Programme pour compiler ou pré-traiter des programmes Fortran et Ratfor@tie{}; par défaut
@samp{f77}.
@pindex f77

@item M2C
@vindex M2C
Programme à utiliser pour compiler du code source Modula-2@tie{}; par défaut @samp{m2c}.
@pindex m2c

@item PC
@vindex PC
Programme pour compiler des programmes Pascal@tie{}; par défaut @samp{pc}.
@pindex pc

@item CO
@vindex CO
Programme pour extraire un fichier de RCS@tie{}; par défaut @samp{co}.
@pindex co

@item GET
@vindex GET
Programme pour extraire un fichier de SCCS@tie{}; par défaut @samp{get}.
@pindex get

@item LEX
@vindex LEX
Programme à utiliser pour transformer une grammaire Lex grammars en un
code source@tie{}; par défaut @samp{lex}.
@pindex lex

@item YACC
@vindex YACC
Programme à utiliser pour transformer une grammaire Yacc en un code
source@tie{}; par défaut @samp{yacc}.
@pindex yacc

@item LINT
@vindex LINT
Programme à utiliser pour exécuter lint sur un code source; par défaut @samp{lint}.
@pindex lint

@item MAKEINFO
@vindex MAKEINFO
Programme pour convertir un fichier source Texinfo en un fichier fichier
Info@tie{}; par défaut @samp{makeinfo}.
@pindex makeinfo

@item TEX
@vindex TEX
Programme pour générer des fichiers @sc{dvi} @TeX{} à partir de fichiers
source @TeX{}@tie{}; par défaut @samp{tex}.
@pindex tex

@item TEXI2DVI
@vindex TEXI2DVI
Programme pour générer des fichier @sc{dvi} @TeX{} à partir de fichier
source Texinfo; par défaut @samp{texi2dvi}.
@pindex texi2dvi

@item WEAVE
@vindex WEAVE
Programme pour traduire une entrée Web en @TeX{}; par défaut @samp{weave}.
@pindex weave

@item CWEAVE
@vindex CWEAVE
Programme pour tranduire une entrée C Web en @TeX{}; par défaut @samp{cweave}.
@pindex cweave

@item TANGLE
@vindex TANGLE
Programme pour traduire une entrée Web en Pascal; par défaut @samp{tangle}.
@pindex tangle

@item CTANGLE
@vindex CTANGLE
Programme pour traduire une entrée C Web en C; par défaut @samp{ctangle}.
@pindex ctangle

@item RM
@vindex RM
Commande pour effacer un fichier@tie{}; par défaut @samp{rm -f}.
@pindex rm
@end table

Voici une tables des variables, dont les valeurs sont des arguments
additionnels pour les programmes cités ci-dessus.  Les valeurs par
défaut de toutes ces variables sont la chaîne vide, sauf si spécifié
autrement.

@table @code
@item ARFLAGS
@vindex ARFLAGS
Options à donner au programme de maintenance d'archive@tie{}; default @samp{rv}.

@item ASFLAGS
@vindex ASFLAGS
Options supplémentaires à donner à l'assembleur (quand invoqué
explicitement sur un fichier @samp{.s} ou @samp{.S}).

@item CFLAGS
@vindex CFLAGS
Option supplémentaires à donner au compilateur C.

@item CXXFLAGS
@vindex CXXFLAGS
Option supplémentaires à donner au compilateur C++.

@item COFLAGS
@vindex COFLAGS
Option supplémentaires à donner au programme RCS @code{co}.

@item CPPFLAGS
@vindex CPPFLAGS
Options supplémentaires à donner au pré-processeur C et aux programmes
qui l'utilisent (les compilateurs C et Fortran).

@item FFLAGS
@vindex FFLAGS
Option supplémentaires à donner au compilateur Fortran.

@item GFLAGS
@vindex GFLAGS
Options supplémentaires à donner au programme SCCS @code{get}.

@item LDFLAGS
@vindex LDFLAGS
Options supplémentaires à donner au compilateurs, quand ils sont
supposer invoquer l'éditeur de liens, @samp{ld}, comme @code{-L}.  Les
bibliothèques (@code{-lfoo}) devraient être ajoutées à la variable
@code{LDLIBS} à la place.

@item LDLIBS
@vindex LDLIBS
@vindex LOADLIBES
Les options ou noms de bibliothèques données aux compilateurs, quand ils
sont supposés les invoquer dans l'éditeur de liens, @samp{ld}.
@code{LOADLIBES} est un version obsolète (mais toujours supporté) à
@code{LDLIBS}.  Les options de l'éditeur de liens, qui ne se réfèrent
pas à des bibliothèques, comme @code{-L}, devraient aller dans la
variable @code{LDFLAGS} à la place.

@item LFLAGS
@vindex LFLAGS
Options supplémentaires à donner à Lex.

@item YFLAGS
@vindex YFLAGS
Options supplémentaires à donner à Yacc.

@item PFLAGS
@vindex PFLAGS
Options supplémentaires à donner au compilateur Pascal.

@item RFLAGS
@vindex RFLAGS
Options supplémentaire à donner au compilateur Fortran pour les programmes Ratfor.

@item LINTFLAGS
@vindex LINTFLAGS
Options supplémentaire à donner à lint.
@end table

@node Enchaînement de règles implicites, Modèle de règles, Les variables implicites, Les règles implicites
@section Enchaînement de règles implicites

@cindex enchaînement de règles
@cindex règle, implicite, enchaînement
Parfois une fichier peut être obtenu à partir d'une séquence de règles implicites.
Par exemple, un fichier @file{@var{n}.o} peut être fait à partir de
@file{@var{n}.y} en exécutant d'abord Yacc et ensuite @code{cc}.  Une
telle séquence est appelée un @dfn{enchaînement}.

Si le fichier @file{@var{n}.c} existe ou s'il est mentioné dans le
makefile, aucune recherche particulière n'est requise@tie{}: @code{make}
trouve que le fichier objet peut être fait par une compilation C de
@file{@var{n}.c}@tie{}; ensuite, en considérant commant faire 
@file{@var{n}.c}, la règle utilisant l'exécution de Yacc est utilisée.
Finalement, les deux fichier fichiers @file{@var{n}.c} et
@file{@var{n}.o} sont mis à jour.@refill

@cindex fichiers intermédiaires
@cindex fichiers, intermediaire
Cependant, même si @file{@var{n}.c} n'existe pas et n'est pas mentioné,
@code{make} sait le concevoir comme le lien lien manquant entre
@file{@var{n}.o} et @file{@var{n}.y}_! Dans ce cas, @file{@var{n}.c} est
appelé un  @dfn{fichier intermédiaire}.  Une fois que @code{make} a
décidé d'utiliser ce fichier intermédiaire, il est entré dans la base de
données comme s'il avait été mentioné dans le  makefile, avec les règles
implicites qui disent comment le créer.@refill

Les fichiers intermédiaires sont refaits en utilisant leurs règles,
juste comme tous les autres fichiers. Mais les fichiers intermédiaires
sont traités différement de deux façons.

La première différence est que ce qui se passe dans le fichier
intermédiaire n'existe pas. Si un fichier ordinaire @var{b} n'existe pas
et que @code{make} considère une cible qui dépend de @var{b}, ceci crée
invariable ment @var{b} et ensuite met à jour la cible à partie de
@var{b}.  Mais si @var{b} est un fichier intermédiaire, alors
@code{make} peut très bien le laisser tout seul. Il ne cherchera pas à
mettre à jour @var{b} ou la cible finale, sauf si des pré-requis de
@var{b} sont plus récents que la cible ou qu'il y ait d'autres raisons
pour mettre à jour la cible.

La seconde différence est que si @code{make} @emph{crée} @var{b} pour
mettre à jour quelque chose d'autre, il effacera @var{b} plus tard quand
il ne sera plus utile.  C'est pourquoi un fichier intermédiaire qui
n'existe pas avant que @code{make} ne le construise n'existe pas non
plus après la fin d'exécution de @code{make}. Le programme @code{make}
vous informe de l'effacement en renvoyant une commande @samp{rm -f} qui
montre quels sont les fichiers qu'il a effacés.

Normalement un fichier ne peut pas être un fichier intermédiaire s'il
est mentionné dans le makefile comme une cible ou un
pré-requis. Cependant, vous pouvez marque un fichier explicitement comme
fichier intermédiaire en le listant comme un pré-requis de la cible
spéciale @code{.INTERMEDIATE}.  Ceci prend effet même si le fichier est
rementionné plus tard explicitement d'une autre façon.

@cindex fichiers inntermédiaires, préserver
@cindex préserver les fichiers intermédiaires
@cindex fichiers secondaires
Vous pouvez empêcher l'effacement automatique d'un fichier intermédiaire
en le marquand comme fichier @dfn{secondaire}. Pour le faire, listez le
comme un pré-requis de la cible spéciale @code{.SECONDARY}.  Quand un fichier
est secondaire, le programme @code{make} ne créera pas le fichier
seulement parcequ'il n'existe pas, mais @code{make} n'effacera pas le
fichier automatiquement.  Marquer un fichier comme condaire le marque
aussi comme intermédiaire.

Vous pouvez lister le modèle de cible d'une règle implicite (comme
@samp{%.o}) comme un pré-requis de al cible spéciale @code{.PRECIOUS}
pour préserver les fichiers intermédiaires construits par des règles
implicite dont le modèle de règle correspond ce nom de fichier@tie{};
voir @ref{Interruptions}.@refill
@cindex préserver avec @code{.PRECIOUS}
@cindex @code{.PRECIOUS} fichiers intermédiaires

Un enchaînement peut impliquer plus de deux règles implicites. Par
exemple, il est possible de construire un fichier @file{foo} à partir de
@file{RCS/foo.y,v} en exécutant RCS, Yacc et @code{cc}.  Les deux
fichiers @file{foo.y} et @file{foo.c} sont des fichiers intermédiaires
qui seront effacés à la fin.@refill

Mais aucune règle implicite ne peut apparaître plus d'une fois dans un
enchaînement. Ceci signifie que @code{make} ne considèrera pas quelque
chose d'aussi ridicule que de construire @file{foo} à partir de
@file{foo.o.o} en exécutant l'éditeur de liens deux fois. Cette
constrainte a l'avantage supplémentaire d'empêcher les boucles infinies
dans la recherche d'un enchaînement de règles implicites.

Il y a des règles implicites particulières pour optimiser certains cas,
qui seraient autrement gérés par des enchaînements de règles. Par
exemple construire @file{foo} à partir de @file{foo.c} peut être traité
en compilant et en liant avec des enchaînements séparés de règles en
utilisant @file{foo.o} comme un fichier intermédiaire.  Mais ce qui se
passe en réalité est qu'une règle spéciale pour cas exécute la
compilation et lie avec une commande @code{cc} unique.  La règle
optimisée est utilisée préfrentiellement avec un enchaînement pas à pas,
car elle vient avant dans l'ordre des règles.

Finalement pour des raisons de performances, @code{make} ne considère
pas les règles non-terminale qui corresponde à tout (i.e., @samp{%:})
quand il recherche une règle pour construire le pré-requis d'une règle
implicite (@pxref{Régles pour correspondre à tout}).

@node Modèle de règles, Dernier ressort, Enchaînement de règles implicites, Les règles implicites
@section Définir et redéfinir des modèles de règles

Vous définissez une règle implicite en écrivant un @dfn{modèle de
règle}. Un modèle de règle ressemble à une règle ordinaire, excepté que
ses cibles contiennent le caractère @samp{%} (exactement un seul). La
cible est considérée être le modèle pour faire correspondre les noms de
fichiers@tie{}; le @samp{%} correspondra à n'importe quelle sous-chaîne
non vide, pendant que les autres caractères ne pourront correspondre
qu'avec eux-mêmes. Les pré-requis utiliseront @samp{%} de la même façon
pour montrer les noms en relations avec le nom de la cible.

Ainsi un modèle de règle @samp{%.o@tie{}: %.c} dit comment construire
n'importe quel fichier @file{@var{radical}.o} à partir d'un autre fichier
@file{@var{radical}.c}.@refill

Notez que le développement utilisant @samp{%} dans le modèle de règle
n'interviendra @strong{qu'après} tout développement de variable, qui
pourrait intervenir quand le makefile est lu. @xref{Utiliser les
variables,,Comment utiliser les variables}, et @ref{Les fonctions,
,Fonctions pour transformer les textes}.

@node Introduction aux modèles, Exemple de modèles, Modèle de règles, Modèle de règles
@subsection Introduction aux modèles de règles
@cindex modèle de règle
@cindex règle, modèle

Un modèle de règle contient le caractère @samp{%} (exactement un seul)
dans sa cible@tie{}; autrement, il ressemble à une règle ordinaire. La
cible est un modèle pour correspondre à des noms de fichiers@tie{}; Le
caractères @samp{%} correspond à toute sous-chaîne non vide, alors que
les autres caractères ne correspondent qu'avec eux-mêmes.
@cindex modèle de cible, implicite
@cindex @code{%}, dans les modèles de règles

Par exemple, @samp{%.c} est un modèle qui correspond à tous les noms de
fichiers qui terminent par @samp{.c}.  @samp{s.%.c} est un modèle qui
correspond à tous les fichiers qui commencent par @samp{s.} et se
terminent par @samp{.c} et qui sont longs d'au moins cinq caractères.
(Il doit y avoir au moins un caractère correspondant à @samp{%}.)  La
sous-chaîne qui correspond au @samp{%} est appelée le
@dfn{radical}.@refill


Le caractère @samp{%} dans un pré-requis d'un modèle de règle prend le
même le radical que celui qui correspond pour le caractère @samp{%} de la
cible. Pour qu'un modèle de règle s'applique, il faut que le modèle de
sa cible corresponde au nom de fichier qui est en traitement et
que tous ses pré-requis nomment des fichiers qui existent (après
substitution de modèle) ou peuvent être construits. Ces fichiers
deviennent alors les pré-requis de la cible.
@cindex modèle des pré-requis, implicite

Donc une règle de la forme

@example
%.o : %.c ; @var{recipe}@dots{}
@end example

@noindent
spécifie comment faire le fichier @file{@var{n}.o} avec un autre fichier
@file{@var{n}.c} comme requis, sous condition que @file{@var{n}.c}
existe ou puisse être fait.

Il peut aussi y avoir des pré-requis qui n'utilisent pas @samp{%}@tie{};
un tel pré-requis s'applique à tous les fichiers faits à partir de ce
modèle de règle. Ces pré-requis invariants sont parfois utiles.

Un modèle de règle n'a pas besoin d'avoir un pré-requis qui contienne
@samp{%} et en fait même d'avoir des pré-requis. Une telle règle est en
fait une règle générique. Elle fournit un moyen de faire n'importe quel
fichier qui correspond au modèle de la règle.  @xref{Dernier ressort}.

Une cible peut être visée par plusieurs modèles de règles. Dans ce cas,
@code{make} choisira celle qui correspond le mieux.  @xref{Correspondance de
modèle, ,Comment les modèles trouvent les correspondances}.

@cindex Les cibles multiples, dans un modèle de règle
@cindex cibles, multiples dans un modèle de règle
Les modèles de règle peut avoir plus d'une cible@tie{}; cependant,
chaque cible doit contenir le caractère générique @code{%}. Les modèles
de règles sont toujours traités comme des cibles groupées (@pxref{Les cibles
multiples, , Les cibles multiples pour une règle}) que ce soit en utilisant 
@code{:} ou @code{&:} comme séparateur.


@node Exemple de modèles, Les variables automatiques, Introduction aux modèles, Modèle de règles
@subsection Exemples de modèles de règles

Voici quelques exemples de modèles de règles, qui sont en réalité
prédéfinies and @code{make}. D'abord, la règle qui compile les fichiers @samp{.c}
en fichiers @samp{.o}@tie{}:@refill

@example
%.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@@
@end example

@noindent
définie une règle qui compile tout fichier @file{@var{x}.o} à partir de
@file{@var{x}.c}. L'instruction utilise les variables automatiques
@samp{$@@} et @samp{$<} pour substituer les noms du fichier cible et du
fichier source dans chaque cas où la règle s'applique (@pxref{Les variables
automatiques}).@refill

Voici une second règle prédéfinie@tie{}:

@example
% :: RCS/%,v
        $(CO) $(COFLAGS) $<
@end example

@noindent
définit une règle qui peut compiler n'importe quel fichier
@file{@var{x}}, quelque soit le fichier @file{@var{x},v} correspondant
dans le sous-répertoire @file{RCS}.  Comme la cible est @samp{%}, la
règle s'appliquera à n'importe quel fichier, tant que le fichier
pré-requis approprié existe. Le double double points en fait une règle
@dfn{terminal}, ce qui veut dire que ces pré-requis ne peuvent pas être
un fichier intermédiaire (@pxref{Régles pour correspondre à tout,
,Règles pour correspondre à tout}).@refill

@need 500
Ce modèle de règle a deux cibles@tie{}:

@example
@group
%.tab.c %.tab.h: %.y
        bison -d $<
@end group
@end example

@noindent
@c The following paragraph is rewritten to avoid overfull hboxes
@code{make} fait que l'instruction @samp{bison -d @var{x}.y}
fabriquera à la fois @file{@var{x}.tab.c} et @file{@var{x}.tab.h}.  Si
le fichier @file{foo} dépend des fichiers @file{parse.tab.o} et
@file{scan.o} et le fichier @file{scan.o} dépend du fichier
@file{parse.tab.h}, quand @file{parse.y} est modifié, m'instruction
@samp{bison -d parse.y} ne sera exécutée qu'une seule fois, et les
pré-requis des deux fichiers @file{parse.tab.o} et @file{scan.o} seront
satisfaits. (On présume que le fichier @file{parse.tab.o} sera recompilé
à partir du fichier @file{parse.tab.c} et le fichier @file{scan.o} à
partir du fichier @file{scan.c}, alors que @file{foo} est lié avec
@file{parse.tab.o}, @file{scan.o}, and ses autres pré-requis, et il sera
exécuté par après.)@refill


@node Les variables automatiques, Correspondance de modèle, Exemple de modèles, Modèle de règles
@subsection Les variables automatiques
@cindex variables, automatiques
@cindex variables, et règles implicites

Supposez que vous écriviez un modèle de règle qui compile un fichier
@samp{.c} en un fichier @samp{.o}@tie{}: comme écririez vous la règle
pour faire que la commande @samp{cc} opère sur le bon nom de fichier
source@tie{}? Vous ne pouvez pas écrire le nom dans l'instruction, car ce
nom est différent chaque fois qu'une règle implicite est appliquée.

Ce que vous ferez est d'utiliser cette fonctionalité particulière de
@code{make} qui sont les @dfn{variables automatiques}.  Ces variables
ont des valeurs fraîchement redéterminée à chaque exécution de règle, sur
la base de la cible et des pré-requis de cette règle.  Dans cet exemple,
vous utiliseriez @samp{$@@} pour le nom du fichier objet et @samp{$<}
pour le nom du fichier source.

@cindex variables automatiques dans les pré-requis
@cindex pré-requis, et variables automatiques
Il est très important que vous déterminiez la limite d'applicabilité
dans laquelle les variables automatiques sont disponibles@tie{}: elles
n'ont de valeur qu'à l'intérieur d'une instruction. En particulier, vous
ne pouvez pas les utiliser dans la liste des cibles d'une règle@tie{};
elles n'auront aucune valeur à cet endroit et se développeront donc
comme une chaîne vide.  Elles ne peuvent pas non plus être accédées
directement depuis la listes des pré-requis d'une règle. Une erreur
commune est d'essayer d'utiliser @code{$@@} dans la liste des
pré-requis@tie{}; ceci ne fonctionne pas.  Cependant, il existe une
fonctionalité spéciale de GNU @code{make}, le développement secondaire
(@pxref{Les développements secondaires}), qui permettra d'utiliser les
variables automatiques dans les listes de pré-requis.

Voici une table des variables automatiques@tie{}:

@table @code
@vindex $@@
@vindex @@ @r{(variable automatique)}
@item $@@
Le nom de fichier cible de la règle. Si la cible est un membre
archivé, alors @samp{$@@} est le nom du fichier archivé. Dans un modèle
de règle à plusieurs cibles (@pxref{Introduction aux modèles,
,Introduction aux modèles de règles}), @samp{$@@} est le nom de la cible
qui a été la cause de l'exécution de l'instruction de cette règle.

@vindex $%
@vindex % @r{(variable automatique)}
@item $%
Le nom d'un membre de la cible, quand la cible est un membre archivé.
@xref{Les fichiers archivés}.  Par exemple, si la cible est @file{foo.a(bar.o)} alors
@samp{$%} est @file{bar.o} et @samp{$@@} est @file{foo.a}.  @samp{$%}
est vide quand la cible n'est pas un mebre archivé.

@vindex $<
@vindex < @r{(variable automatique)}
@item $<
Le nom du premier pré-requis.  Si une cible obtient son instruction
d'une règle implicite, ce sera le premier pré-requis ajouté par la règle
implicite (@pxref{Les règles implicites}).

@vindex $?
@vindex ? @r{(variable automatique)}
@item $?
Les noms de tous les pré-requis, qui sont plus récents que la cible
séparés par des espaces.  Si une cible n'existe pas, tous les
pré-requis seront incluent.  Pour les pré-requis qui sont membres d'une
archive, seuls le membre nommé est utilisé (@pxref{Les fichiers archivés}).
@cindex pré-requis, liste des changements
@cindex liste des pré-requis modifiés

@vindex $^
@vindex ^ @r{(variable automatique)}
@item $^
Les noms de tous les pré-requis séparés par des espaces. Pour les
pré-requis, qui sont membres d'une archive, seul le membre nommé est
utilisé (@pxref{Les fichiers archivés}).  Chaque fichier de dépendance d'une cible ne
représente qu'un seul seul pré-requis, indépendamment du nombre de fois
que ce fichier puisse avoir été listé comme pré-requis.  Donc si vous
listez un pré-requis plus d'une fois pour une cible donnée, la valeur de
@code{$^} ne contiendra qu'une seule copie de son nom.  Cette liste ne
contient @strong{aucun} des pré-requis qui pourrait être un pré-requis
de commande seule@tie{}; pour ceux-là utilisez la variable @samp{$|} ci-dessous.
@cindex pré-requis, liste de tous
@cindex liste de tous les pré-requis

@vindex $+
@vindex + @r{(variable automatique)}
@item $+
Comme la variable @samp{$^}, mais pour les pré-requis répétés plus d'une
fois et dans l'ordre d'apparition dans le makefile.  Ceci est
basiquement utile pour lier les commandes, pour lesquelles cela a un
sens de répéter les noms de fichier de bibliothèque dans un ordre particulier.

@vindex $|
@vindex | @r{(variable automatique)}
@item $|
Les noms de tous les pré-requis de commandes seules, séparés
par un espace.

@vindex $*
@vindex * @r{(variable automatique)}
@item $*
Le radical avec lequel une règle implicite correspond
(@pxref{Correspondance de modèle, ,Comment les modèles établissent une
correspondance}). Si la cible est @file{dir/a.foo.b} et le modèle de
cible est @file{a.%.b}, alors le radical est @file{dir/foo}.  Le radical
est utile pour contruire les noms de fichiers correspondants.@refill
@cindex radical, variable

Dans un modèle statique de règle, le radical est la partie du nom de
fichier qui correspond à @samp{%} dans le modèle de cible.

Dans une règle explicite, il n'y a pas de radical@tie{}; donc @samp{$*} ne
peut pas être déterminé ainsi. À la place, si la cible termine par un
suffixe reconnu (@pxref{Règle des suffixes, ,Ancienne règle des
suffixes}), @samp{$*} est défini comme le nom de cible moins le suffixe.
Par exemple, si le nom de la cible est @samp{foo.c}, alors @samp{$*} est
défini comme @samp{foo}, car @samp{.c} est le suffixe.  GNU @code{make}
fait ce genre de chose bizarre seulement pour des raisons de
compatibilités avec les autres implémentations de @code{make}.  Vous
devriez normalement évetier d'utiliser @samp{$*}, excepété dans les
règles implicites ou les modèles statiques de règles.@refill

Si le nom de cible est une règle explicite qui ne termine pas par un
suffixe reconnu, @samp{$*} est défini comme une chaîne vide pour cette
règle.
@end table

@samp{$?} est utile même dans les règles explicites, quand vous voulez
opérer seulement sur les pré-requis qui ont changé. Par exemple,
supposez qu'une archive nommée @file{lib} doivent contenir des copies de
plusieurs fichiers objet. Cette règle ne copie que les fichiers objet
qui ont changé dans l'archive@tie{}:

@example
@group
lib: foo.o bar.o lose.o win.o
        ar r lib $?
@end group
@end example

Dans les variables listées ci-dessous, quatre ont des valeurs qui sont
des noms de fichiers uniques et trois ont comme valeurs des listes de
noms de fichiers. Ces sept variables ont des variantes qui donnent soit
juste le nom du répertoire du fichier, soit le nom du fichier dans le
répertoire. Ces différentes variables sont formées en ajoutant @samp{D}
or @samp{F}, respectivement pour les noms de répertoires
(ndt. ``Directory'') et les noms de fichiers (ndt. ``Files'').  Les
fonctions @code{dir} et @code{notdir} peuvent être utilisées pour
obtenir un effet similaire (@pxref{Les fonctions de noms de fichier, ,
Fonctions pour les noms de fichiers}).  Notez cependant que la variante
utilisant @samp{D} omet la barre oblique en fin alors que le sortie de
la fonction @code{dir} la met toujours.  Voici une table des
variantes@tie{}:

@table @samp
@vindex $(@@D)
@vindex @@D @r{(variable automatique)}
@item $(@@D)
La partie donnant les répertoires dans le nom de fichier de la cible,
avec la barre oblique inversée finale enlevée. Si la valeur de
@samp{$@@} est @file{dir/foo.o} alors @samp{$(@@D)} est @file{dir}.
Cette valeur est @file{.} si @samp{$@@} ne contient pas de barre oblique.

@vindex $(@@F)
@vindex @@F @r{(variable automatique)}
@item $(@@F)
Le partie donnant le nom du fichier dans le répertoire pour le nom de
fichier de la cible. Si la valeur de @samp{$@@} est @file{dir/foo.o}
alors @samp{$(@@F)} est @file{foo.o}.  @samp{$(@@F)} est équivalent à 
@samp{$(notdir $@@)}.

@vindex $(*D)
@vindex *D @r{(automatic variable)}
@item $(*D)
@vindex $(*F)
@vindex *F @r{(variable automatique)}
@itemx $(*F)
La partie répertoires et la partie du nom du fichier dans le répertoire
pour le radical@tie{}; @file{dir} et @file{foo} dans cet exemple.

@vindex $(%D)
@vindex %D @r{(variable automatique)}
@item $(%D)
@vindex $(%F)
@vindex %F @r{(variable automatique)}
@itemx $(%F)
La partie répertoires et la partie du nom du fichier dans le répertoire
pour le membre d'une archive. Cela n'a de sense que pour membre d'archive
de cibles de la forme @file{@var{archive}(@var{membre})} et c'est utile
seulement quand @var{membre} est suceptible de contenir des noms de
répertoires.  (@xref{Les membres d'une archive, ,Membre d'une cible archivée}.)

@vindex $(<D)
@vindex <D @r{(variable automatique)}
@item $(<D)
@vindex $(<F)
@vindex <F @r{(variable automatique)}
@itemx $(<F)
La partie répertoires et la partie du nom du fichier dans le répertoire
du premier pré-requis.


@vindex $(^D)
@vindex ^D @r{(variable automatique)}
@item $(^D)
@vindex $(^F)
@vindex ^F @r{(variable automatique)}
@itemx $(^F)
Les listes des répertoires et des noms des fichiers dans le répertoire
de tous les pré-requis.

@vindex $(+D)
@vindex +D @r{(variable automatique)}
@item $(+D)
@vindex $(+F)
@vindex +F @r{(variable automatique)}
@itemx $(+F)
Les listes des répertoires et des noms des fichiers dans le répertoire
de tous les pré-requis, incluant les instances multiples des pré-requis
dupliqués.

@vindex $(?D)
@vindex ?D @r{(variable automatique)}
@item $(?D)
@vindex $(?F)
@vindex ?F @r{(variable automatique)}
@itemx $(?F)
Les listes des répertoires et des noms des fichiers dans le répertoire
de tous les pré-requis qui sont plus récent que la cible.
@end table

Notez que nous utilisons une convention stylistique particulière, quand
nous parlons de ces variables automatiques@tie{}; nous écrivons ``la
valeur de @samp{$<}'' plutôt que @w{``la variable @code{<}''} comme nous
le ferions pour une variable ordinaire comme @code{objects} et
@code{CFLAGS}.  Nous pensons que cette convention parait plus naturelle
dans ce cas particulier. Ne pensez pas cependant que cela ait une
signfication très profonde@tie{};
@samp{$<} se réfère à la variable nommée @code{<} juste comme @samp{$(CFLAGS)}
se réfère à la variable nommée @code{CFLAGS}.  Vous pourriez juste
utiliser aussi @samp{$(<)} à la place de @samp{$<}.

@node Correspondance de modèle, Régles pour correspondre à tout, Les variables automatiques, Modèle de règles
@subsection Comment les modèles établissent une correspondance

@cindex stem
Un modèle de cible est composé d'un @samp{%} entre un préfixe et un
suffixe, l'un des deux pouvant être vide. Le modèle correspond à un nom
de fichier seulement si le nom de fichier commence par ce préfixe et
termine par ce suffixe, sans recouvrement. Le texte entre le préfixe et
le suffixe est appelé le @dfn{radical} (ndt. ``stem''). Donc le modèle
@samp{%.o} s'applique au nom de fichier @file{test.o} et le radical est
@samp{test}. Le modèle de règle de pré-requis sont convertis en noms de
fichiers réels en substituant le radical au caractère @samp{%}. Donc dans
le même exemple, un des pré-requis s'écrit @samp{%.c} et il se développe
en @samp{test.c}.@refill

Quand le modèle de cible ne contient pas de barre oblique (et il ne
contient pas habituellement), les noms de répertoires sont enlevés des
noms de fichiers avant qu'ils ne soit comparés avec le préfixe et le
suffixe de la cible. Après la comparaison des noms de fichiers avec le
modèle de la cible, les noms de répertoires, avec les barres obliques
qui les terminent sont ajoutés sur les noms de fichiers pré-requis
généré en accords avec les règles du modèle des pré-requis et les noms
de fichiers. Les répertoires sont ignorés seulement au moment de la
recherche d'une règle implicite à utiliser, pas au moment d'appliquer
cette règle. Donc @samp{e%t} va correspondre aux noms de fichiers
@file{src/eat}, avec @samp{src/a} comme radical. Quand les pré-requis sont
transformés en noms de fichiers, les répertoires du radical sont ajoutés
au front alors que le reste du radical se substitue à @samp{%}. Le radical
@samp{src/a} avec un modèle pré-requis @samp{c%r} donne le nom de
fichier @file{src/car}.@refill

@cindex modèle de règle, ordre
@cindex ordre des modèle de règles
Un modèle de règle peut être utilisé pour construire un fichier donné
seulement s'il y a un modèle de règle qui correspond au nom du fichier,
@emph{et} si tous les pré-requis de cette règle existent ou peuvent être
construits. Les règles que vous écrivez ont la priorité sur les règles
prédéfinies. Notez cependant qu'une règle dont les pré-requis existent
bien ou sont mentionnés est toujours prioritaire sur une règle dont les
pré-requis doivent être faits en enchaînant d'autres règles implicites.

@cindex radical, le plus court
Il est possible que plus d'un modèle de règle correpondent à ces
critères. Dans ce cas, @code{make} choisira la règle qui a le radical le
plus court (c'est à dire, le modèle qui correspond le plus
spécifiquement).  Si plus d'un modèle de règle a le radical le plus court,
@code{make} choisira la première trouvée dans le makefile.

Le résultat de cet algorithme est que les règles les plus spécifiques
sont préférées à celles qui sont plus générique@tie{}; par
exemple@tie{}:

@example
%.o: %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@@

%.o : %.f
        $(COMPILE.F) $(OUTPUT_OPTION) $<

lib/%.o: lib/%.c
        $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) $< -o $@@
@end example

Étant donné ces règles et la requète de compiler @file{bar.o} avec
@file{bar.c} et @file{bar.f} existants, @code{make} choisira la première
règle et compilera @file{bar.c} en @file{bar.o}.  Dans la même situation
mais où @file{bar.c} n'existe pas, @code{make} choisira la seconde règle
et compilera @file{bar.f} en @file{bar.o}.

Si on demande à @code{make} de compiler @file{lib/bar.o} et que les deux
fichiers @file{lib/bar.c} et @file{lib/bar.f} existent, alors la
troisième règle sera choisie car le radical pour cette règle (@samp{bar})
est plus court que le radical pour la première règle (@samp{lib/bar}).  Si
@file{lib/bar.c} n'existe pas, alors cette troisième règle n'est pas
elligible et c'est donc la seconde règle qui sera utilisée, même si son
radical est plus long.


@node Régles pour correspondre à tout, règles d'annulation, Correspondance de modèle, Modèle de règles
@subsection Le modèle de règle qui correspond à tout

@cindex règle qui correspond à tout
@cindex règle terminale
Quand un modèle de règle de cible contient juste @samp{%}, il correspond
à n'importe quel fichier quelqu'il soit. Nous appelons ces règles des
règles qui @dfn{correspondent à tout}. Elles sont très utiles, mais cela
peut prendre du temps avant que @code{make} ne pense à elles, car il
doit considérer chacune de ces règles pour chacun des fichiers listés
soit comme une cible ou comme un pré-requis.

Supposons que le makefile mentionne @file{foo.c}. Pour cette cible,
@code{make} devrait considérer de le constuire en liant un fichier objet
@file{foo.c.o}, ou par une compilation C et en liant en une seule étape
depuis @file{foo.c.c} ou par une compilation Pascal et en liant à partir
de @file{foo.c.p} et bien d'autres possiblités.

Nous savons que ces possibilités sont ridicules parceque @file{foo.c}
est un fichier source C, et pas un exécutable. Si @code{make} considère
ces possibilités, il les rejetterait finalement, car ces fichiers
@file{foo.c.o} et @file{foo.c.p} n'esxisteraient pas. Mais ces
possiblités sont nombreuses ce qui ferait que @code{make} s'exécuterait
vraiment lentement s'il devait les considérer. @refill

Pour gagner de la vitesse, nous avons mis plusieurs contraintes dans la
façon dont @code{make} doit considérer les règles qui correspondent à
tout. Il y a deux contraintes différentes qui peuvent être appliquées et
chaque fois que vous définissez une règle qui correspond à tout, vous
devez choisir l'une d'entre elle pour la lui appliquer.

Un choix est de marquer la règle qui correspond à tout comme
@dfn{terminale} en la définissant avec deux points. Quand une règle est
terminale, elle ne s'applique que si son pré-requis existe
réellement. Les pré-requis qui pourraient être construits avec d'autres
règles implicites ne sont pas assez biens. En d'autres termes, il n'y
aura pas d'autres enchainement permis après une règle terminale.

Par exemple, les règles implicite prédéfinies pour extraire les
fichiers sources d'un fichier RCS et SCCS sont des règles
terminales@tie{}; il en résulte que si le fichier @file{foo.c,v}
n'existe pas, @code{make} ne cherchera même pas à faire un fichier
intermédiaire depuis @file{foo.c,v.o} ou depuis
@file{RCS/SCCS/s.foo.c,v}.  Les fichiers RCS et SCCS sont généralement
les fichiers souces ultimes, qui ne devraient pas être refait depuis
d'autres fichiers@tie{}; c'est pourquoi, @code{make} économise du temps
en ne recherchant de moyens pour les refaire.@refill

Si vous ne marquez pas la règle qui correspond à tout comme un règle
terminale, alors elle sera non-terminale. Une règle non-termnale et qui
correspond à tout ne peut pas être appliquée à un pré-requis d'une règle
implicite ou à un nom de fichier qui indique un type spécifique de
données. Un nom de fichier indique un type de données spécifiques si
certaines règles, qui ne sont pas des règles qui correspondent à tout,
lui correspondent.

Par exemple, le nom de fichier @file{foo.c} correspond à la cible pour
le modèle de règle @samp{%.c@tie{}: %.y} (la règle pour exécuter Yacc).
Sans tenir compte si cette règle est en réalité applicable ou non (ce
qui se passe seulement si un fichier @file{foo.y} existe), le fait que
sa cible corresponde est suffisant pour ne pas considérer de règle
non-terminale, ou qui soit une règle qui correspond à tout, pour le
fichier @file{foo.c}. Donc @code{make} n'essayera pas de faire un faire
de @file{foo.c} un exécutable à partir de @file{foo.c.o},
@file{foo.c.c}, @file{foo.c.p}, etc.@refill

Ce qui motive cette contrainte est que les règles non-terminales et qui
correspondent à tout, sont utilisées pour faire des fichiers qui
contiennent certains types de données (comme des fichiers executables)
et un nom de fichier avec un suffixe reconny indique un autre type de
données (comme un fichier source en C).

Des modèles de règles spéciaux, fictifs et prédéfini sont fournis dans
le seul but de reconnaître certains noms de fichier, de telle manière
que les règles non-terminales et qui correspondent à tout ne soit pas
considérées. Ces règles fictives n'ont pas de pré-requis et pas
d'instructions et elles sont ignorées pour tous les autres usages. Par
exemple, la règle implicite prédéfinie

@example
%.p :
@end example

@noindent
existe pour être sûr que le fichier source en Pascal, comme par exemple
@file{foo.p}, corresponde à un modèle de cible spécifique et par là
empêche de gaspiller du temps en recherchant @file{foo.p.o} ou
@file{foo.p.c}.

Les modèles de règles fictives comme celle pour @samp{%.p} sont faites
pour tous les suffixes listés d'utilisation valide dans les règles de
suffixe (@pxref{Règle des suffixes, ,Ancienne règle des suffixes}).


@node règles d'annulation, , Régles pour correspondre à tout, Modèle de règles
@subsection Annuler les règles implicites

Vous pouvez remplacer une règle implicite prédéfinie (ou une que vous
avez définie vous-même) en définissant un noveau modèle de règle avec la
même cible et les mêmes pré-requis, mais une instruction différente.
Quand la nouvelle règle est définie, celle qui était prédéfinie est
remplacée.  La nouvelle position de la règle dans la séquence de règles
implicites est déterlinée par l'endroit où vous écrivez le nouvelle
règle.

Vous pouvez annuler les règles implicites prédéfinies en définissant
un modèle de règle avec la même cible et les mêmes pré-requis mais aucune
instructions. Par exemple, L'instruction suivante annulera la règle qui
exécute l'assembleur@tie{}:

@example
%.o : %.s
@end example


@node Dernier ressort, Règle des suffixes, Modèle de règles, Les règles implicites
@section Définir les règles de dernier ressort par défaut
@cindex règles par défaut de dernier ressort
@cindex règles par défaut, dernier ressort

Vous pouvez définir une règle implicite de dernier ressort en écrivant
un modèle terminal de règle qui corresponde à tout et n'ayant aucun
pré-requis ((@pxref{Régles pour correspondre à tout}@tie{}). Ceci
s'écrit comme n'importe quel autre modèle de règle@tie{}; la seule chose
qui change ici, est que cette règle pourra s'appliquer à n'importe
quelle cible. Une telle instruction est donc utilisée pour les cibles et
pré-requis qui n'ont pas d'instructions qui leur soient propres et pour
qui, aucune autre règle implicite ne peut s'appliquer.

Par exemple, lors du test d'un makefile, vous pourriez ne pas vous
soucier de savoir si les fichiers source contiennent ou non des données
réelles, il suffit qu'ils existent. Dans ce cas, vous pourriez écrire
ceci@tie{}:

@example
%::
        touch $@@
@end example

@noindent
ce qui créera automatiquement tous les fichiers source requis (comme
pré-requis).

@findex .DEFAULT
Vous pouvez aussi, à la place, définir une instruction à utiliser pour
toutes le cibles pour lesquelles il n'y aurait aucune règle, même de
celles qui ne définissent aucune instruction. Ceci se réalise en
écrivant une règle pour la cible @code{.DEFAULT}. Une telle instruction
est alors utilisée pour tous les pré-requis, qui n'apparaissent pas
comme cible dans aucune des règles explicites et pour lesquels aucune
règle implicite ne s'applique non plus.  Naturellement, il n'existe
aucune règle pour @code{.DEFAULT} avant que vous n'en écriviez une.

Si vous utilisez @code{.DEFAULT} avec aucune instruction et aucun pré-requis@tie{}:

@example
.DEFAULT:
@end example

@noindent
l'instruction qui aura été stockée précédemment pour @code{.DEFAULT}
sera effacée.  Dans ce cas @code{make} agira comme si vous n'aviez
jamais défini @code{.DEFAULT}.

Si vous ne voulez pas qu'une cible reçoive l'instruction d'un modèle
de règle qui peut correspondre à tout ou de @code{.DEFAULT}, mais que vous ne
vouliez pas non plus qu'aucune instruction ne soit exécutée pour cette
cible, vous pouvez lui donner une instruction vide (@pxref{Instructions
vides, ,Définir des instructions vides}@tie{}).@refill

Vous pouvez utiliser les règle de dernier ressort pour remplacer une
partie d'un autre makefile.
@xref{Reconstruire les Makefiles, ,Remplacer une partie d'un autre Makefile}.

@node Règle des suffixes, Recherche de règles implicites, Dernier ressort, Les règles implicites
@section Ancienne règle des suffixes
@cindex old-fashioned suffix rules
@cindex suffix rule

La @dfn{règle des suffixes} est une ancienne façon de définir une règle
implicite pour @code{make}. Les règles de suffixes sont obsolètees
parceque les modèles de règles sont plus généraux et plus clairs. Elle
est supportée dans GNU @code{make} pour garder la compatibilité avec les
anciens makefiles.  Elle vient avec deux sortes@tie{}:
@dfn{à-suffixes-doubles} et @dfn{à-suffixe-simple}.@refill

Une règle à double suffixes est définie par une paire de suffixes@tie{}:
le suffixe de la cible et le suffixe de la source. Elle correspond à
tous les fichiers dont les noms se terminent par le suffixe de la
cible. Les pré-requis implicites correspondants sont obtenus en
replaçant la suffixe de la cible par le suffixe de la source dans les
noms de fichiers. Un règle à deux suffixes @samp{.c.o} (dont les
suffixes de cible et source sont respectivement @samp{.o} and @samp{.c})
est équivalente au modèle de règle @samp{%.o@tie{}: %.c}.

Une règle à suffixe simple est définie par un seul suffixe, qui est la
suffixe de la source. Elle correspond à tous les noms de fichiers et le
nom de fichier du pré-requis implicite correspondant est obtenu en
ajoutant le suffixe de la source. Un règle à suffixe simple, dont le
suffixe sources est @samp{.c} est équivalent au modèle de règle
@samp{%@tie{}: %.c}.

Les définitions des règles de suffixes sont reconnues en comparant
chaque règle de cible à une liste définie de suffixes connus. Quand
@code{make} trouve une règle dont la cible est un suffixe connu, cette
règle est considérée comme une règle à suffixe simple. Quand @code{make}
trouve une règle dont la cible est deux suffixes connus concaténés,
cette règle est prise pour une règle à double suffixe.

Par exemple, @samp{.c} et @samp{.o} sont tous les deux sur la liste par
défaut des suffixes connus. Donc si vous définissez une règle dont la
cible est @samp{.c.o}, @code{make} la prend pour une règle à double
suffixes avec le suffixe de source @samp{.c} et le suffixe de cible
@samp{.o}.  Voici l'ancienne façon de définir la règle pour compiler des
programme à partir d'un fichier source C@tie{}:@refill

@example
.c.o:
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@@ $<
@end example

Les règles de suffixes ne peuvent pas avoir de pré-requis à elles.  Si
elles en avaient, elle seraient traité comme des fichiers normaux avec
des noms bizarres, mais pas comme des règles à suffixes. Donc la
règle@tie{}:


@example
.c.o: foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@@ $<
@end example

@noindent
dit comment faire le fichier @file{.c.o} à partir du fichier pré-requis
@file{foo.h}, et ce n'est pas du tout comme le modèle de règle@tie{}:

@example
%.o: %.c foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@@ $<
@end example

@noindent
qui dit comment faire des fichiers @samp{.o} à partir de fichiers
@samp{.c} et fait que tous les fichiers @samp{.o} qui utilisent ce
modèle de règle, dépendent aussi de  @file{foo.h}.

Les règles de suffixe sans instruction sont aussi sans
signification. Elle n'enlève pas la anciennes règles comme le font les
modèles de règles sans instruction (@pxref{règles d'annulation, ,
Annueler les règles implicites}). Elle entre simplement un suffixe ou
une paire de suffixes concaténés comme cible dans la base de
données.@refill

@findex .SUFFIXES
Les suffixes connus sont simplemment les noms des pré-requis de la cible
spéciales @code{.SUFFIXES}. Vous pouvez ajouter vos propres suffixes en
écrivant une règle pour @code{.SUFFIXES}, qui lui ajoute d'autres
pré-requis comme ici@tie{}:

@example
.SUFFIXES: .hack .win
@end example

@noindent
qui ajoute @samp{.hack} et @samp{.win} à la fin de la liste des suffixes.

Si vous voulez éliminer les suffixes connus par défaut à la place de
juste les ajouter, écrivez une règle pour @code{.SUFFIXES} sans
pré-requis. Par dispensation spéciales, ceci élimine tous les pré-requis
existant de @code{.SUFFIXES}.  Vous pouvez écrire une autre règle qui
ajouter les suffixes que vous voulez. Par exemple,

@example
@group
.SUFFIXES:            # @r{Efface les suffixes par défaut}
.SUFFIXES: .c .o .h   # @r{Définit votre liste de suffixes}
@end group
@end example

L'option @samp{-r} ou @samp{--no-builtin-rules} fait que la liste des
suffixes est vide.

@vindex SUFFIXES
La variable @code{SUFFIXES} est définie sur la liste des suffixes par
défaut avant que @code{make} ne lise aucun makefiles.  Vous pouvez
changer la liste des suffixes avec une règle pour la cible spéciale
@code{.SUFFIXES}, mais elle ne changera pas cette variable.

@node Recherche de règles implicites, , Règle des suffixes, Les règles implicites
@section Algorithme de recherche de règle implicite
@cindex règle implicite, algorithme de recherche
@cindex algorithme de recherche, règle implicite

Voici la procédure qu'utilise @code{make} pour rechercher une règle
implicite pour une cible @var{t}. Cette procédure est suivie pour chaque
règle à double double points sans recette, pour chaque cible sans
instruction, pour chaque cible de règles ordinaires dont nulles n'a une
instruction et pour chaque pré-requis qui n'est la cible d'aucune règle.
Elle est aussi suivi récursivement pour les pré-requis qui viennent des
règles implicites, dans la recherche d'un enchaînement de règles.

Les règles de suffixes ne sont pas mentionnées dans cet algorithme, car
les règles de suffixes sont converties en leur modèles de règles
équivalents, une fois que le makefiles les a lues.

Pour la cible d'un membre d'archive de la forme @samp{@var{archive}(@var{membre})},
l'algorithme qui suit est exécutés deux fois, la première fois en
utilisant le nom entier de la cible @var{t}, et une seconde en utilisant
@samp{(@var{member})} comme la cible @var{t} si la première ne trouve
aucune règle.@refill

@enumerate
@item
Découpe @var{t} en une partie nom de répertoire, appelée @var{d}, et le
rest, appelé @var{n}. Par exemple, si @var{t} est @samp{src/foo.o},
alors @var{d} est @samp{src/} et @var{n} est @samp{foo.o}.@refill

@item
Fait une liste de tous les modèles de règles dont l'une des cibles
correspond à @var{t} ou à @var{n}.  Si la modèle de cible contient une
barre oblique, la correspondance est recherchée pour @var{t}@tie{};
sinon pour @var{n}.

@item
Si @emph{aucune} règle de la liste n'est une règle qui correspond à tout
ou si @var{t} est un pré-requis d'une règle implicite, alors enlève toutes
les règles terminales qui correspondent à tout de la liste.

@item
Enlève de la liste toutes les règles sans instructions.

@item
Pour chaque modèle de règle de la liste@tie{}:

@enumerate a
@item
Trouver le radical @var{s}, qui est la partie non vide de @var{t} ou de @var{n}
correspondant à @samp{%} dans le modèle de la cible.@refill

@item
Détermine les noms des pré-requis en substituant @var{s} à la place de
@samp{%}@tie{}; si le modèle de cible ne contient pas de barre oblique,
ajoute @var{d} au début de chaque nom de pré-requis.@refill

@item
Teste si tous les pré-requis existent ou devraient pouvoir exister.  (Si
un nom de fichier est mentioné dans le makefile comme une cible ou comme
un pré-requis explicite, alors nous disons qu'il devrait pouvoir
exister.@tie{})

Si tous les pré-requis existent ou devrait pouvoir exister ou s'il n'y a
pas de pré-requis, alors cette règle s'applique.
@end enumerate

@item
Si aucun modèle de règle n'a été trouvé jusqu'à présent, chercher encore.
Pour chaque modèle de règle dans la liste@tie{}:

@enumerate a
@item
Si la règle est terminale, ignorer la et allez à la règle suivante.

@item
Déterminer les noms des pré-requis comme précédemment.

@item
Tester si tous les pré-requis existent ou devraient exister.

@item
Pour chaque pré-requis qui n'existe pas, suivre cet algorithme
récursivement pour voir si le pré-requis peut être fabriqué avec une
règle implicite.

@item
Si tous les pré-requis existent ou devraient pouvoir exister ou peuvent
être fabriquer par des règles implicites, alors cette règle s'applique.
@end enumerate

@item
Si aucun règle implicite ne s'applique, la règle pour @code{.DEFAULT},
si elle existe, s'applique. Dans ce cas, donner à @var{t} la même
instruction que celle que @code{.DEFAULT} a. Sinon, il n'y a aucune
instruction pour @var{t}.
@end enumerate

Une fois qu'une règle qui s'applique a été trouvée, pour chaque modèle
de règle de la règle autre que ceux qui ont correspondus avec @var{t} ou
@var{n}, le @samp{%} dans le modèle est remplacé par @var{s} et le nom
de fichier résultat est conservé jusqu'à ce que l'instruction pour
recompiler le fichier cible @var{t} soit exécuté. Après que
l'instruction ait été exécutée, chacun de ces noms de fichiers conservés
sont entrés dans la base de données et marqués comme ayant été mis à
jour et ayant le même status de mise à jour que le fichier @var{t}.

Quand une instruction d'un modèle de règle est exécutée pour @var{t},
les variables automatiques sont définies en fonction de la cible et des
pré-requis.  @xref{Les variables automatiques}.


@node Les fichiers archivés, Compléter make par des extensions, Les règles implicites, Top
@chapter Using @code{make} to Update Archive Files 
@cindex archive

@dfn{Les fichiers d'archive} sont des fichiers contenant des
sous-fichiers nommés @dfn{membres}@tie{}; ils sont maintenus avec le
programme @code{ar} et leur utilisation principale est une
bibliothèques de sous-routine pour l'édition de liens..

@node Les membres d'une archive, Archive Update, Les fichiers archivés, Les fichiers archivés
@section Membres d'une archive comme cibles
@cindex membres d'archive cible

Un membre de fichier archive peut être utilisé comme une cible ou un
pré-requis dans @code{make}. Vous spécifiez le membre nommé @var{member}
dans un fichier archine nommé @var{archive} de la manière suivante@tie{}:

@example
@var{archive}(@var{member})
@end example

@noindent
Cette construction est disponible seulement dans les cibles ou les
pré-requis, pas dans les règles@tie{}! La plupart des programmes, que
vous pourriez utiliser dans vos règles ne supporte pas cette syntaxe et
ne peuvent pas agir directement sur les membres d'une archive. Seul
@code{ar} et d'autre programmes conçus spécifiquement pour opérer sur
des archives peuvent le faire. C'est pourquoi, les règles valables pour
mettre à jour une cible, qui soit un membre d'une archive devront
probablement utiliser @code{ar}.  Par exemple, cette règle dit de créer
un membre @file{hack.o} dans l'archive @file{foolib} en copiant le
fichier @file{hack.o}:

@example
foolib(hack.o) : hack.o
        ar cr foolib hack.o
@end example

En fait, presque toutes les cibles portant sur un membre d'archive sont
mises à jour juste de cette façon et il existe une règle implicite pour
le faire pour vous.  @strong{Please note:} l'option @samp{c} de
@code{ar} est requise si le fichier d'archive n'existe pas encore.

Pour spécifier plusieurs membres d'une même archive, vous pouvez écrire
tous les noms des membres entre parenthèses. Par exemple:

@example
foolib(hack.o kludge.o)
@end example

@noindent
is equivalent to:

@example
foolib(hack.o) foolib(kludge.o)
@end example

@cindex caractère générique (wildcard), dans les membres d'une archive
Vous pouvez aussi utiliser le style utilisant les caractères génériques
pour référencer un membre d'archive. @xref{Les caractères génériques,
,Utiliser les caractères génériques dans les noms de fichiers}. Par exemple,
@w{@samp{foolib(*.o)}} développe tous les membres existants de l'archive
@file{foolib} dont les noms se terminent par @samp{.o}; se peut être
@samp{@w{foolib(hack.o)} @w{foolib(kludge.o)}}.


@node Archive Update, Archive Pitfalls, Les membres d'une archive, Les fichiers archivés
@section Règle implicite pour les membres d'une archive

Rappelez-vous qu'une cible qui ressemble à @file{@var{a}(@var{m})} fait
référence au membre @var{m} d'un fichier d'archive @var{a}.

Quand @code{make} recherche une règle implice pour une telle cible, en
fonctionalité particulière, il regarde les règles implicites qui
correspondent à @file{(@var{m})}, comme celles qui correspondent à la
cible réelle @file{@var{a}(@var{m})}.

Ceci fait qu'une règle spéciale dont la cible est @file{(%)}
correspondra. Cette règle met à jour la cible @file{@var{a}(@var{m})} en
copiant le fichier @var{m} dans l'archive. Par exemple, cela mettra à
jour le membre d'archive @file{foo.a(bar.o)} en copiant le
@emph{fichier} @file{bar.o} dans l'archive @file{foo.a} en tant que
@emph{membre} nommé @file{bar.o}.

Quand une règle est enchaînée avec d'autres, le résultat est très
puissant. C'est pourquoi @samp{make "foo.a(bar.o)"} (les guillemets sont
nécessaires pour protéger les @samp{(} et @samp{)} contre une
interprétation spéciale par le shell) en présence du fichier
@file{bar.c} est suffisant pour que la règle suivante soit exécutée,
même sans un makefile:

@example
cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
@end example

@noindent
Ici @code{make} a envisagé le fichier @file{bar.o} comme un fichier
intermédiaire.  @xref{Enchaînement de règles implicites, ,Enchaînement
de règles implicites}.

Les règles implicites comme celle-ci sont écrite en utilisant la
variable automatique @samp{$%}.  @xref{Les variables automatiques}.

Un nom d'un membre d'archive ne peur pas contenir un nom de répertoire,
mais il peut être utile dans un makefile, de prétendre qu'il en a un. Si
vous écrivez une cible de membre d'archive @file{foo.a(dir/file.o)},
@code{make} fera la mises à jour automatique avec cette instruction@tie{}:

@example
ar r foo.a dir/file.o
@end example

@noindent
ce qui aura pour effet de copier le fichier @file{dir/file.o} dans un
membre d'archive nommé @file{file.o}.  En connection avec ce genre
d'usage, les variables automatiques @code{%D} and @code{%F} peuvent être
utiles.


@node Archive Symbols, , Archive Update, Archive Update
@subsection Updating Archive Symbol Directories (NT)
@cindex @code{__.SYMDEF}
@cindex updating archive symbol directories
@cindex archive symbol directory updating
@cindex symbol directories, updating archive
@cindex directories, updating archive symbol

An archive file that is used as a library usually contains a special member
named @file{__.SYMDEF} that contains a directory of the external symbol
names defined by all the other members.  After you update any other members,
you need to update @file{__.SYMDEF} so that it will summarize the other
members properly.  This is done by running the @code{ranlib} program:

@example
ranlib @var{archivefile}
@end example

Normally you would put this command in the rule for the archive file, and
make all the members of the archive file prerequisites of that rule.  For
example,

@example
libfoo.a: libfoo.a(x.o) libfoo.a(y.o) @dots{}
        ranlib libfoo.a
@end example

@noindent
The effect of this is to update archive members @file{x.o}, @file{y.o},
etc., and then update the symbol directory member @file{__.SYMDEF} by
running @code{ranlib}.  The rules for updating the members are not shown
here; most likely you can omit them and use the implicit rule which copies
files into the archive, as described in the preceding section.

This is not necessary when using the GNU @code{ar} program, which updates
the @file{__.SYMDEF} member automatically.


@node Archive Pitfalls, Archive Règle des suffixes, Archive Update, Les fichiers archivés
@section Les dangers d'utiliser des archives (NT)
@cindex archive, and parallel execution
@cindex parallel execution, and archive update
@cindex archive, and @code{-j}
@cindex @code{-j}, and archive update

It is important to be careful when using parallel execution (the @code{-j}
switch; @pxref{Parallèle, ,Parallèle Exécution}) and archives.  If multiple
@code{ar} commands run at the same time on the same archive file, they will
not know about each other and can corrupt the file.

Possibly a future version of @code{make} will provide a mechanism to
circumvent this problem by serializing all recipes that operate on the same
archive file.  But for the time being, you must either write your makefiles
to avoid this problem in some other way, or not use @code{-j}.

@node Archive Règle des suffixes, , Archive Pitfalls, Les fichiers archivés
@section Règle des suffixes pour les fichiers d'archive (NT)
@cindex règle des suffixes, pour les archives
@cindex archive, règle des suffixes
@cindex bibliothèque archivée, règle des suffixes
@cindex @code{.a} (archives)

You can write a special kind of suffix rule for dealing with archive files.
@xref{Règle des suffixes}, for a full explanation of suffix rules.  Archive suffix
rules are obsolete in GNU @code{make}, because pattern rules for archives
are a more general mechanism (@pxref{Archive Update}).  But they are
retained for compatibility with other @code{make}s.

To write a suffix rule for archives, you simply write a suffix rule using
the target suffix @samp{.a} (the usual suffix for archive files).  For
example, here is the old-fashioned suffix rule to update a library archive
from C source files:

@example
@group
.c.a:
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
        $(AR) r $@@ $*.o
        $(RM) $*.o
@end group
@end example

@noindent
This works just as if you had written the pattern rule:

@example
@group
(%.o): %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
        $(AR) r $@@ $*.o
        $(RM) $*.o
@end group
@end example

In fact, this is just what @code{make} does when it sees a suffix rule with
@samp{.a} as the target suffix.  Any double-suffix rule
@w{@samp{.@var{x}.a}} is converted to a pattern rule with the target pattern
@samp{(%.o)} and a prerequisite pattern of @samp{%.@var{x}}.

Since you might want to use @samp{.a} as the suffix for some other kind of
file, @code{make} also converts archive suffix rules to pattern rules in the
normal way (@pxref{Règle des suffixes}).  Thus a double-suffix rule
@w{@samp{.@var{x}.a}} produces two pattern rules: @samp{@w{(%.o):}
@w{%.@var{x}}} and @samp{@w{%.a}: @w{%.@var{x}}}.@refill

@node Compléter make par des extensions, Intégrer make, Les fichiers archivés, Top
@chapter Étendre GNU @code{make} par des extensions
@cindex les extensions de make

GNU @code{make} propose beaucoup de fonctionnalités avancées, incluant
beaucoup de fonction puissantes. Cependant, il ne contient pas un
langage de programmation complet et a certaines limitations. Parfois ces
limitations peuvent être contournées avec l'utilisation de fonction
@code{shell} pour invoquer des programmes séparrés, même si cela peut
être peu efficace.

Dans les cas où les fonctionnalités pré-intégrées de GNU @code{make}
seraient insuffisantes pour vos besoins, il y a deux options pour
faire des extensions de @code{make}. Pour les systèmes dans lesquels
c'est fourni, vous pouvez utiliser GNU Guile comme un langage de script
intégré. (@pxref{Intégration de Guile,,GNU Intégration de Guile}). Sur
les systèmes, qui supportent le chargement dynamique d'objets, vous
pouvez écrire vos propres extensions dans n'importe quel langage (qui
peut être compilé en un tel objet) et le charger pour obtenir ces
fonctionalités additionnelles (@pxref{load Directive, ,La directive
@code{load}}).

@node Intégration de Guile, Charger des objets dynamiquement, Compléter make par des extensions, Compléter make par des extensions
@section GNU Intégration de Guile (NT)
@cindex Guile
@cindex extensions, Guile

GNU @code{make} may be built with support for GNU Guile as an embedded
extension language.  Guile implements the Scheme language.  A review of GNU
Guile and the Scheme language and its features is beyond the scope of this
manual: see the documentation for GNU Guile and Scheme.

You can determine if @code{make} contains support for Guile by examining the
@code{.FEATURES} variable; it will contain the word @var{guile} if Guile
support is available.

The Guile integration provides one new @code{make} function: @code{guile}.
The @code{guile} function takes one argument which is first expanded by
@code{make} in the normal fashion, then passed to the GNU Guile evaluator.
The result of the evaluator is converted into a string and used as the
expansion of the @code{guile} function in the makefile.

In addition, GNU @code{make} exposes Guile procedures for use in Guile
scripts.

@node Types Guile, Interface Guile, Intégration de Guile, Intégration de Guile
@subsection Conversion of Guile Types (NT)
@cindex convert guile types
@cindex guile, conversion of types
@cindex types, conversion of

There is only one ``data type'' in @code{make}: a string.  GNU Guile, on the
other hand, provides a rich variety of different data types.  An important
aspect of the interface between @code{make} and GNU Guile is the conversion
of Guile data types into @code{make} strings.

This conversion is relevant in two places: when a makefile invokes the
@code{guile} function to evaluate a Guile expression, the result of that
evaluation must be converted into a make string so it can be further
evaluated by @code{make}.  And secondly, when a Guile script invokes one of
the procedures exported by @code{make} the argument provided to the
procedure must be converted into a string.

The conversion of Guile types into @code{make} strings is as below:

@table @code
@item #f
False is converted into the empty string: in @code{make} conditionals the
empty string is considered false.

@item #t
True is converted to the string @samp{#t}: in @code{make} conditionals any
non-empty string is considered true.

@item symbol
@item number
A symbol or number is converted into the string representation of that
symbol or number.

@item character
A printable character is converted to the same character.

@item string
A string containing only printable characters is converted to the same
string.

@item list
A list is converted recursively according to the above rules.  This implies
that any structured list will be flattened (that is, a result of @samp{'(a b
(c d) e)} will be converted to the @code{make} string @samp{a b c d e}).

@item other
Any other Guile type results in an error.  In future versions of
@code{make}, other Guile types may be converted.

@end table

The translation of @samp{#f} (to the empty string) and @samp{#t} (to the
non-empty string @samp{#t}) is designed to allow you to use Guile boolean
results directly as @code{make} boolean conditions.  For example:

@example
$(if $(guile (access? "myfile" R_OK)),$(info myfile exists))
@end example

As a consequence of these conversion rules you must consider the result of
your Guile script, as that result will be converted into a string and parsed
by @code{make}.  If there is no natural result for the script (that is, the
script exists solely for its side-effects), you should add @samp{#f} as the
final expression in order to avoid syntax errors in your makefile.

@node Interface Guile, Exemple Guile, Types Guile, Intégration de Guile
@subsection Interface entre Guile et @code{make} (NT)
@cindex interface make avec guile
@cindex procedures make dans guile

In addition to the @code{guile} function available in makefiles, @code{make}
exposes some procedures for use in your Guile scripts.  At startup
@code{make} creates a new Guile module, @code{gnu make}, and exports these
procedures as public interfaces from that module:

@table @code
@item gmk-expand
@findex gmk-expand
This procedure takes a single argument which is converted into a string.
The string is expanded by @code{make} using normal @code{make} expansion
rules.  The result of the expansion is converted into a Guile string and
provided as the result of the procedure.

@item gmk-eval
@findex gmk-eval
This procedure takes a single argument which is converted into a string.
The string is evaluated by @code{make} as if it were a makefile.  This is
the same capability available via the @code{eval} function (@pxref{Fonction
Eval}).  The result of the @code{gmk-eval} procedure is always the empty
string.

Note that @code{gmk-eval} is not quite the same as using @code{gmk-expand}
with the @code{eval} function: in the latter case the evaluated string will
be expanded @emph{twice}; first by @code{gmk-expand}, then again by the
@code{eval} function.

@end table

@node Exemple Guile, , Interface Guile, Intégration de Guile
@subsection Example Using Guile in @code{make} (NT)
@cindex Guile example
@cindex example using Guile

Here is a very simple example using GNU Guile to manage writing to a file.
These Guile procedures simply open a file, allow writing to the file (one
string per line), and close the file.  Note that because we cannot store
complex values such as Guile ports in @code{make} variables, we'll keep the
port as a global variable in the Guile interpreter.

You can create Guile functions easily using @code{define}/@code{endef} to
create a Guile script, then use the @code{guile} function to internalize it:

@example
@group
define GUILEIO
;; A simple Guile IO library for GNU make

(define MKPORT #f)

(define (mkopen name mode)
  (set! MKPORT (open-file name mode))
  #f)

(define (mkwrite s)
  (display s MKPORT)
  (newline MKPORT)
  #f)

(define (mkclose)
  (close-port MKPORT)
  #f)

#f
endef

# Internalize the Guile IO functions
$(guile $(GUILEIO))
@end group
@end example

If you have a significant amount of Guile support code, you might consider
keeping it in a different file (e.g., @file{guileio.scm}) and then loading
it in your makefile using the @code{guile} function:

@example
$(guile (load "guileio.scm"))
@end example

An advantage to this method is that when editing @file{guileio.scm}, your
editor will understand that this file contains Scheme syntax rather than
makefile syntax.

Now you can use these Guile functions to create files.  Suppose you need to
operate on a very large list, which cannot fit on the command line, but the
utility you're using accepts the list as input as well:

@example
@group
prog: $(PREREQS)
        @@$(guile (mkopen "tmp.out" "w")) \
         $(foreach X,$^,$(guile (mkwrite "$(X)"))) \
         $(guile (mkclose))
        $(LINK) < tmp.out
@end group
@end example

A more comprehensive suite of file manipulation procedures is possible of
course.  You could, for example, maintain multiple output files at the same
time by choosing a symbol for each one and using it as the key to a hash
table, where the value is a port, then returning the symbol to be stored in
a @code{make} variable.

@node Charger des objets dynamiquement, , Intégration de Guile, Compléter make par des extensions
@section Charger des objets dynamiquement (NT).
@cindex loaded objects
@cindex objects, loaded
@cindex extensions, loading

@cartouche
@quotation Warning
The @code{load} directive and extension capability is considered a
``technology preview'' in this release of GNU make.  We encourage you to
experiment with this feature and we appreciate any feedback on it.  However
we cannot guarantee to maintain backward-compatibility in the next release.
Consider using GNU Guile instead for extending GNU make (@pxref{La fonction
Guile, ,The @code{guile} Function}).
@end quotation
@end cartouche

Many operating systems provide a facility for dynamically loading compiled
objects.  If your system provides this facility, GNU @code{make} can make
use of it to load dynamic objects at runtime, providing new capabilities
which may then be invoked by your makefile.

The @code{load} directive is used to load a dynamic object.  Once the object
is loaded, a ``setup'' function will be invoked to allow the object to
initialize itself and register new facilities with GNU @code{make}.  A
dynamic object might include new @code{make} functions, for example, and the
``setup'' function would register them with GNU @code{make}'s function
handling system.

@node load Directive, Remaking Loaded Objects, Charger des objets dynamiquement, Charger des objets dynamiquement
@subsection La directive @code{load} (NT)
@cindex la directive load
@cindex extensions, directive load

Objects are loaded into GNU @code{make} by placing the @code{load} directive
into your makefile.  The syntax of the @code{load} directive is as follows:

@findex load
@example
load @var{object-file} @dots{}
@end example

or:

@example
load @var{object-file}(@var{symbol-name}) @dots{}
@end example

The file @var{object-file} is dynamically loaded by GNU @code{make}.  If
@var{object-file} does not include a directory path then it is first looked
for in the current directory.  If it is not found there, or a directory path
is included, then system-specific paths will be searched.  If the load fails
for any reason, @code{make} will print a message and exit.

If the load succeeds @code{make} will invoke an initializing function.

If @var{symbol-name} is provided, it will be used as the name of the
initializing function.

If no @var{symbol-name} is provided, the initializing function name is
created by taking the base file name of @var{object-file}, up to the first
character which is not a valid symbol name character (alphanumerics and
underscores are valid symbol name characters).  To this prefix will be
appended the suffix @code{_gmk_setup}.

More than one object file may be loaded with a single @code{load} directive,
and both forms of @code{load} arguments may be used in the same directive.

The initializing function will be provided the file name and line number of
the invocation of the @code{load} operation.  It should return a value of
type @code{int}, which must be @code{0} on failure and non-@code{0} on
success.  If the return value is @code{-1}, then GNU make will @emph{not}
attempt to rebuild the object file (@pxref{Remaking Loaded Objects, ,How
Loaded Objects Are Remade}).

For example:

@example
load ../mk_funcs.so
@end example

will load the dynamic object @file{../mk_funcs.so}.  After the object is
loaded, @code{make} will invoke the function (assumed to be defined by the
shared object) @code{mk_funcs_gmk_setup}.

On the other hand:

@example
load ../mk_funcs.so(init_mk_func)
@end example

will load the dynamic object @file{../mk_funcs.so}.  After the object is
loaded, @code{make} will invoke the function @code{init_mk_func}.

Regardless of how many times an object file appears in a @code{load}
directive, it will only be loaded (and its setup function will only be
invoked) once.

@vindex .LOADED
After an object has been successfully loaded, its file name is appended to
the @code{.LOADED} variable.

@findex -load
If you would prefer that failure to load a dynamic object not be reported as
an error, you can use the @code{-load} directive instead of @code{load}.
GNU @code{make} will not fail and no message will be generated if an object
fails to load.  The failed object is not added to the @code{.LOADED}
variable, which can then be consulted to determine if the load was
successful.

@node Remaking Loaded Objects, Loaded Object API, load Directive, Charger des objets dynamiquement
@subsection How Loaded Objects Are Remade (NT)
@cindex updating loaded objects
@cindex remaking loaded objects
@cindex loaded objects, remaking of

Loaded objects undergo the same re-make procedure as makefiles
(@pxref{Reconstruire les Makefiles, ,How Makefiles Are Remade}).  If any loaded
object is recreated, then @code{make} will start from scratch and re-read
all the makefiles, and reload the object files again.  It is not necessary
for the loaded object to do anything special to support this.@refill

It's up to the makefile author to provide the rules needed for rebuilding
the loaded object.

@node Loaded Object API, Loaded Object Example, Remaking Loaded Objects, Charger des objets dynamiquement
@subsection Loaded Object Interface (NT)
@cindex loaded object API
@cindex interface for loaded objects

@cartouche
@quotation Warning
For this feature to be useful your extensions will need to invoke various
functions internal to GNU @code{make}.  The programming interfaces provided
in this release should not be considered stable: functions may be added,
removed, or change calling signatures or implementations in future versions
of GNU @code{make}.
@end quotation
@end cartouche

To be useful, loaded objects must be able to interact with GNU @code{make}.
This interaction includes both interfaces the loaded object provides to
makefiles and also interfaces @code{make} provides to the loaded object to
manipulate @code{make}'s operation.

The interface between loaded objects and @code{make} is defined by the
@file{gnumake.h} C header file.  All loaded objects written in C should
include this header file.  Any loaded object not written in C will need to
implement the interface defined in this header file.

Typically, a loaded object will register one or more new GNU @code{make}
functions using the @code{gmk_add_function} routine from within its setup
function.  The implementations of these @code{make} functions may make use
of the @code{gmk_expand} and @code{gmk_eval} routines to perform their
tasks, then optionally return a string as the result of the function
expansion.

@subsubheading Loaded Object Licensing (NT)
@cindex loaded object licensing
@cindex plugin_is_GPL_compatible

Every dynamic extension should define the global symbol
@code{plugin_is_GPL_compatible} to assert that it has been licensed under a
GPL-compatible license.  If this symbol does not exist, @code{make} emits a
fatal error and exits when it tries to load your extension.

The declared type of the symbol should be @code{int}. It does not need to be
in any allocated section, though.  The code merely asserts that the symbol
exists in the global scope. Something like this is enough:

@example
int plugin_is_GPL_compatible;
@end example

@subsubheading Data Structures (NT)

@table @code
@item gmk_floc
This structure represents a filename/location pair.  It is provided when
defining items, so GNU @code{make} can inform the user later where the
definition occurred if necessary.
@end table

@subsubheading Registering Fonctions (NT)
@findex gmk_add_function

There is currently one way for makefiles to invoke operations provided by
the loaded object: through the @code{make} function call interface.  A
loaded object can register one or more new functions which may then be
invoked from within the makefile in the same way as any other function.

Use @code{gmk_add_function} to create a new @code{make} function.  Its
arguments are as follows:

@table @code
@item name
The function name.  This is what the makefile should use to invoke the
function.  The name must be between 1 and 255 characters long and it may
only contain alphanumeric, period (@samp{.}), dash (@samp{-}), and
underscore (@samp{_}) characters.  It may not begin with a period.

@item func_ptr
A pointer to a function that @code{make} will invoke when it expands the
function in a makefile.  This function must be defined by the loaded object.

@item min_args
The minimum number of arguments the function will accept.  Must be between 0
and 255.  GNU @code{make} will check this and fail before invoking
@code{func_ptr} if the function was invoked with too few arguments.

@item max_args
The maximum number of arguments the function will accept.  Must be between 0
and 255.  GNU @code{make} will check this and fail before invoking
@code{func_ptr} if the function was invoked with too few arguments.  If the
value is 0, then any number of arguments is accepted.  If the value is
greater than 0, then it must be greater than or equal to @code{min_args}.

@item flags
Flags that specify how this function will operate; the desired flags should
be OR'd together.  If the @code{GMK_FUNC_NOEXPAND} flag is given then the
function arguments will not be expanded before the function is called;
otherwise they will be expanded first.
@end table

@subsubheading Registered Function Interface (NT)
@findex gmk_func_ptr

A function registered with @code{make} must match the @code{gmk_func_ptr}
type.  It will be invoked with three parameters: @code{name} (the name of
the function), @code{argc} (the number of arguments to the function), and
@code{argv} (an array of pointers to arguments to the function).  The last
pointer (that is, @code{argv[argc]}) will be null (@code{0}).

The return value of the function is the result of expanding the function.
If the function expands to nothing the return value may be null.  Otherwise,
it must be a pointer to a string created with @code{gmk_alloc}.  Once the
function returns, @code{make} owns this string and will free it when
appropriate; it cannot be accessed by the loaded object.

@subsubheading GNU @code{make} Facilities (NT)

There are some facilities exported by GNU @code{make} for use by loaded
objects.  Typically these would be run from within the setup function and/or
the functions registered via @code{gmk_add_function}, to retrieve or modify
the data @code{make} works with.

@table @code
@item gmk_expand
@findex gmk_expand
This function takes a string and expands it using @code{make} expansion
rules.  The result of the expansion is returned in a nil-terminated string
buffer.  The caller is responsible for calling @code{gmk_free} with a
pointer to the returned buffer when done.

@item gmk_eval
@findex gmk_eval
This function takes a buffer and evaluates it as a segment of makefile
syntax.  This function can be used to define new variables, new rules, etc.
It is equivalent to using the @code{eval} @code{make} function.
@end table

Note that there is a difference between @code{gmk_eval} and calling
@code{gmk_expand} with a string using the @code{eval} function: in the
latter case the string will be expanded @emph{twice}; once by
@code{gmk_expand} and then again by the @code{eval} function.  Using
@code{gmk_eval} the buffer is only expanded once, at most (as it's read by
the @code{make} parser).

@subsubheading Memory Management (NT)

Some systems allow for different memory management schemes.  Thus you should
never pass memory that you've allocated directly to any @code{make}
function, nor should you attempt to directly free any memory returned to you
by any @code{make} function.  Instead, use the @code{gmk_alloc} and
@code{gmk_free} functions.

In particular, the string returned to @code{make} by a function registered
using @code{gmk_add_function} @emph{must} be allocated using
@code{gmk_alloc}, and the string returned from the @code{make}
@code{gmk_expand} function @emph{must} be freed (when no longer needed)
using @code{gmk_free}.

@table @code
@item gmk_alloc
@findex gmk_alloc
Return a pointer to a newly-allocated buffer.  This function will always
return a valid pointer; if not enough memory is available @code{make} will
exit.

@item gmk_free
@findex gmk_free
Free a buffer returned to you by @code{make}.  Once the @code{gmk_free}
function returns the string will no longer be valid.
@end table

@node Loaded Object Example, , Loaded Object API, Charger des objets dynamiquement
@subsection Example Loaded Object (NT)
@cindex loaded object example
@cindex example of loaded objects

Let's suppose we wanted to write a new GNU @code{make} function that would
create a temporary file and return its name.  We would like our function to
take a prefix as an argument.  First we can write the function in a file
@file{mk_temp.c}:

@example
@group
#include <stdlib.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <gnumake.h>

int plugin_is_GPL_compatible;

char *
gen_tmpfile(const char *nm, int argc, char **argv)
@{
  int fd;

  /* Compute the size of the filename and allocate space for it.  */
  int len = strlen (argv[0]) + 6 + 1;
  char *buf = gmk_alloc (len);

  strcpy (buf, argv[0]);
  strcat (buf, "XXXXXX");

  fd = mkstemp(buf);
  if (fd >= 0)
    @{
      /* Don't leak the file descriptor.  */
      close (fd);
      return buf;
    @}

  /* Failure.  */
  fprintf (stderr, "mkstemp(%s) failed: %s\n", buf, strerror (errno));
  gmk_free (buf);
  return NULL;
@}

int
mk_temp_gmk_setup ()
@{
  /* Register the function with make name "mk-temp".  */
  gmk_add_function ("mk-temp", gen_tmpfile, 1, 1, 1);
  return 1;
@}
@end group
@end example

Next, we will write a makefile that can build this shared object, load it,
and use it:

@example
@group
all:
        @@echo Temporary file: $(mk-temp tmpfile.)

load mk_temp.so

mk_temp.so: mk_temp.c
        $(CC) -shared -fPIC -o $@ $<
@end group
@end example

On MS-Windows, due to peculiarities of how shared objects are produced, the
compiler needs to scan the @dfn{import library} produced when building
@code{make}, typically called @file{libgnumake-@var{version}.dll.a}, where
@var{version} is the version of the load object API.  So the recipe to
produce a shared object will look on Windows like this (assuming the API
version is 1):

@example
@group
mk_temp.dll: mk_temp.c
        $(CC) -shared -o $@ $< -lgnumake-1
@end group
@end example

Now when you run @code{make} you'll see something like:

@example
$ make
cc -shared -fPIC -o mk_temp.so mk_temp.c
Temporary filename: tmpfile.A7JEwd
@end example

@node Intégrer make, Fonctionalités, Compléter make par des extensions, Top
@chapter Intégrer GNU @code{make}
@cindex intégration de make

GNU @code{make} est souvent un composant d'un système d'outils plus
large incluant les environnements de développement intégrés, les chaînes
d'outils de compilation et autres. Le rôle de @code{make} et de lancer
les commandes et de détermines si elles ont réussies ou non@tie{}: aucune
intégration spéciale n'est nécessaire pour accomplir cela. Cependant, il
est parfois pratique de lier @code{make} plus fermement aux autres
parties du système, à la fois pour le haut niveau (les outils qui
invoquent @code{make}) que pour la bs niveau (les outils qui sont
invoqués par @code{make}).

@node Job Slots, Terminal Output, Intégrer make, Intégrer make
@section Sharing Job Slots with GNU @code{make} (NT)
@cindex job slots, sharing
@cindex tools, sharing job slots

GNU @code{make} has the ability to run multiple recipes in parallel
(@pxref{Parallèle, ,Parallèle Exécution}) and to cap the total number of
parallel jobs even across recursive invocations of @code{make}
(@pxref{Les options de récursions, ,Communicating Options to a Sub-@code{make}}).
Tools that @code{make} invokes which are also able to run multiple
operations in parallel, either using multiple threads or multiple processes,
can be enhanced to participate in GNU @code{make}'s job management facility
to ensure that the total number of active threads/processes running on the
system does not exceed the maximum number of slots provided to GNU
@code{make}. @refill

@cindex jobserver
GNU @code{make} uses a method called the ``jobserver'' to control the number
of active jobs across recursive invocations.  The actual implementation of
the jobserver varies across different operating systems, but some
fundamental aspects are always true.

First, only command lines that @code{make} understands to be recursive
invocations of @code{make} (@pxref{La variable MAKE, ,How the @code{MAKE}
Variable Works}) will have access to the jobserver.  When writing makefiles
you must be sure to mark the command as recursive (most commonly by
prefixing the command line with the @code{+} indicator (@pxref{Récursion,
,Recursive Use of @code{make}}).

Second, @code{make} will provide information necessary for accessing the
jobserver through the environment to its children, in the @code{MAKEFLAGS}
environment variable.  Tools which want to participate in the jobserver
protocol will need to parse this environment variable, as described in
subsequent sections.

Third, every command @code{make} starts has one implicit job slot reserved
for it before it starts.  Any tool which wants to participate in the
jobserver protocol should assume it can always run one job without having to
contact the jobserver at all.

Finally, it's critical that tools that participate in the jobserver protocol
return the exact number of slots they obtained from the jobserver back to
the jobserver before they exit, even under error conditions.  Remember that
the implicit job slot should @strong{not} be returned to the jobserver!
Returning too few slots means that those slots will be lost for the rest of
the build process; returning too many slots means that extra slots will be
available.  The top-level @code{make} command will print an error message at
the end of the build if it detects an incorrect number of slots available in
the jobserver.

As an example, suppose you are implementing a linker which provides for
multithreaded operation.  You would like to enhance the linker so that if it
is invoked by GNU @code{make} it can participate in the jobserver protocol
to control how many threads are used during link.  First you will need to
modify the linker to determine if the @code{MAKEFLAGS} environment variable
is set.  Next you will need to parse the value of that variable to determine
if the jobserver is available, and how to access it.  If it is available
then you can access it to obtain job slots controlling how much parallelism
your tool can use.  Once done your tool must return those job slots back to
the jobserver.

@node POSIX Jobserver, Windows Jobserver, Job Slots, Job Slots
@subsection POSIX Jobserver Interaction (NT)
@cindex jobserver on POSIX

On POSIX systems the jobserver is implemented as a simple UNIX pipe.  The
pipe will be pre-loaded with one single-character token for each available
job.  To obtain an extra slot you must read a single character from the
jobserver pipe; to release a slot you must write a single character back
into the jobserver pipe.  Note that the read side of the jobserver pipe is
set to ``blocking'' mode.

To access the pipe you must parse the @code{MAKEFLAGS} variable and look for
the argument string @code{--jobserver-auth=R,W} where @samp{R} and @samp{W}
are non-negative integers representing file descriptors: @samp{R} is the
read file descriptor and @samp{W} is the write file descriptor.

It's important that when you release the job slot, you write back the same
character you read from the pipe for that slot.  Don't assume that all
tokens are the same character; different characters may have different
meanings to GNU @code{make}.  The order is not important, since @code{make}
has no idea in what order jobs will complete anyway.

There are various error conditions you must consider to ensure your
implementation is robust:

@itemize @bullet
@item
Usually you will have a command-line argument controlling the parallel
operation of your tool.  Consider whether your tool should detect situations
where both the jobserver and the command-line argument are specified, and
how it should react.

@item
If your tool determines that the @code{--jobserver-auth} option is available
in @code{MAKEFLAGS} but that the file descriptors specified are closed, this
means that the calling @code{make} process did not think that your tool was
a recursive @code{make} invocation (e.g., the command line was not prefixed
with a @code{+} character).  You should notify your users of this situation.

@item
Your tool should also examine the first word of the @code{MAKEFLAGS}
variable and look for the character @code{n}.  If this character is present
then @code{make} was invoked with the @samp{-n} option and your tool should
stop without performing any operations.

@item
Your tool should be sure to write back the tokens it read, even under error
conditions.  This includes not only errors in your tool but also outside
influences such as interrupts (@code{SIGINT}), etc.  You may want to install
signal handlers to manage this write-back.
@end itemize

@node Windows Jobserver, , POSIX Jobserver, Job Slots
@subsection Windows Jobserver Interaction (NT)
@cindex jobserver on Windows

On Windows systems the jobserver is implemented as a named semaphore.  The
semaphore will be set with an initial count equal to the number of available
slots; to obtain a slot you must wait on the semaphore (with or without a
timeout).  To release a slot, release the semaphore.

To access the semaphore you must parse the @code{MAKEFLAGS} variable and
look for the argument string @code{--jobserver-auth=NAME} where @samp{NAME}
is the name of the named semaphore.  Use this name with @code{OpenSemaphore}
to create a handle to the semaphore.

There are various error conditions you must consider to ensure your
implementation is robust:

@itemize @bullet
@item
Usually you will have a command-line argument controlling the parallel
operation of your tool.  Consider whether your tool should detect situations
where both the jobserver and the command-line argument are specified, and
how it should react.

@item
Your tool should be sure to release the semaphore for the tokens it read,
even under error conditions.  This includes not only errors in your tool but
also outside influences such as interrupts (@code{SIGINT}), etc.  You may
want to install signal handlers to manage this write-back.
@end itemize

@node Terminal Output, , Job Slots, Intégrer make
@section Synchronized Terminal Output (NT)
@cindex parallel output to terminal
@cindex terminal, output to

Normally GNU @code{make} will invoke all commands with access to the same
standard and error outputs that @code{make} itself was started with.  A
number of tools will detect whether the output is a terminal or
not-a-terminal, and use this information to change the output style.  For
example if the output goes to a terminal the tool may add control characters
that set color, or even change the location of the cursor.  If the output is
not going to a terminal then these special control characters are not
emitted so that they don't corrupt log files, etc.

The @code{--output-sync} (@pxref{Sortie parallèle, ,Output During Parallèle
Output}) option will defeat the terminal detection.  When output
synchronization is enabled GNU @code{make} arranges for all command output
to be written to a file, so that its output can be written as a block
without interference from other commands.  This means that all tools invoked
by @code{make} will believe that their output is not going to be displayed
on a terminal, even when it will be (because @code{make} will display it
there after the command is completed).

In order to facilitate tools which would like to determine whether or not
their output will be displayed on a terminal, GNU @code{make} will set the
@code{MAKE_TERMOUT} and @code{MAKE_TERMERR} environment variables before
invoking any commands.  Tools which would like to determine whether standard
or error output (respectively) will be displayed on a terminal can check
these environment variables to determine if they exist and contain a
non-empty value.  If so the tool can assume that the output will
(eventually) be displayed on a terminal.  If the variables are not set or
have an empty value, then the tool should fall back to its normal methods of
detecting whether output is going to a terminal or not.

The content of the variables can be parsed to determine the type of terminal
which will be used to display the output.

Similarly, environments which invoke @code{make} and would like to capture
the output and eventually display it on a terminal (or some display which
can interpret terminal control characters) can set these variables before
invoking @code{make}.  GNU @code{make} will not modify these environment
variables if they already exist when it starts.

@node Fonctionalités, Manquants, Intégrer make, Top
@chapter Fonctionalités of GNU @code{make} (NT)
@cindex fonctionalités of GNU @code{make}
@cindex portability
@cindex compatibility

Here is a summary of the features of GNU @code{make}, for comparison with
and credit to other versions of @code{make}.  We consider the features of
@code{make} in 4.2 BSD systems as a baseline.  If you are concerned with
writing portable makefiles, you should not use the features of @code{make}
listed here, nor the ones in @ref{Manquants}.

Many features come from the version of @code{make} in System V.

@itemize @bullet
@item
The @code{VPATH} variable and its special meaning.  @xref{Rechercher dans les répertoires,
, Searching Directories for Prerequisites}.  This feature exists in System V
@code{make}, but is undocumented.  It is documented in 4.3 BSD @code{make}
(which says it mimics System V's @code{VPATH} feature).@refill

@item
Included makefiles.  @xref{Inclure d'autres makefiles, ,Including Other Makefiles}.  Allowing
multiple files to be included with a single directive is a GNU extension.

@item
Variables are read from and communicated via the environment.
@xref{Variables d'environnement, ,Variables venant de l'environnement}.

@item
Options passed through the variable @code{MAKEFLAGS} to recursive
invocations of @code{make}.  @xref{Les options de récursions, ,Communicating Options
to a Sub-@code{make}}.

@item
The automatic variable @code{$%} is set to the member name in an archive
reference.  @xref{Les variables automatiques}.

@item
The automatic variables @code{$@@}, @code{$*}, @code{$<}, @code{$%}, and
@code{$?} have corresponding forms like @code{$(@@F)} and @code{$(@@D)}.  We
have generalized this to @code{$^} as an obvious extension.
@xref{Les variables automatiques}.@refill

@item
Substitution variable references.  @xref{Référencer une variable, ,Basics of Variable
References}.

@item
The command line options @samp{-b} and @samp{-m}, accepted and ignored.  In
System V @code{make}, these options actually do something.

@item
Exécution of recursive commands to run @code{make} via the variable
@code{MAKE} even if @samp{-n}, @samp{-q} or @samp{-t} is specified.
@xref{Récursion, ,Recursive Use of @code{make}}.

@item
Support for suffix @samp{.a} in suffix rules.  @xref{Archive Règle des suffixes}.
This feature is obsolete in GNU @code{make}, because the general feature of
rule chaining (@pxref{Enchaînement de règles implicites, ,Enchaînement de règles implicites}) allows one
pattern rule for installing members in an archive (@pxref{Archive Update})
to be sufficient.

@item
The arrangement of lines and backslash/newline combinations in recipes is
retained when the recipes are printed, so they appear as they do in the
makefile, except for the stripping of initial whitespace.
@end itemize

The following features were inspired by various other versions of
@code{make}.  In some cases it is unclear exactly which versions inspired
which others.

@itemize @bullet
@item
Pattern rules using @samp{%}.  This has been implemented in several versions
of @code{make}.  We're not sure who invented it first, but it's been spread
around a bit.  @xref{Modèle de règles, ,Defining and Redefining Pattern Rules}.@refill

@item
Rule chaining and implicit intermediate files.  This was implemented by Stu
Feldman in his version of @code{make} for AT&T Eighth Edition Research Unix,
and later by Andrew Hume of AT&T Bell Labs in his @code{mk} program (where
he terms it ``transitive closure'').  We do not really know if we got this
from either of them or thought it up ourselves at the same time.
@xref{Enchaînement de règles implicites, ,Enchaînement de règles implicites}.

@item
The automatic variable @code{$^} containing a list of all prerequisites of
the current target.  We did not invent this, but we have no idea who did.
@xref{Les variables automatiques}.  The automatic variable @code{$+} is a simple
extension of @code{$^}.

@item
The ``what if'' flag (@samp{-W} in GNU @code{make}) was (as far as we know)
invented by Andrew Hume in @code{mk}.  @xref{À la place d'une exécution, ,Instead
of Executing Recipes}.

@item
The concept of doing several things at once (parallelism) exists in many
incarnations of @code{make} and similar programs, though not in the System V
or BSD implementations.  @xref{Exécution, ,Recipe Exécution}.

@item
A number of different build tools that support parallelism also support
collecting output and displaying as a single block.  @xref{Sortie parallèle,
,Output During Parallèle Exécution}.

@item
Modified variable references using pattern substitution come from SunOS 4.
@xref{Référencer une variable, ,Basics of Variable References}.  This functionality was
provided in GNU @code{make} by the @code{patsubst} function before the
alternate syntax was implemented for compatibility with SunOS 4.  It is not
altogether clear who inspired whom, since GNU @code{make} had
@code{patsubst} before SunOS 4 was released.@refill

@item
The special significance of @samp{+} characters preceding recipe lines
(@pxref{À la place d'une exécution, ,Instead of Executing Recipes}) is mandated by
@cite{IEEE Standard 1003.2-1992} (POSIX.2).

@item
The @samp{+=} syntax to append to the value of a variable comes from SunOS 4
@code{make}.  @xref{Rajouter du texte à une variable, , Appending More Text to Variables}.

@item
The syntax @w{@samp{@var{archive}(@var{mem1} @var{mem2}@dots{})}} to list
multiple members in a single archive file comes from SunOS 4 @code{make}.
@xref{Les membres d'une archive}.

@item
The @code{-include} directive to include makefiles with no error for a
nonexistent file comes from SunOS 4 @code{make}.  (But note that SunOS 4
@code{make} does not allow multiple makefiles to be specified in one
@code{-include} directive.)  The same feature appears with the name
@code{sinclude} in SGI @code{make} and perhaps others.

@item
The @code{!=} shell assignment operator exists in many BSD of @code{make}
and is purposefully implemented here to behave identically to those
implementations.

@item
Various build management tools are implemented using scripting languages
such as Perl or Python and thus provide a natural embedded scripting
language, similar to GNU @code{make}'s integration of GNU Guile.
@end itemize

The remaining features are inventions new in GNU @code{make}:

@itemize @bullet
@item
Use the @samp{-v} or @samp{--version} option to print version and copyright
information.

@item
Utilise l'option @samp{-h} ou @samp{--help} pour résumer les options de @code{make}.

@item
Les variables développées de manière unique.  @xref{Deux catégories de variables, ,Les deux versions de variables}.

@item
Pass command line variable assignments automatically through the variable
@code{MAKE} to recursive @code{make} invocations.  @xref{Récursion,
,Recursive Use of @code{make}}.

@item
Use the @samp{-C} or @samp{--directory} command option to change directory.
@xref{Résumé des options, ,Résumé des options}.

@item
Make verbatim variable definitions with @code{define}.  @xref{Variables sur plusieurs lignes,
,Defining Multi-Line Variables}.

@item
Declare phony targets with the special target @code{.PHONY}.

Andrew Hume of AT&T Bell Labs implemented a similar feature with a different
syntax in his @code{mk} program.  This seems to be a case of parallel
discovery.  @xref{Les cibles fictives, ,Les cibles fictives}.

@item
Manipulate text by calling functions.  @xref{Les fonctions, ,Fonctions for
Transforming Text}.

@item
Use the @samp{-o} or @samp{--old-file} option to pretend a file's
modification-time is old.  @xref{Éviter de recompiler, ,Avoiding
Recompilation of Some Files}.

@item
Conditional execution.

This feature has been implemented numerous times in various versions of
@code{make}; it seems a natural extension derived from the features of the C
preprocessor and similar macro languages and is not a revolutionary
concept.  @xref{Les parties conditionnelles, ,Conditional Parts of Makefiles}.

@item
Specify a search path for included makefiles.  @xref{Inclure d'autres makefiles, ,Including
Other Makefiles}.

@item
Specify extra makefiles to read with an environment variable.
@xref{La Variable MAKEFILES, ,The Variable @code{MAKEFILES}}.

@item
Strip leading sequences of @samp{./} from file names, so that
@file{./@var{file}} and @file{@var{file}} are considered to be the same
file.@refill

@item
Use a special search method for library prerequisites written in the form
@samp{-l@var{name}}.  @xref{Recherche dans les bibliothèques, ,Directory Search for Link
Libraries}.

@item
Allow suffixes for suffix rules (@pxref{Règle des suffixes, ,Old-Fashioned Suffix
Rules}) to contain any characters.  In other versions of @code{make}, they
must begin with @samp{.} and not contain any @samp{/} characters.

@item
Keep track of the current level of @code{make} recursion using the variable
@code{MAKELEVEL}.  @xref{Récursion, ,Recursive Use of @code{make}}.

@item
Provide any goals given on the command line in the variable
@code{MAKECMDGOALS}.  @xref{Objectifs, ,Arguments pour spécifier les objectifs}.

@item
Specify static pattern rules.  @xref{Les modèles statiques, ,Static Pattern Rules}.

@item
Provide selective @code{vpath} search.  @xref{Rechercher dans les répertoires, ,Searching
Directories for Prerequisites}.

@item
Provide computed variable references.
@xref{Référencer une variable, ,Basics of Variable References}.

@item
Update makefiles.  @xref{Reconstruire les Makefiles, ,How Makefiles Are Remade}.
System V @code{make} has a very, very limited form of this functionality in
that it will check out SCCS files for makefiles.

@item
Various new built-in implicit rules.  @xref{Catalogue des règles, ,Catalogue
des règles prédéfinies}.

@item
Load dynamic objects which can modify the behavior of @code{make}.
@xref{Charger des objets dynamiquement, ,Charger des objets dynamiquement}.
@end itemize

@node Manquants, Les conventions des Makefiles, Fonctionalités, Top
@chapter Incompatibilités et fonctionalités manquantes (NT)
@cindex incompatibilités
@cindex fonctionalités manquantes
@cindex fonctionalités, manquants

The @code{make} programs in various other systems support a few features
that are not implemented in GNU @code{make}.  The POSIX.2 standard
(@cite{IEEE Standard 1003.2-1992}) which specifies @code{make} does not
require any of these features.@refill

@itemize @bullet
@item
A target of the form @samp{@var{file}((@var{entry}))} stands for a member of
archive file @var{file}.  The member is chosen, not by name, but by being an
object file which defines the linker symbol @var{entry}.@refill

This feature was not put into GNU @code{make} because of the non-modularity
of putting knowledge into @code{make} of the internal format of archive file
symbol tables.  @xref{Archive Symbols, ,Updating Archive Symbol
Directories}.

@item
Suffixes (used in suffix rules) that end with the character @samp{~} have a
special meaning to System V @code{make}; they refer to the SCCS file that
corresponds to the file one would get without the @samp{~}.  For example,
the suffix rule @samp{.c~.o} would make the file @file{@var{n}.o} from the
SCCS file @file{s.@var{n}.c}.  For complete coverage, a whole series of such
suffix rules is required.  @xref{Règle des suffixes, ,Ancienne règle des suffixes}.

In GNU @code{make}, this entire series of cases is handled by two pattern
rules for extraction from SCCS, in combination with the general feature of
rule chaining.  @xref{Enchaînement de règles implicites, ,Enchaînement de règles implicites}.

@item
In System V and 4.3 BSD @code{make}, files found by @code{VPATH} search
(@pxref{Rechercher dans les répertoires, ,Searching Directories for Prerequisites}) have
their names changed inside recipes.  We feel it is much cleaner to always
use automatic variables and thus make this feature unnecessary.@refill

@item
In some Unix @code{make}s, the automatic variable @code{$*} appearing in the
prerequisites of a rule has the amazingly strange ``feature'' of expanding
to the full name of the @emph{target of that rule}.  We cannot imagine what
went on in the minds of Unix @code{make} developers to do this; it is
utterly inconsistent with the normal definition of @code{$*}.
@vindex * @r{(automatic variable), unsupported bizarre usage}

@item
In some Unix @code{make}s, implicit rule search (@pxref{Les règles implicites,
,Utiliser les règles implicites}) is apparently done for @emph{all} targets, not just
those without recipes.  This means you can do:@refill

@example
@group
foo.o:
        cc -c foo.c
@end group
@end example

@noindent
and Unix @code{make} will intuit that @file{foo.o} depends on @file{foo.c}.@refill

We feel that such usage is broken.  The prerequisite properties of
@code{make} are well-defined (for GNU @code{make}, at least), and doing such
a thing simply does not fit the model.@refill

@item
GNU @code{make} does not include any built-in implicit rules for compiling
or preprocessing EFL programs.  If we hear of anyone who is using EFL, we
will gladly add them.

@item
It appears that in SVR4 @code{make}, a suffix rule can be specified with no
recipe, and it is treated as if it had an empty recipe (@pxref{Instructions vides}).  For example:

@example
.c.a:
@end example

@noindent
will override the built-in @file{.c.a} suffix rule.

We feel that it is cleaner for a rule without a recipe to always simply add
to the prerequisite list for the target.  The above example can be easily
rewritten to get the desired behavior in GNU @code{make}:

@example
.c.a: ;
@end example

@item
Some versions of @code{make} invoke the shell with the @samp{-e} flag,
except under @samp{-k} (@pxref{Tester, ,Testing the Compilation of a
Program}).  The @samp{-e} flag tells the shell to exit as soon as any
program it runs returns a nonzero status.  We feel it is cleaner to write
each line of the recipe to stand on its own and not require this special
treatment.
@end itemize

@comment The makefile standards are in a separate file that is also
@comment included by standards.texi.
@include make-stds.fr.texi

@node Référence rapide, Les messages d'erreurs, Les conventions des Makefiles, Top
@appendix Référence Rapide

Cet appendice résume les directives, les fonctions de manipulation de
texte et les variables spéciales que GNU @code{make} comprend.  @xref{Les
cibles spéciales}, @ref{Catalogue des règles, ,Catalogue des règles
prédéfinies}, and @ref{Résumé des options, ,Résumé des options}, pour
les autres résumés.

Voici un résumé des directives reconnues par GNU @code{make} :

@table @code
@item define @var{variable}
@itemx define @var{variable} =
@itemx define @var{variable} :=
@itemx define @var{variable} ::=
@itemx define @var{variable} +=
@itemx define @var{variable} ?=
@itemx endef
Définir des variables sur plusieurs lignes.@* @xref{Variables sur plusieurs lignes}.

@item undefine @var{variable}
Variables indéfinies.@* @xref{Directive indéfinie}.

@item ifdef @var{variable}
@itemx ifndef @var{variable}
@itemx ifeq (@var{a},@var{b})
@itemx ifeq "@var{a}" "@var{b}"
@itemx ifeq '@var{a}' '@var{b}'
@itemx ifneq (@var{a},@var{b})
@itemx ifneq "@var{a}" "@var{b}"
@itemx ifneq '@var{a}' '@var{b}'
@itemx else
@itemx endif
Évalue des parties de makefile sous conditions.@* @xref{Les parties conditionnelles}.

@item include @var{file}
@itemx -include @var{file}
@itemx sinclude @var{file}
Inclue un autre makefile.@* @xref{Inclure d'autres makefiles, ,Including Other Makefiles}.

@item override @var{variable-assignment}
Définie une variable, remplace n'importe quelle autre définition, même
celle venant de la ligne de commande.@* @xref{Directive de forçage, ,The override Directive}.

@item export
Dit à @code{make} d'exporter toutes les variables, par défaut aux processus enfants.@*
@xref{La récursion et les variables, , Communicating Variables to a Sub-@code{make}}.

@item export @var{variable}
@itemx export @var{variable-assignment}
@itemx unexport @var{variable}
Dit à @code{make} d'exporter ou non une variable particulière aux
processus enfants.@* @xref{La récursion et les variables, , Communicating Variables to a
Sub-@code{make}}.

@item private @var{variable-assignment}
Ne permet pas que l'assignement de cette variable soit hérité par les pré-requis.@*
@xref{Supprimer l'héritage}.

@item vpath @var{pattern} @var{path}
Spécifie un chemin de recherche pour la correspondance de fichiers avec
un motif @samp{%}.@*
@xref{Recherche sélective, , The vpath Directive}.

@item vpath @var{pattern}
Enlève tous les chemins de recherche qui ont été spécifiés pour le motif @var{pattern}.

@item vpath
Enlève tous les chemins de recherche qui ont été spécifiés dans
n'importe quelle directive @code{vpath}.
@end table

Voici maintenant un résumé des fonctions pré-incluses (@pxref{Les fonctions}):

@table @code
@item $(subst @var{from},@var{to},@var{text})
Remplace @var{from} avec @var{to} dans le @var{text}.@*
@xref{Fonctions de texte, ,Fonctions for String Substitution and Analysis}.

@item $(patsubst @var{pattern},@var{replacement},@var{text})
Remplace les mots qui correspondent au motif @var{pattern} avec @var{replacement} dans @var{text}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(strip @var{string})
Enlève les caractères d'espaces blancs en trop de la chaîne
@var{string}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(findstring @var{find},@var{text})
Localise @var{find} dans @var{text}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(filter @var{pattern}@dots{},@var{text})
Sélectionne les mots dans @var{text}, qui correspondent l'un des mots du
motif @var{pattern}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(filter-out @var{pattern}@dots{},@var{text})
Sélectionne les mots dans @var{text}, qui @emph{ne correspondent à
aucun} des mots du motifs @var{pattern}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(sort @var{list})
Classe les mots de la @var{list} dans l'ordre alphabétique, en enlevant
les mots dupliqués.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(word @var{n},@var{text})
Extrait le @var{n}ième mot (en commençant à un) du @var{text}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(words @var{text})
Compte le nombre de mots dans @var{text}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(wordlist @var{s},@var{e},@var{text})
Retourne la liste des mots dans @var{text} depuis @var{s} jusqu'à @var{e}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(firstword @var{names}@dots{})
Extrait le premier mot de @var{names}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(lastword @var{names}@dots{})
Extrait le dernier motd de @var{names}.@*
@xref{Fonctions de texte, , Fonctions for String Substitution and Analysis}.

@item $(dir @var{names}@dots{})
Extrait la partie nommant le répertoire de chaque nom de fichier.@*
@xref{Les fonctions de noms de fichier, , Fonctions for File Names}.

@item $(notdir @var{names}@dots{})
Extrait partie qui ne concerne pas le répertoire dans un nom de fichier.@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(suffix @var{names}@dots{})
Extrait le suffixe (le dernier @samp{.} et les caractères qui suivent)
pour chaque nom de fichier.@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(basename @var{names}@dots{})
Extrait la base du nom pour chaque nom de fichier (c'est-à-dire le nom
sans le suffixe).@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(addsuffix @var{suffix},@var{names}@dots{})
Ajoute @var{suffix} à chaque mot dans @var{names}.@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(addprefix @var{prefix},@var{names}@dots{})
Ajoute au début de chaque mots de @var{names} le @var{prefix} .@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(join @var{list1},@var{list2})
Concatène de listes parallèles de mots.@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(wildcard @var{pattern}@dots{})
Trouve les noms de fcihiers, qui correspondent un motif shell de nom de
fichier (@emph{pas} un motif @samp{%}).@*
@xref{La fonction Wildcard, ,The Function wildcard}.

@item $(realpath @var{names}@dots{})
Pour chaque nom de fichier dans @var{names}, le développe en utilisant
des réfrences absolues qui ne contiennent aucun code @code{.} ou
@code{..} ni aucun liens symboliques.@*
@xref{Les fonctions de noms de fichier, , Fonctions for File Names}.

@item $(abspath @var{names}@dots{})
Pour chaque nom de fichier dans @var{names}, développe en utilisant des
références absolues qui ne contiennent code @code{.} ou @code{..}, mais
en préservant les liens symboliques.@*
@xref{Les fonctions de noms de fichier, ,Fonctions for File Names}.

@item $(error @var{text}@dots{})
Quand cette fonction est évaluée, @code{make} génère une erreur fatale
avec le message @var{text}.@*
@xref{Les fonctions de contrôle de Make, ,Fonctions That Control Make}.

@item $(warning @var{text}@dots{})
Quand cette fonction est évaluée, @code{make} génère un avertissement
avec le message @var{text}.@*
@xref{Les fonctions de contrôle de Make, ,Fonctions That Control Make}.

@item $(shell @var{command})
Exécute une commande du shell et retourne sa sortie.@*
@xref{La fonction shell, , The @code{shell} Function}.

@item $(origin @var{variable})
Retourne une chaîne décrivant commant la variable @code{make}
@var{variable} est définie.@*
@xref{La fonction origin, , The origin Fuction}.

@item $(flavor @var{variable})
Retourne une chaîne décrivant la catégorie de la variable @code{make} @var{variable}.@*
@xref{La fonction Flavor, , The @code{flavor} Function}.

@item $(foreach @var{var},@var{words},@var{text})
Évalue @var{text} avec @var{var} lié à chacun des mots dans @var{words}
et concatène les résultats.@*
@xref{La fonction Foreach, ,The foreach Function}.

@item $(if @var{condition},@var{then-part}[,@var{else-part}])
Évalue la condition @var{condition}; si le résultat n'est pas vide,
substitue le développement de la partie @var{then-part}, sinon substitue
le développement de la partie @var{else-part}.@*
@xref{Fonctions conditionnelles, ,Fonctions for Conditionals}.

@item $(or @var{condition1}[,@var{condition2}[,@var{condition3}@dots{}]])
Évalue chaque condition @var{conditionN}, l'une après l'autre, et renvoie
le premier développement non vide. Si tous les développement sont vides,
renvoie la chaîne vide.@*
@xref{Fonctions conditionnelles, ,Fonctions for Conditionals}.

@item $(and @var{condition1}[,@var{condition2}[,@var{condition3}@dots{}]])
Évalue chaque condition @var{conditionN}, l'une après l'autre et si
l'une d'entre elle résulte en un chaîne vide, renvoie la chaîne vide. Si
tous les développements donnent des chaînes non vides, renvoie le
développement de la dernière @var{condition}.@*
@xref{Fonctions conditionnelles, ,Fonctions for Conditionals}.

@item $(call @var{var},@var{param},@dots{})
Évalue la variable @var{var} en remplaçant toute référence à @code{$(1)},
@code{$(2)} avec la première valeur, la seconde etc.@: de @var{param}.@*
@xref{La fonction Call, ,The @code{call} Function}.

@item $(eval @var{text})
Évalue @var{text} et lit le résultat comme une commande de Makefile. Se
développe en un chaîne vide.@*
@xref{Fonction Eval, ,The eval Function}.

@item $(file @var{op} @var{filename},@var{text})
Développe les arguments, puis ouvre le fichier @var{filename} en
utilisant le mode @var{op} et écrit le @var{text} dans ce fichier.@*
@xref{La fonction File, ,The @code{file} Function}.

@item $(value @var{var})
Évalue le contenu de la variable @var{var}, sans développement réalisé
dessus.@*
@xref{Fonction Value, ,The @code{value} Function}.
@end table

Voici un résumé des variables automatiques.  @xref{Les variables automatiques},
pour l'information plus complète.

@table @code
@item $@@
Le nom de fichier de la cible.

@item $%
Le nom du membre d'archive, quand la cible est un membre d'archive.

@item $<
Le nom du premier pré-requis.

@item $?
Les noms de tous les pré-requis, qui sont plus récents que la cible,
avec un espace entre eux. Pour les pré-requis qui sont des membres d'une
archive, seul le membre nommé est utilisé (@pxref{Les fichiers archivés}).

@item $^
@itemx $+
Les noms de tous les pré-requis, avec des espaces entre eux. Pour les
pré-requis qui sont des membres d'archive, seul le membre nommé est
utilisé (@pxref{Les fichiers archivés}).  La variable @code{$^} omet
les pré-requis dupliqués, alors que la variable @code{$+} les retients
et préserve leur ordre.

@item $*
Le radical, avec lequel un règle implicite correspond.
(@pxref{Correspondance de modèle, ,How Patterns Match}).

@item $(@@D)
@itemx $(@@F)
La partie répertoire et la partie donnant les fichiers dans le
répertoire @code{$@@}.

@item $(*D)
@itemx $(*F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$*}.

@item $(%D)
@itemx $(%F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$%}.

@item $(<D)
@itemx $(<F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$<}.

@item $(^D)
@itemx $(^F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$^}.

@item $(+D)
@itemx $(+F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$+}.

@item $(?D)
@itemx $(?F)
La partie répertoire et celle donnant les fichiers dans le répertoire de
@code{$?}.
@end table

Ces variables sont utilisées spécialement par GNU @code{make}:

@table @code
@item MAKEFILES

Makefiles to be read on every invocation of @code{make}.@*
@xref{La Variable MAKEFILES, ,The Variable @code{MAKEFILES}}.

@item VPATH

La chemin de recherche des répertoires pout les fichiers qui ne sont pas
trouvés dans le répertoire courant.@*
@xref{Recherche générale, , @code{VPATH} Search Path for All Prerequisites}.

@item SHELL

Le nom de l'interpréteur de commande par défaut du système, le plus
souvent @file{/bin/sh}.  Vous pouvez régler @code{SHELL} dans le
makefile pour changer le shell qui sera utilisé utilisé pour exécuter
les instructions.  @xref{Exécution, ,Recipe Exécution}.  La variable
@code{SHELL} est traité de manière particulière quand on importe ou on
exporte vers l’environnement.  @xref{Choisir le Shell}.

@item MAKESHELL

Sur MS-DOS seulement, le nom de l'interpréteur de commande qui est
utilisé par @code{make}.  La valeur de cette variable prend la
précédence sur la valeur de la variable @code{SHELL}.
@xref{Exécution, ,MAKESHELL variable}.

@item MAKE

Le nom avec lequel @code{make} est invoqué. Utiliser cette variable dans
les instructions a une signification particulière.
@xref{La variable MAKE, ,Comment la variable MAKE fonctionne}.

@item MAKE_VERSION

La variable pré-définie @samp{MAKE_VERSION} se développe en numéro de
version du programme GNU @code{make}.
@vindex MAKE_VERSION

@item MAKE_HOST

La variable pré-définie @samp{MAKE_HOST} se développe en un chaîne
representant l'hôte sur lequel GNU @code{make} a été bâti pour y fonctionner.
@vindex MAKE_HOST

@item MAKELEVEL

Le nombre de niveaux de répétitions (sub-@code{make}s).@*
@xref{La récursion et les variables}.

@item MAKEFLAGS

Les indicateurs (ndt. 'flags') donnés à @code{make}. Vous pouvez les régler
ceci dans l'environnement ou dans un Makefile.@*
@xref{Les options de récursions, ,Communicating Options to a Sub-@code{make}}.

Il n'est @emph{jamais} approprié d'utiliser @code{MAKEFLAGS} directement
dans une ligne d'instruction@tie{}: sont contenu pourrait ne pas être
échappé par des guillemets correctement pour son utilisation correct
dans le shell.  Il faut toujours permettre aux récursions de @code{make}
d'obtenir ces valeurs à travers l'environnement de ses parents.

@item GNUMAKEFLAGS

Les autres indicateurs (ndt. 'flags') analysés par @code{make}.  Vous
pouvez régler dans l'environnement ou dans un Makefile les indcateurs de
@code{make} en ligne de commande.  GNU @code{make} ne règle jamais cette
variable par lui-même.  Cette variable n'est utile que si vous voulez
des indicateurs spécifique à GNU @code{make} ans un Makefile qui suit la
norme POSIX. Cette variable sera vue par GNU @code{make} et ignorée par
d'autres implémentations de @code{make}.  Elle n'est pas utile si vous
n'utilisez que GNU @code{make}@tie{}; utilisez @code{MAKEFLAGS} directement.

@xref{Les options de récursions, ,Communicating Options to a Sub-@code{make}}.

@item MAKECMDGOALS

Les cibles données à @code{make} en ligne de commande.  Régler cet variable
n'a pas d'effet sur le fonctionnement de @code{make}.@*
@xref{Objectifs, ,Arguments to Specify the Objectifs}.

@item CURDIR

Règle le nom en mode absolu du chemin du répertoire courant (après que
toutes les options @code{-C} aient été exécutée, s'il y a). Régler cette
variable n'a pas d'effet sur le fonctionnement de @code{make}.@*
@xref{Récursion, ,Recursive Use of @code{make}}.

@item SUFFIXES

La liste des suffixes par défaut avant que @code{make} ne lise aucun Makefiles.

@item .LIBPATTERNS

Définie le nom des bibliothèques que @code{make} recherche et leur
ordre.@*
@xref{Recherche dans les bibliothèques, ,Directory Search for Link Libraries}.
@end table

@node Les messages d'erreurs, Makefile complexe, Référence rapide, Top
@comment  node-name,  next,  previous,  up
@appendix Erreurs générées par Make

Voici une liste des erreurs les plus communes que vous pourriez
voir générées par @code{make} et que quelques informations sur ce
qu'elles signifient et comment réparer.

Parfois les erreurs de @code{make} sont fatales, particulièrement en
présence du préfixe @code{-} sur la ligne d'instruction ou de l'option
@code{-k} en ligne de commande. Les erreurs qui sont fatales sont
préfixées avec la chaîne @code{***}.

Les messages d'erreur sont tous préfixés avec le nom du programme (normalement
@samp{make}) oui, si l'erreur est trouvée dans un makefile, le nom du
fichier et le numéro de ligne contenant le problème.

Dans la table ci-dessous, ces préfixes de commande ne sont pas indiqués.

@table @samp

@item [@var{foo}] Error @var{NN}
@itemx [@var{foo}] @var{signal description}
Ces erreurs ne sont pas vraiment des erreurs de @code{make}.  Elles
signifient  que le programme que @code{make} invoqué comme un partie
d'une instruction a retourné un status non nul, donnant un code d'erreur
(@samp{Error @var{NN}}), que @code{make} interprète comme une erreur ou
il sort d'une autre façon anormale (avec un signal d'un certain type).
@xref{Erreurs dans les instructions, ,Erreurs dans les instructions}.

Si aucune chaîne @code{***} n'est attachée au message, ceci veut dire
qu'un sous processus s'est interrompu sur une erreur mais que la règle
dans le makefile était préfixée avec le caractère générique @code{-},
donc @code{make} a ignoré l'erreur.

@item manquant separator.  Stop.
@itemx manquant separator (did you mean TAB instead of 8 spaces?).  Stop.
Ceci veut dire que @code{make} n'a pas pu comprendre grand chose de la
ligne du makefile, qu'il a juste lue.  GNU @code{make} recherche les
différents séparateurs (@code{:}, @code{=}, caractère de préfixe
d'instruction, etc.) pour indiquer quelle sorte de ligne il est en train
d'analyser.  Ce message signifie qu'il n'a pas pu en trouver un de valable.

Une des raisons les plus communes pour ce message est que vous (ou peut
être votre éditeur oh combien utile, comme c'est le cas pour beaucoup
d'éditeurs de MS-Windows) avez essayé d'indenter vos lignes
d'instruction avec des espaces au lieu d'utiliser la caractère de
tabulation.  Dans ce cas, @code{make} utilisera la deuxième forme de
message d'erreur vu ci-dessus.  Souvenez-vous que chaque ligne
d'instruction doit commencer par un caractère de tabulation (excépté si
vous avez définir la variable @code{.RECIPEPREFIX}@tie{};
@pxref{Variables spéciales}).  Huit caractères d'espace ne comptent pas.
@xref{Règles syntaxiques}.

@item recipe commences before first target.  Stop.
@itemx manquant rule before recipe.  Stop.
Ceci signifie que la première chose trouvée dans le makefile semble être
une partie d'instruction@tie{}: cela commence par la caractère préfixe
d'une instruction, mais semble ne pas être une directive @code{make}
légale (comme un assibnement de variable).  Les instructions doivent
toujours être associées à une cible.

La seconde forme est générée si une ligne a un point virgule comme
premier caractère, qui ne soit pas un caractère d'espace blanc@tie{};
@code{make} comprend alors que vous avez laissé tomber la section
"cible@tie{}:@tie{}pré-requis" de la règle.  @xref{Règles syntaxiques}.

@item No rule to make target `@var{xxx}'.
@itemx No rule to make target `@var{xxx}', needed by `@var{yyy}'.
Ceci veut dire que @code{make} a décidé qu'il devait compiler une cible,
mais qu'ensuite il n'a pu trouver aucune instruction dans le makefile
disant comment le faire, que ce soit de manière explicite ou implicite
(inclues dans la bases de données des règles par défaut).

Si vous voulez que ce fichier soit compilé, il vous faudra ajouter une
règle dans votre makefile décrivant commant cette cible doit être
compilée. Les autres sources possibles de problème sont les typos dans
le makefile (si ce nom de fichier n'est pas la bon) ou un arbre des
sources corrompu (si ce fichier n'était pas supposé être compilé, mais
plutôt être simplement un pré-requis).

@item No targets specified and no makefile found.  Stop.
@itemx No targets.  Stop.
La première partie du message peut signifier que vous n'avez pas donné
de cible à compiler sur la ligne de commande et que @code{make} ne
trouve aucun makefile à lire.  La seconde partie dit qu'un certain
makefile a été trouvé, mais qu'il ne contenait aucun objectif par défaut
et qu'aucun n'a été donné à la ligne de commade.  GNU @code{make} n'a
rien à faire dans ce genre de situation.  @xref{Les arguments d'un
Makefile, ,Arguments pour définir le Makefile}.@refill

@item Makefile `@var{xxx}' was not found.
@itemx Included makefile `@var{xxx}' was not found.
Un makefile défini en ligne de commande (première forme) ou inclu
(seconde forme) pas été trouvé.

@item warning: overriding recipe for target `@var{xxx}'
@itemx warning: ignoring old recipe for target `@var{xxx}'
GNU @code{make} ne permet de définir qu'une seule instruction par cible
(excépté pour les règles à double double points). Si vous donner une
instruction pour une cible qui en a déjà une, ce message d'avertissement
est renvoyé et la seconde instruction remplacera les effets de la première.
@xref{Les règles multiples, ,Les règles multiples pour une seule cible}.

@item Circular @var{xxx} <- @var{yyy} dependency dropped.
Ceci veut dire que @code{make} a détecté un bouclage dans le graphe des
dépendances@tie{}: après avoir suivi les pré-requis @var{yyy} de la
cible @var{xxx} et ses pré-requis, etc., l'un d'entre eux dépend de
nouveau de @var{xxx}.

@item Recursive variable `@var{xxx}' references itself (eventually).  Stop.
Ceci signifie que vous avez défini une variable @code{make} normale
(récursive) @var{xxx} qui, quand elle est développée, se réfèrera à elle
même (@var{xxx}).  Ceci est défendu@tie{}; utlisez soit une variable
développée simplement (@samp{:=} or @samp{::=}) ou utilisez l'opérateur
d'ajout (@samp{+=}).  @xref{Utiliser les variables, ,Comment utiliser
les variables}.

@item Unterminated variable reference.  Stop.
Ceci veut dire que vous avez oublié d'entrer la parenthèse fermante
adéquate ou l'accolade dans votre référence de variable ou de fonction.

@item insufficient arguments to function `@var{xxx}'.  Stop.
Ceci signifie que vous n'avez pas fourni le nombre requis d'arguments
pour ces fonction.  Voyez la documentation de cette fonction pour une
description de ses arguments.  @xref{Les fonctions, ,Fonctions pour modifier
du texte}.

@item missing target pattern.  Stop.
@itemx multiple target patterns.  Stop.
@itemx target pattern contains no `%'.  Stop.
@itemx mixed implicit and static pattern rules.  Stop.
Ces erreurs sont générées pour les modèles de règles malformés
(@pxref{Utilisation statique, ,Syntaxe des modèles de règles statique}).
La première signifie que la partie de la règle qui donne le modèle de
cible est vide@tie{}; le second signifie qu'il y a plusieurs caractères
génériques (@code{%}) dans la partie qui donne le modèle de cible@tie{};
le troisième signifie qu'il n'y a pas de caractère générique dans la
partie donnant le modèle de cible@tie{}; et la quatrième signifie que les trois parties du
modèle de la règle statique contiennent le caractère générique
(@code{%}) ---@tie{}or la première partie ne devrait pas contenir ce
caractère générique.

Si vous voyez ces erreurs and que vous n'êtes pas en train d'essayez de
créer un modèle statique de règle, vérifiez les valeurs de toutes les
cibles et les listes de pré-requis pour être sûr qu'ils ne contiennent
pas de de doubles points.

@item warning: -jN forced in submake: disabling jobserver mode.

Cet avertissment et le texte sont générés si @code{make} détecte une
erreur de conditions en relation avec une exécution parallèle sur des
systèmes où des sous-@code{make}s peuvent communiquer (@pxref{Les
options de récursions, ,Communiquer des options à un sous-@code{make}}).
Cet avertissement est généré si une invocation récursive d'un processus
@code{make} doit avoir @samp{-j@var{N}} dans la liste de ses arguments
(où @var{N} est plus grand que un).  Cela pourrait intervenir, par
exemple, si vous réglez la variable d'environnement @code{MAKE} à
@samp{make -j2}.  Dans ce cas, le sous-@code{make} ne communique 
pas avec les autres processus @code{make} et il va simplement prétendre
qu'il a deux processus pour lui.

@item warning: jobserver unavailable: using -j1.  Add `+' to parent make rule.
Pour que @code{make} démarre une communication, le parent passe une
information à l'enfant.  Commne ceci pourrait causer des problèmes si
processus enfant n'est en réalité pas un @code{make}, le parent le fera
seulment s'il pense que l'enfant est un processus @code{make}.  Le
parent utilise un algorithme normal pour déterminer (@pxref{La variable
MAKE, ,comment la variable MAKE fonctionne}).  Si le makefile est construit
de telle façon que le parent ne sache pas si le processus enfant est un
processus @code{make}, alors le processus enfant ne recevra qu'une
partie de l'information necessaire.  Dans ce cas, l'enfant genèrera ce
message d'avertissement et procèdera avec avec le programme construit de
manière séquentielle.

@item warning: ignoring prerequisites on suffix rule definition
Selon POSIX, une règle de suffixe ne peut pas contenir de pré-requis. Si
une règle qui pourrait être une règle de suffixe a des pré-requis elle
est interprétée comme une simple règle explicite, avec un nom de cible
bizarre. Cette exigence est respectée quand le mode de conformité POSIX
est activé (la cible @code{.POSIX} est définie).  Dans les version GNU
de @code{make} avant la version 4.3, aucun avertissement n'est émis et
une règle de suffixe étaot créée, cependant tous les pré-requis sont
ignorés et ils ne font pas partie de la règle de suffixe.  En démarrant
GNU @code{make} 4.3 le comportement est le même et en addition, cet
avertissement est généré.  Dans une future version, le comportement en
conformité POSIX sera le seul comportement@tie{}: aucune règle avec un
pré-requis ne peut être une règle de suffixe et cet avertissement sera
enlevé.

@end table

@node Makefile complexe, License de la documentation libre GNU, Les messages d'erreurs, Top
@appendix Exemple de Makefile complexe

Voici le makefile pour le programme GNU @code{tar}.  C'est un makefile
modérément complexe.  La première ligne utilise le règlage  @code{#!}
pour permettre au makefile d'être exécuté directement.

Parceque c'est la première cible, l'objectif par défaut est @samp{all}.
Une fonctionalité intéressante de ce makefile est que @file{testpad.h}
est un fichier source créé automatiquement par le programme
@code{testpad}, lui-meême compilé à partir de @file{testpad.c}.

Si vous tapez @samp{make} ou @samp{make all}, alors @code{make} créé l'exécutable
@file{tar}, le démon @file{rmt} qui donne l'accès à distance au stockage
et le ficher Info @file{tar.info}.

Si vous tapez @samp{make install}, alors @code{make} ne créé pas seulement
@file{tar}, @file{rmt}, et @file{tar.info}, mais aussi il les installe.

Si vous tapez @samp{make clean}, alors @code{make} enlève les fichiers @samp{.o},
et les fichiers @file{tar}, @file{rmt}, @file{testpad}, @file{testpad.h}, et
@file{core}.

Si vois tapez @samp{make distclean}, alors @code{make} n'enlève pas pas
seulement les mêmes fichiers que le fait @samp{make clean} mais aussi
les fichiers @file{TAGS}, @file{Makefile}, et @file{config.status}.
(Même si ce n'est pas évident, ce makefile (et @file{config.status}) est
généré par l'utilsateur avec le programme @code{configure}, qui est
fourni avec la distribution @code{tar}, mais n'est pas pas montré ici.)

Si vous tapez @samp{make realclean}, alors @code{make} enlèves les mêmes
fichier que le fait @samp{make distclean} et enlève aussi les fichiers
Info généré par @file{tar.texinfo}.

En addition, il y a des cibles @code{shar} et @code{dist} qui créé des
kits de distribution.

@example
@group
#!/usr/bin/make -f
# Generated automatically from Makefile.in by configure.
# Un*x Makefile for GNU tar program.
# Copyright (C) 1991 Free Software Foundation, Inc.
@end group

@group
# This program is free software; you can redistribute
# it and/or modify it under the terms of the GNU
# General Public License @dots{}
@dots{}
@dots{}
@end group

SHELL = /bin/sh

#### Start of system configuration section. ####

srcdir = .

@group
# If you use gcc, you should either run the
# fixincludes script that comes with it or else use
# gcc with the -traditional option.  Otherwise ioctl
# calls will be compiled incorrectly on some systems.
CC = gcc -O
YACC = bison -y
INSTALL = /usr/local/bin/install -c
INSTALLDATA = /usr/local/bin/install -c -m 644
@end group

# Things you might add to DEFS:
# -DSTDC_HEADERS        If you have ANSI C headers and
#                       libraries.
# -DPOSIX               If you have POSIX.1 headers and
#                       libraries.
# -DBSD42               If you have sys/dir.h (unless
#                       you use -DPOSIX), sys/file.h,
#                       and st_blocks in `struct stat'.
# -DUSG                 If you have System V/ANSI C
#                       string and memory functions
#                       and headers, sys/sysmacros.h,
#                       fcntl.h, getcwd, no valloc,
#                       and ndir.h (unless
#                       you use -DDIRENT).
# -DNO_MEMORY_H         If USG or STDC_HEADERS but do not
#                       include memory.h.
# -DDIRENT              If USG and you have dirent.h
#                       instead of ndir.h.
# -DSIGTYPE=int         If your signal handlers
#                       return int, not void.
# -DNO_MTIO             If you lack sys/mtio.h
#                       (magtape ioctls).
# -DNO_REMOTE           If you do not have a remote shell
#                       or rexec.
# -DUSE_REXEC           To use rexec for remote tape
#                       operations instead of
#                       forking rsh or remsh.
# -DVPRINTF_MISSING     If you lack vprintf function
#                       (but have _doprnt).
# -DDOPRNT_MISSING      If you lack _doprnt function.
#                       Also need to define
#                       -DVPRINTF_MISSING.
# -DFTIME_MISSING       If you lack ftime system call.
# -DSTRSTR_MISSING      If you lack strstr function.
# -DVALLOC_MISSING      If you lack valloc function.
# -DMKDIR_MISSING       If you lack mkdir and
#                       rmdir system calls.
# -DRENAME_MISSING      If you lack rename system call.
# -DFTRUNCATE_MISSING   If you lack ftruncate
#                       system call.
# -DV7                  On Version 7 Unix (not
#                       tested in a long time).
# -DEMUL_OPEN3          If you lack a 3-argument version
#                       of open, and want to emulate it
#                       with system calls you do have.
# -DNO_OPEN3            If you lack the 3-argument open
#                       and want to disable the tar -k
#                       option instead of emulating open.
# -DXENIX               If you have sys/inode.h
#                       and need it 94 to be included.

DEFS =  -DSIGTYPE=int -DDIRENT -DSTRSTR_MISSING \
        -DVPRINTF_MISSING -DBSD42
# Set this to rtapelib.o unless you defined NO_REMOTE,
# in which case make it empty.
RTAPELIB = rtapelib.o
LIBS =
DEF_AR_FILE = /dev/rmt8
DEFBLOCKING = 20

@group
CDEBUG = -g
CFLAGS = $(CDEBUG) -I. -I$(srcdir) $(DEFS) \
        -DDEF_AR_FILE=\"$(DEF_AR_FILE)\" \
        -DDEFBLOCKING=$(DEFBLOCKING)
LDFLAGS = -g
@end group

@group
prefix = /usr/local
# Prefix for each installed program,
# normally empty or `g'.
binprefix =

# The directory to install tar in.
bindir = $(prefix)/bin

# The directory to install the info files in.
infodir = $(prefix)/info
@end group

#### End of system configuration section. ####

@group
SRCS_C  = tar.c create.c extract.c buffer.c   \
          getoldopt.c update.c gnu.c mangle.c \
          version.c list.c names.c diffarch.c \
          port.c wildmat.c getopt.c getopt1.c \
          regex.c
SRCS_Y  = getdate.y
SRCS    = $(SRCS_C) $(SRCS_Y)
OBJS    = $(SRCS_C:.c=.o) $(SRCS_Y:.y=.o) $(RTAPELIB)
@end group
@group
AUX =   README COPYING ChangeLog Makefile.in  \
        makefile.pc configure configure.in \
        tar.texinfo tar.info* texinfo.tex \
        tar.h port.h open3.h getopt.h regex.h \
        rmt.h rmt.c rtapelib.c alloca.c \
        msd_dir.h msd_dir.c tcexparg.c \
        level-0 level-1 backup-specs testpad.c
@end group

.PHONY: all
all:    tar rmt tar.info

@group
tar:    $(OBJS)
        $(CC) $(LDFLAGS) -o $@@ $(OBJS) $(LIBS)
@end group

@group
rmt:    rmt.c
        $(CC) $(CFLAGS) $(LDFLAGS) -o $@@ rmt.c
@end group

@group
tar.info: tar.texinfo
        makeinfo tar.texinfo
@end group

@group
.PHONY: install
install: all
        $(INSTALL) tar $(bindir)/$(binprefix)tar
        -test ! -f rmt || $(INSTALL) rmt /etc/rmt
        $(INSTALLDATA) $(srcdir)/tar.info* $(infodir)
@end group

@group
$(OBJS): tar.h port.h testpad.h
regex.o buffer.o tar.o: regex.h
# getdate.y has 8 shift/reduce conflicts.
@end group

@group
testpad.h: testpad
        ./testpad
@end group

@group
testpad: testpad.o
        $(CC) -o $@@ testpad.o
@end group

@group
TAGS:   $(SRCS)
        etags $(SRCS)
@end group

@group
.PHONY: clean
clean:
        rm -f *.o tar rmt testpad testpad.h core
@end group

@group
.PHONY: distclean
distclean: clean 
       rm -f TAGS Makefile config.status
@end group

@group
.PHONY: realclean
realclean: distclean
        rm -f tar.info*
@end group

@group
.PHONY: shar
shar: $(SRCS) $(AUX)
        shar $(SRCS) $(AUX) | compress \\
          > tar-`sed -e '/version_string/!d' \\
                     -e 's/[^0-9.]*\\([0-9.]*\\).*/\\1/' \\
                     -e q
                     version.c`.shar.Z
@end group

@group
.PHONY: dist
dist: $(SRCS) $(AUX)
        echo tar-`sed \
             -e '/version_string/!d' \
             -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
             -e q
             version.c` > .fname
        -rm -rf `cat .fname`
        mkdir `cat .fname`
        ln $(SRCS) $(AUX) `cat .fname`
        tar chZf `cat .fname`.tar.Z `cat .fname`
        -rm -rf `cat .fname` .fname
@end group

@group
tar.zoo: $(SRCS) $(AUX)
        -rm -rf tmp.dir
        -mkdir tmp.dir
        -rm tar.zoo
        for X in $(SRCS) $(AUX) ; do \
            echo $$X ; \
            sed 's/$$/^M/' $$X \
            > tmp.dir/$$X ; done
        cd tmp.dir ; zoo aM ../tar.zoo *
        -rm -rf tmp.dir
@end group
@end example

@node License de la documentation libre GNU, Traduction de la license de la documentation libre GNU, Makefile complexe, Top
@appendix License de la documentation libre GNU (orginal en Anglais)
@cindex FDL, GNU Licence de la Documentation Libre
@include fdl.texi

@node Traduction de la license de la documentation libre GNU, Index des concepts, License de la documentation libre GNU, Top
@appendix Traduction de license de la documentation libre GNU
@cindex FDL, GNU Licence de la Documentation Libre
@include fdl.fr.texi


@node Index des concepts, Index des noms, License de la documentation libre GNU, Top
@unnumbered Index des concepts

@printindex cp

@node Index des noms, , Index des concepts, Top
@unnumbered Index des fonctions, variables et directives

@printindex fn

@bye
